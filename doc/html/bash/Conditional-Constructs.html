<html lang="en">
<head>
<title>Conditional Constructs - Bash Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Bash Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Compound-Commands.html#Compound-Commands" title="Compound Commands">
<link rel="prev" href="Looping-Constructs.html#Looping-Constructs" title="Looping Constructs">
<link rel="next" href="Command-Grouping.html#Command-Grouping" title="Command Grouping">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This text is a brief description of the features that are present in
the Bash shell (version 4.1, 23 December 2009).

This is Edition 4.1, last updated 23 December 2009,
of `The GNU Bash Reference Manual',
for `Bash', Version 4.1.

Copyright (C) 1988--2009 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being ``A GNU Manual'', and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License''.

     (a) The FSF's Back-Cover Text is: You are free to copy and modify
     this GNU manual.  Buying copies from GNU Press supports the FSF in
     developing GNU and promoting software freedom.''

   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Conditional-Constructs"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Command-Grouping.html#Command-Grouping">Command Grouping</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Looping-Constructs.html#Looping-Constructs">Looping Constructs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Compound-Commands.html#Compound-Commands">Compound Commands</a>
<hr>
</div>

<h5 class="subsubsection">3.2.4.2 Conditional Constructs</h5>

<p><a name="index-commands_002c-conditional-47"></a>
     <dl>
<dt><code>if</code><dd><a name="index-if-48"></a><a name="index-then-49"></a><a name="index-else-50"></a><a name="index-elif-51"></a><a name="index-fi-52"></a>The syntax of the <code>if</code> command is:

     <pre class="example">          if <var>test-commands</var>; then
            <var>consequent-commands</var>;
          [elif <var>more-test-commands</var>; then
            <var>more-consequents</var>;]
          [else <var>alternate-consequents</var>;]
          fi
</pre>
     <p>The <var>test-commands</var> list is executed, and if its return status is zero,
the <var>consequent-commands</var> list is executed. 
If <var>test-commands</var> returns a non-zero status, each <code>elif</code> list
is executed in turn, and if its exit status is zero,
the corresponding <var>more-consequents</var> is executed and the
command completes. 
If &lsquo;<samp><span class="samp">else </span><var>alternate-consequents</var></samp>&rsquo; is present, and
the final command in the final <code>if</code> or <code>elif</code> clause
has a non-zero exit status, then <var>alternate-consequents</var> is executed. 
The return status is the exit status of the last command executed, or
zero if no condition tested true.

     <br><dt><code>case</code><dd><a name="index-case-53"></a><a name="index-in-54"></a><a name="index-esac-55"></a>The syntax of the <code>case</code> command is:

     <pre class="example">          <code>case </code><var>word</var><code> in [ [(] </code><var>pattern</var><code> [| </code><var>pattern</var><code>]...) </code><var>command-list</var><code> ;;]... esac</code>
</pre>
     <p><code>case</code> will selectively execute the <var>command-list</var> corresponding to
the first <var>pattern</var> that matches <var>word</var>. 
If the shell option <code>nocasematch</code>
(see the description of <code>shopt</code> in <a href="The-Shopt-Builtin.html#The-Shopt-Builtin">The Shopt Builtin</a>)
is enabled, the match is performed without regard to the case
of alphabetic characters. 
The &lsquo;<samp><span class="samp">|</span></samp>&rsquo; is used to separate multiple patterns, and the &lsquo;<samp><span class="samp">)</span></samp>&rsquo;
operator terminates a pattern list. 
A list of patterns and an associated command-list is known
as a <var>clause</var>.

     <p>Each clause must be terminated with &lsquo;<samp><span class="samp">;;</span></samp>&rsquo;, &lsquo;<samp><span class="samp">;&amp;</span></samp>&rsquo;, or &lsquo;<samp><span class="samp">;;&amp;</span></samp>&rsquo;. 
The <var>word</var> undergoes tilde expansion, parameter expansion, command
substitution, arithmetic expansion, and quote removal before matching is
attempted.  Each <var>pattern</var> undergoes tilde expansion, parameter
expansion, command substitution, and arithmetic expansion.

     <p>There may be an arbitrary number of <code>case</code> clauses, each terminated
by a &lsquo;<samp><span class="samp">;;</span></samp>&rsquo;, &lsquo;<samp><span class="samp">;&amp;</span></samp>&rsquo;, or &lsquo;<samp><span class="samp">;;&amp;</span></samp>&rsquo;. 
The first pattern that matches determines the
command-list that is executed.

     <p>Here is an example using <code>case</code> in a script that could be used to
describe one interesting feature of an animal:

     <pre class="example">          echo -n "Enter the name of an animal: "
          read ANIMAL
          echo -n "The $ANIMAL has "
          case $ANIMAL in
            horse | dog | cat) echo -n "four";;
            man | kangaroo ) echo -n "two";;
            *) echo -n "an unknown number of";;
          esac
          echo " legs."
</pre>
     <p class="noindent">If the &lsquo;<samp><span class="samp">;;</span></samp>&rsquo; operator is used, no subsequent matches are attempted after
the first pattern match. 
Using &lsquo;<samp><span class="samp">;&amp;</span></samp>&rsquo;  in place of &lsquo;<samp><span class="samp">;;</span></samp>&rsquo; causes execution to continue with
the <var>command-list</var> associated with the next clause, if any. 
Using &lsquo;<samp><span class="samp">;;&amp;</span></samp>&rsquo; in place of &lsquo;<samp><span class="samp">;;</span></samp>&rsquo; causes the shell to test the patterns
in the next clause, if any, and execute any associated <var>command-list</var>
on a successful match.

     <p>The return status is zero if no <var>pattern</var> is matched.  Otherwise, the
return status is the exit status of the <var>command-list</var> executed.

     <br><dt><code>select</code><dd><a name="index-select-56"></a>
The <code>select</code> construct allows the easy generation of menus. 
It has almost the same syntax as the <code>for</code> command:

     <pre class="example">          select <var>name</var> [in <var>words</var> ...]; do <var>commands</var>; done
</pre>
     <p>The list of words following <code>in</code> is expanded, generating a list
of items.  The set of expanded words is printed on the standard
error output stream, each preceded by a number.  If the
&lsquo;<samp><span class="samp">in </span><var>words</var></samp>&rsquo; is omitted, the positional parameters are printed,
as if &lsquo;<samp><span class="samp">in "$@"</span></samp>&rsquo; had been specified. 
The <samp><span class="env">PS3</span></samp> prompt is then displayed and a line is read from the
standard input. 
If the line consists of a number corresponding to one of the displayed
words, then the value of <var>name</var> is set to that word. 
If the line is empty, the words and prompt are displayed again. 
If <code>EOF</code> is read, the <code>select</code> command completes. 
Any other value read causes <var>name</var> to be set to null. 
The line read is saved in the variable <samp><span class="env">REPLY</span></samp>.

     <p>The <var>commands</var> are executed after each selection until a
<code>break</code> command is executed, at which
point the <code>select</code> command completes.

     <p>Here is an example that allows the user to pick a filename from the
current directory, and displays the name and index of the file
selected.

     <pre class="example">          select fname in *;
          do
          	echo you picked $fname \($REPLY\)
          	break;
          done
</pre>
     <br><dt><code>((...))</code><dd>
     <pre class="example">          (( <var>expression</var> ))
</pre>
     <p>The arithmetic <var>expression</var> is evaluated according to the rules
described below (see <a href="Shell-Arithmetic.html#Shell-Arithmetic">Shell Arithmetic</a>). 
If the value of the expression is non-zero, the return status is 0;
otherwise the return status is 1.  This is exactly equivalent to
     <pre class="example">          let "<var>expression</var>"
</pre>
     <p class="noindent">See <a href="Bash-Builtins.html#Bash-Builtins">Bash Builtins</a>, for a full description of the <code>let</code> builtin.

     <br><dt><code>[[...]]</code><dd><a name="index-g_t_005b_005b-57"></a><a name="index-g_t_005d_005d-58"></a>
     <pre class="example">          [[ <var>expression</var> ]]
</pre>
     <p>Return a status of 0 or 1 depending on the evaluation of
the conditional expression <var>expression</var>. 
Expressions are composed of the primaries described below in
<a href="Bash-Conditional-Expressions.html#Bash-Conditional-Expressions">Bash Conditional Expressions</a>. 
Word splitting and filename expansion are not performed on the words
between the &lsquo;<samp><span class="samp">[[</span></samp>&rsquo; and &lsquo;<samp><span class="samp">]]</span></samp>&rsquo;; tilde expansion, parameter and
variable expansion, arithmetic expansion, command substitution, process
substitution, and quote removal are performed. 
Conditional operators such as &lsquo;<samp><span class="samp">-f</span></samp>&rsquo; must be unquoted to be recognized
as primaries.

     <p>When used with &lsquo;<samp><span class="samp">[[</span></samp>&rsquo;, The &lsquo;<samp><span class="samp">&lt;</span></samp>&rsquo; and &lsquo;<samp><span class="samp">&gt;</span></samp>&rsquo; operators sort
lexicographically using the current locale.

     <p>When the &lsquo;<samp><span class="samp">==</span></samp>&rsquo; and &lsquo;<samp><span class="samp">!=</span></samp>&rsquo; operators are used, the string to the
right of the operator is considered a pattern and matched according
to the rules described below in <a href="Pattern-Matching.html#Pattern-Matching">Pattern Matching</a>. 
If the shell option <code>nocasematch</code>
(see the description of <code>shopt</code> in <a href="The-Shopt-Builtin.html#The-Shopt-Builtin">The Shopt Builtin</a>)
is enabled, the match is performed without regard to the case
of alphabetic characters. 
The return value is 0 if the string matches (&lsquo;<samp><span class="samp">==</span></samp>&rsquo;) or does not
match (&lsquo;<samp><span class="samp">!=</span></samp>&rsquo;)the pattern, and 1 otherwise. 
Any part of the pattern may be quoted to force it to be matched as a
string.

     <p>An additional binary operator, &lsquo;<samp><span class="samp">=~</span></samp>&rsquo;, is available, with the same
precedence as &lsquo;<samp><span class="samp">==</span></samp>&rsquo; and &lsquo;<samp><span class="samp">!=</span></samp>&rsquo;. 
When it is used, the string to the right of the operator is considered
an extended regular expression and matched accordingly (as in <i>regex</i>3)). 
The return value is 0 if the string matches
the pattern, and 1 otherwise. 
If the regular expression is syntactically incorrect, the conditional
expression's return value is 2. 
If the shell option <code>nocasematch</code>
(see the description of <code>shopt</code> in <a href="The-Shopt-Builtin.html#The-Shopt-Builtin">The Shopt Builtin</a>)
is enabled, the match is performed without regard to the case
of alphabetic characters. 
Any part of the pattern may be quoted to force it to be matched as a
string. 
Substrings matched by parenthesized subexpressions within the regular
expression are saved in the array variable <code>BASH_REMATCH</code>. 
The element of <code>BASH_REMATCH</code> with index 0 is the portion of the string
matching the entire regular expression. 
The element of <code>BASH_REMATCH</code> with index <var>n</var> is the portion of the
string matching the <var>n</var>th parenthesized subexpression.

     <p>Expressions may be combined using the following operators, listed
in decreasing order of precedence:

          <dl>
<dt><code>( </code><var>expression</var><code> )</code><dd>Returns the value of <var>expression</var>. 
This may be used to override the normal precedence of operators.

          <br><dt><code>! </code><var>expression</var><dd>True if <var>expression</var> is false.

          <br><dt><var>expression1</var><code> &amp;&amp; </code><var>expression2</var><dd>True if both <var>expression1</var> and <var>expression2</var> are true.

          <br><dt><var>expression1</var><code> || </code><var>expression2</var><dd>True if either <var>expression1</var> or <var>expression2</var> is true. 
</dl>
     The <code>&amp;&amp;</code> and <code>||</code> operators do not evaluate <var>expression2</var> if the
value of <var>expression1</var> is sufficient to determine the return
value of the entire conditional expression.

   </dl>

   </body></html>

