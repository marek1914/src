ARMv8 AArch64 Processor

projectNe10
Ne10 项目

Thumb-2 Technology Delivers the peak performance of traditional ARM code while also providing up to a 30% reduction in memory required to store instructions. 

Vectorizing compilers:

vmov

定义宏
.macro 宏名 参数名列表
	宏体
.endm
如果使用参数，宏体中使用该参数时添加前缀"\"


aarch32
aarch64

ETM:Embedded Trace Macrocell
ETB:Embedded Trace Buffer
用于跟踪
ARM GIC: Generic Interrupt Controller

ThumbEE:Thumb Execution Environment

ARMv6T2 Introduces Thumb-2 technology
Thumb-2 : Thumb的编码密度，ARM 指令集32-bit效能。

ThumbEE，用于字节码语言的执行，比如java python perl，那为啥没有armee呢？A

VFP 架构也支援 SIMD（理解了）

Thumb状态：执行Thumb指令的处理器状态。BX、BLX 等指令完成时，切换到ARM状态


ISETSTATE 指令集4状态：ARM Thumb Jazelle(用于jvm) ThumbEE

 Cortex-A5 的FPU是VFPv4-D16
 AHB用于高性能模块(如CPU、DMA和DSP等)之间的连接，作为SoC的片上系统总线
 
 
 bit.LITTLE 用于在 Cortex-A15 和 Cortex-A7 之间切换

如三星某款8核处理器，由4核A15+4核A7组成

身材魁梧高大的男士是big，身材娇小的女士是LITTLE
Bit先生负责具有挑战性的重任
Little小姐负责小任务

vfpv3 vfpv3-d16 vfpv4 vfpv4-d16

FLOPS是Floating-point Operations Per Second

arm的cache（数据/指令）使用前必需先 flush

PrimeCell:
General Purpose Input/Output (PL060)
UART (PL011)


VFP:
ARM 浮点架构 (VFP) 为半精度、单精度和双精度浮点运算中的浮点操作提供硬件支持。符合IEEE754，并提供完全软件库支持。 
浮点功能为汽车动力系统、车身控制应用和图像应用（如打印中的缩放、转换和字体生成以及图形中的 3D 转换、FFT 和过滤）中使用的浮点运算提供增强的性能。

应用
    汽车控制应用/动力系统/ABS、牵引控制和主动悬架
    图像/激光打印机
    工业控制系统/运动控制

ARM VFP 提供的浮点的动态范围和准确性。与 NEON™ 多媒体处理功能结合使用可增强性能（如缩放、2D/3D转换、字体生成和数字过滤）。

VFPv1 已废弃
VFPv2 ARMv5/ARMv6
VFPv3 ARMv7-A/R 中 ARM/Thumb/ThumbEE指令集的可选扩展
      16个双精度(VFPv3-D32)或32个单精度(VFPv3-D16)寄存器


GNU EABI is a new application binary interface (ABI) for Linux. 
It is part of a new family of ABIs from ARM.

Why switch to EABI?

The EABI:
Allows use of optimized hardfloat functions with the system's softfloat libraries
Uses a more efficient syscall convention
Will be more compatible with future tools

The ability to mix floating point code is the most important new feature. 

Debian has used hardfloat FPA instructions for floating point arithmetic. 
Very few ARM CPUs actually support FPA (a specific kind of floating point acceleration) 
but ARM-Linux kernels can emulate FPA instructions. 
They do this through illegal instruction faults which are rather inefficient. 
Emulating floating point instructions using softfloat (-msoftfloat) can be 4 to 10 times faster than kernel emulation. 
Prior to the introduction of EABI, the only way to use softfloat was to recompile the entire root file system with softfloat enabled. 
With EABI, softfloat instructions will be used by default and the root file system can have a mixture of softfloat and hardfloat. 
Now, if you have a system with floating point hardware -- it doesn't have to be FPA, it can be something else -- you can recompile critical software with the appropriate hardfloat instructions and run it on a system along with software that uses softfloat.

We have systems that use VFP (Vector Floating Points)



Arm EABI:
* ABI flags passed by gcc to binutils: -mabi=aapcs-linux -mfloat-abi=soft -meabi=4
* objdump -x for compiled binary: 

EABI is supported in the ARM Linux kernel from version 2.6.16 and there is an optional compatibility feature to allow the running of old-ABI binaries with an EABI kernel

4. Drop Thumb interworking

A final option would be simply to compile the standard Debian repo --with-arch=armv4 --with-no-thumb-interwork. This would work on all processors without the dangers inherent in modifying GCC and, according to the GCC manual page, saves a slight size and speed overhead caused by being thumb-interworkable.


Why a new port

In Debian, we want to assure complete binary compatibility. Since the old ABI is not compatible with the new one, we can't allow packages built with old ABI to link against new-abi libs, or the other direction. So the options are:

For the last point, a statically compiled [ArchTakeover] tool could be created. This would also allow i386->amd64 style migrations.


API - ABI

EABI: Embedded Application Binary Interface

  In computer software, an application binary interface (ABI) describes the low-level
  interface between an application program and the operating system or another application.
  GNU EABI is a new application binary interface (ABI) for Linux.
  EABI规定：
  1)应用程序如何发出系统调用来trap到内核态.
  2)如何使用机器的寄存器,RISC处理器的ABI就要规定用那个通用寄存器来作stack pointer和frame pointer.
  3)规定如何进行procedure call.
  EABI is the new "Embedded" ABI by ARM ltd
  The effective changes for users are:
    * Floating point performance, with or without an FPU is very much faster, 
      and mixing soft and hardfloat code is possible
    * Structure packing is not as painful as it used to be (曾经是)
    * More compatibility with various tools (in future - currently linux-elf is well supported)
    * A more efficient syscall convention
    * At present (with gcc-4.1.1) it works with ARMv4t, ARMv5t processors and above, 
      but supporting ARMv4 (e.g., StrongARM) requires toolchain modifications.

对于浮点运行会预设硬浮点运算FPA(Float Point Architecture)，而没有FPA的CPU会用FPE
(Float Point Emulation 软浮点)，速度上就会遇到限制，使用EABI(Embedded Application
 Binary Interface)可以对此改善，ARM EABI有许多革新之处，其中最突出的改进就是Float 
Point Performance，它使用Vector Float Point(矢量浮点)，
因此可以提高涉及到浮点运算的程序


oabi eabi 都是针对arm的cpu来说的
eabi 有时候也叫做gnu eabi
eabi的好处： 1 支持软件浮点合硬件浮点 实现浮点功能的混用
	     2 系统调用的效率更高 ？？
             3 软件浮点的情况下，EABI的软件浮点的效率要比oabi高很多
eabi 和 oabi 的区别
	 1 调用规则 包括参数传递以及如何获得返回值
         2 应用程序如何去做系统调用
         3 结构体中的填充和对其 （ padding packing ）

