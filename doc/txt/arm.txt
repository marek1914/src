ARMv8 48位寻址，256TB
AArch64 Processor

64bit处理器能进行更大范围的整数运算和更大内存
不能简单认为64bit性能是32bit的两倍


projectNe10

Ne10 项目

Thumb-2 Technology Delivers the peak performance of traditional ARM code while also providing up to a 30% reduction in memory required to store instructions. 

NEON technology can accelerate multimedia and signal processing algorithms such as video encode/decode, 2D/3D graphics, gaming, audio and speech processing, image processing, telephony, and sound synthesis by at least 2x the performance of ARMv6 SIMD.

NEON technology is a 128 bit SIMD architecture, It has 32/16 registers, 64/128-bits wide

Registers are considered as vectors of elements of the same data type
Data types: signed/unsigned 8-bit, 16-bit, 32-bit, 64-bit, single precision floating point

    * Simple DSP algorithms can show larger performance boost (4x-8x)
    * Processor can sleep sooner, resulting in overall dynamic power saving 
    * Aligned and unaligned data access allows for efficient vectorization of SIMD operations.
    * Clean instruction set architecture designed for autovectorizing compilers and hand coding.
    * Efficient access to packed arrays such as ARGB or xyz coordinates
    * Support for both integer and floating point operations ensures adaptability to a broad range of applications 
    * dual 128-bit/64-bit views enables efficient handling of data and minimizes access to memory, enhancing data throughput.

How to use NEON
OpenMAX DL library:
    * Recommended approach to accelerate AV codecs
    * Supports formats: MPEG-4 simple profile, H.264 baseline, JPEG, MP3, AAC
    * Supports functions: FIR, IIR, FFT, Dot Product, Color space conversion, de-blocking.de-ringing, rotation, scaling, composition

Vectorizing compilers:
    * Exploits NEON SIMD automatically with existing source code
    * Supported by ARM RealView Development Suite (v3.1 Pro and later)
    * Supported by gcc

C intrinsics:
    * C function call interface to NEON operations
    * Supports all data types and operations supported by NEON
    * Supported in ARM RealView Development Suite (version 3.1 and later) and gcc

Assembler:
    * For those who really want to optimize at the lowest level
    * Supported in ARM's RealView Development Suite (version 3.1 and later) and gcc(>2007q3)

NEON Support in the Open Source Community

    * Android - NEON optimizations
          o Skia library, S32A_D565_Opaque  is 5x faster using NEON
    * Ubuntu 09.04 support NEON:
    * Pixman (part of Cairo 2D graphic library)
          o Compositing/alpha blending
          o eg fbCompositeSolidMask_nx8x0565neon  is 8x faster using NEON
    * ffmpeg - libavcodec

vmov




定义宏
.macro 宏名 参数名列表
	宏体
.endm
如果使用参数，宏体中使用该参数时添加前缀"\"


aarch32
aarch64

ETM:Embedded Trace Macrocell
ETB:Embedded Trace Buffer
用于跟踪
ARM GIC: Generic Interrupt Controller

ThumbEE:Thumb Execution Environment

ARMv6T2 Introduces Thumb-2 technology
Thumb-2 : Thumb的编码密度，ARM 指令集32-bit效能。

ThumbEE，用于字节码语言的执行，比如java python perl，那为啥没有armee呢？A

VFP 架构也支援 SIMD（理解了）

Thumb状态：执行Thumb指令的处理器状态。BX、BLX 等指令完成时，切换到ARM状态


ISETSTATE 指令集4状态：ARM Thumb Jazelle(用于jvm) ThumbEE

 Cortex-A5 的FPU是VFPv4-D16
 AHB用于高性能模块(如CPU、DMA和DSP等)之间的连接，作为SoC的片上系统总线
 
 
 bit.LITTLE 用于在 Cortex-A15 和 Cortex-A7 之间切换

如三星某款8核处理器，由4核A15+4核A7组成

身材魁梧高大的男士是big，身材娇小的女士是LITTLE
Bit先生负责具有挑战性的重任
Little小姐负责小任务

vfpv3 vfpv3-d16 vfpv4 vfpv4-d16

FLOPS是Floating-point Operations Per Second

arm的cache（数据/指令）使用前必需先 flush

PrimeCell:
General Purpose Input/Output (PL060)
UART (PL011)


VFP:
ARM 浮点架构 (VFP) 为半精度、单精度和双精度浮点运算中的浮点操作提供硬件支持。符合IEEE754，并提供完全软件库支持。 
浮点功能为汽车动力系统、车身控制应用和图像应用（如打印中的缩放、转换和字体生成以及图形中的 3D 转换、FFT 和过滤）中使用的浮点运算提供增强的性能。

应用
    汽车控制应用/动力系统/ABS、牵引控制和主动悬架
    图像/激光打印机
    工业控制系统/运动控制

ARM VFP 提供的浮点的动态范围和准确性。与 NEON™ 多媒体处理功能结合使用可增强性能（如缩放、2D/3D转换、字体生成和数字过滤）。

VFP 架构版本

迄今为止，VFP 主要有三个版本：
    VFPv1 已废弃
    VFPv2 对ARMv5TE/ARMv5TEJ/ARMv6 架构中ARM指令集的可选扩展。
    VFPv3 对ARMv7-A/ARMv7-R 中 ARM/Thumb/ThumbEE指令集的可选扩展。
          16个双精度或32个单精度寄存器，VFPv3-D32/VFPv3-D16用于区别这两个实现选项




What is EABI(Embedded ABI)?

GNU EABI is a new application binary interface (ABI) for Linux. 
It is part of a new family of ABIs from ARM.

Why switch to EABI?

The EABI:
Allows use of optimized hardfloat functions with the system's softfloat libraries
Uses a more efficient syscall convention
Will be more compatible with future tools

The ability to mix floating point code is the most important new feature. 

Debian has used hardfloat FPA instructions for floating point arithmetic. 
Very few ARM CPUs actually support FPA (a specific kind of floating point acceleration) 
but ARM-Linux kernels can emulate FPA instructions. 
They do this through illegal instruction faults which are rather inefficient. 
Emulating floating point instructions using softfloat (-msoftfloat) can be 4 to 10 times faster than kernel emulation. 
Prior to the introduction of EABI, the only way to use softfloat was to recompile the entire root file system with softfloat enabled. 
With EABI, softfloat instructions will be used by default and the root file system can have a mixture of softfloat and hardfloat. 
Now, if you have a system with floating point hardware -- it doesn't have to be FPA, it can be something else -- you can recompile critical software with the appropriate hardfloat instructions and run it on a system along with software that uses softfloat.

We have systems that use VFP (Vector Floating Points)



Arm EABI:
* ABI flags passed by gcc to binutils: -mabi=aapcs-linux -mfloat-abi=soft -meabi=4
* objdump -x for compiled binary: 

EABI is supported in the ARM Linux kernel from version 2.6.16 and there is an optional compatibility feature to allow the running of old-ABI binaries with an EABI kernel

The inverse mechanism, to run EABI binaries in an ABI kernel, is not implemented. 

QEMU can run ARM EABI systems 


4. Drop Thumb interworking

A final option would be simply to compile the standard Debian repo --with-arch=armv4 --with-no-thumb-interwork. This would work on all processors without the dangers inherent in modifying GCC and, according to the GCC manual page, saves a slight size and speed overhead caused by being thumb-interworkable.


Why a new port

In Debian, we want to assure complete binary compatibility. Since the old ABI is not compatible with the new one, we can't allow packages built with old ABI to link against new-abi libs, or the other direction. So the options are:

0. Not an option!

Under no circumstances distribute EABI binaries as .arm.deb depending on current library package names!!!

1. Rename all library packages

This is an ABI transition that affects all architectures, and it has been done before (aout -> elf, c++ ABI)

    * + apt-get dist-upgrade for users is possible
    * - Requires insane amounts of work - every single library package needs to be renamed
    * - Requires a very long transition period, in which unstable will be broken for all archs.
          o c++ ABI transition takes about half an year, full transition could thus take around 2 years 
    * - Achieving Consensus for such transition on debian-devel would be very hard.
          o Non-ARM developers will object doing such amount of work only for a minor arch. If arm gets dropped from Release Arch's, we can't even file RC bugs for the migration. 
    * - Very invasive change, affecting every user and developer of Debian. 

2. New arch

    * + Technically, since we drop FPA instruction support, and gcc dumpmachine triplet is different, we can argue we have a new arch
    * + Does not affect non-ARM users
    * + we can target EABI for armv4(t?)+ while we can can keep oldabi port for ARMv3 (RiscPC) and maybe armv4 (StrongARM) users.
    * + Allows using new instructions (thumb) and drops the old FPU instruction set
    * + Can be done quickly, does not affect other arch's release cycle
    * + requires less archive space during migration
    * - Current ARM users don't have a easy upgrade path 

For the last point, a statically compiled [ArchTakeover] tool could be created. This would also allow i386->amd64 style migrations.

3. ABI: field in control file

This was suggested as part of Multiarch proposal. It is unknown if it would actually become part of Debian or not

    * + Reflects the packages ABI correctly, would help other transitions as well
    * - no working implementation
    * - no consensus on how to do it (apt developers want something more generic instead)
    * - might be hard to fit into current archive infrastructure
    * - make dependency resolving hard 

From these choices, we believe a new port is the best compromise.



API - ABI

EABI: Embedded Application Binary Interface

  In computer software, an application binary interface (ABI) describes the low-level
  interface between an application program and the operating system or another application.
  GNU EABI is a new application binary interface (ABI) for Linux.
  EABI规定：
  1)应用程序如何发出系统调用来trap到内核态.
  2)如何使用机器的寄存器,RISC处理器的ABI就要规定用那个通用寄存器来作stack pointer和frame pointer.
  3)规定如何进行procedure call.
  EABI is the new "Embedded" ABI by ARM ltd
  The effective changes for users are:
    * Floating point performance, with or without an FPU is very much faster, 
      and mixing soft and hardfloat code is possible
    * Structure packing is not as painful as it used to be (曾经是)
    * More compatibility with various tools (in future - currently linux-elf is well supported)
    * A more efficient syscall convention
    * At present (with gcc-4.1.1) it works with ARMv4t, ARMv5t processors and above, 
      but supporting ARMv4 (e.g., StrongARM) requires toolchain modifications.

对于浮点运行会预设硬浮点运算FPA(Float Point Architecture)，而没有FPA的CPU会用FPE
(Float Point Emulation 软浮点)，速度上就会遇到限制，使用EABI(Embedded Application
 Binary Interface)可以对此改善，ARM EABI有许多革新之处，其中最突出的改进就是Float 
Point Performance，它使用Vector Float Point(矢量浮点)，
因此可以提高涉及到浮点运算的程序


oabi eabi 都是针对arm的cpu来说的
eabi 有时候也叫做gnu eabi
eabi的好处： 1 支持软件浮点合硬件浮点 实现浮点功能的混用
	     2 系统调用的效率更高 ？？
             3 软件浮点的情况下，EABI的软件浮点的效率要比oabi高很多
eabi 和 oabi 的区别
	 1 调用规则 包括参数传递以及如何获得返回值
         2 应用程序如何去做系统调用
         3 结构体中的填充和对其 （ padding packing ）

