frameworks/base/cmds/bootanimation
mstar，bootanim在init.rc里改为system uid， 出现bootanimation就从8s延长到15s
改为graphics uid ok（new时不返回）

setprop ctl.start bootanim
setprop ctl.stop bootanim

service bootanim /system/bin/bootanimation  //这个服务没起
    disabled //没启动

bootanimation在init.rc配置为disable，
surfaceflinger的readyToRun函数内的startBootAnim();//开启动画属性，通过设置内存属性值来触发Init进程来启动：

void SurfaceFlinger::startBootAnim() {  
    // start boot animation  
    mBootFinished = false;  
    property_set("service.bootanim.exit", "0");//先清零，bootanimation进程周期检测
    property_set("ctl.start", "bootanim");//启动bootanim进程
}  

退出靠 service.bootanim.exit == 1 或线程执行完，自然退出
没有使用 ctl.stop bootanim

void SurfaceFlinger::bootFinished()  
{  
    property_set("service.bootanim.exit", "1"); //bootanimation检测
}

调用bootFinished 是靠
native/include/gui/ISurfaceComposer.h 中的注释
        // Note: BOOT_FINISHED must remain this value, it is called from
        // Java by ActivityManagerService.
        BOOT_FINISHED = IBinder::FIRST_CALL_TRANSACTION,


base/services/java/com/android/server/wm/WindowManagerService.java:
surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, // BOOT_FINISHED    靠这里触发

服务必须在 init.rc 中定义，init进程解析init.rc和启动属性服务，
属性ctl.start/ctl.stop用来启动和停止服务。
服务的启动结果放入“ init.svc.<服务名>“属性中
init.svc.<服务名> 的值可能是  stopped

RefBase子类对象第一次创建时，对象构造完成时会调用onFirstRef()   bootanimation在这里调run，为啥？构造里直接run不行吗

1280 720 1  // 1代表 帧/s
p 0 0 part0 // 分别指循环次数（0代表无限次）和阶段间隔时间

//mstar
usleep(part.pause * ns2us(frameDuration));
可见这个间隔时间是以帧为单位，如 10帧/s，这里写20就代表暂停2s

打包的时候一定不要压缩文件(压缩比为0)。

bootanimation 启动但是run() 很晚，构造函数执行 SurfaceComposerClient()有关

const String8 path(entryName.getPathDir());
const String8 leaf(entryName.getPathLeaf());

调用这个画面才会显示到屏幕
eglSwapBuffers(mDisplay, mSurface);


文件排序靠 SortedVector，可 1.jpg 2.jpg 3.jpg  或a.jpg b.jpg c.jpg

------------------------


带jni，本地.so库的apk，安装完在：/data/data/xx.xxx.xx/lib，这里删除不行

14 ./AndroidManifest.xml:    android:versionName="0.0.2" 会显示在setting 应用程序管理处
surfaceview
1 全屏 在manifast.xml中 android:theme="@android:style/Theme.NoTitleBar.Fullscreen" 
2 宽高 设置为匹配父窗口，而不是wrap_content
TextUtils.isEmpty(mVideoPath)    与直接判断字符串是否等于 NULL 有何区别

import android.hardware.Camera; //!!
import android.hardware.Camera.CameraInfo;
import android.hardware.Camera.Parameters;

setPreviewDisplay（null）就可以不预览了

反汇编：
http://blog.csdn.net/kesenhoo/article/details/6544094
dex2jar  jd-gui

rm-linux-androideabi-objdump -T  libLiveEncoder.so


Setting apk分析

多语言 res/values-zh-rCN/strings.xml  简体中文

2 Setting怎样在模拟器中调试呢？eclipes 是不能编译setting的
setting目录里面怎么没有jni呢？难道所有底层操作都是》
setting里面用了大量的 PreferenceActivity

framework/base/core/java/android/provider/Settings.java

设置保存在：
./data/com.android.providers.settings/databases/settings.db-journal

.db
.db-journal (什么文件)

https://www.sqlite.org/tempfiles.html
2.1 Rollback Journals

ETHERNET_IP




$dumpsys packet
service list  查看系统提供的服务
ndc : netd client
$ndc monitor
$ndc netd list
$ndc mdns mdnsd start service

system_server 由zygote启动

Android线程对应Linux线程

android按键码的解析
/frameworks/base/include/androidfw/KeycodeLabels.h 这里解析

android:versionCode="1"    比较版本
android:versionName="1.0"  显示  
android.intent.category.HOME //launcher

===
data目录是system权限 system 会挂载成 ro 形式。
android系统权限问题，还需要增强：

$ adb root
adbd cannot run as root in production builds

$ adb remount
remount failed: Permission denied

$ adb push 到/cache  /data 都没有权限

关于android shell的权限问题

用户名@机器名
shell@orange:/ $
但是有su程序，可以su
ps看，一个
/system/bin/sh  最前面显示root，另一个显示shell
我的盒子：
root@orange:/ #

adbd是shell，所以adb pull 对于不符合权限的，无法拷贝
shell     3435  1     3572   192   ffffffff 00017e64 S /sbin/adbd
===

==adb==
aapt :Android Asset Packaging Tool
frameworks/base/tools/aapt

aapt dump badging xx.apk


~/.android/adb_usb.ini (must!)
0x1234 //(vid)

vi /etc/udev/rules.d/51-android.rules(udev config):
SUBSYSTEM=="usb", ATTR{idVendor}=="17ef", ATTR{idProduct}=="7435", MODE="0666" OWNER="gaojie"
重新加载udev规则：
$ sudo udevadm control --reload
或重启udev：
$service udev restart


adb devices //List of devices attached
adb kill-server 
adb devices
adb root //root
adb remount //system wr
adb shell
adb tcpip 5555 #让adbd重新启动，并监听端口5555
adb connect 192.168.0.101:5555

adb logcat <=>  adb shell; logcat 其他命令同理
bugreport，打印更多调试信息
adb shell 进入的 sh 进程是 adbd的子进程。

pppoe得独立ip可远程adb


adb install 错误：
Failure [INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES] 之前安装了不同人编译的包名相同的apk
可以先删除了。 但是直接在/data/app下面删除，再安装，提示：
Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE] 因为apk删除不彻底。把/data/data/相应包名/ 目录 还有 ./dalvik-cache 目录还是不行
只能卸载或者恢复出厂设置


分离形式无法安装，如 ApiDemos.odex ApiDemos.apk
adb install -r ApiDemos.apk  提示 Failure [INSTALL_FAILED_DEXOPT] (-r 如已安装则覆盖否则提示：INSTALL_FAILED_ALREADY_EXISTS)
adb push ApiDemo.apk ApiDemo.odex 不能运行，打印: mismatch dep signature for

adb -s devicename //多设备连接时选择

dumpsys meminfo com.xx.test  //查看内存使用

2 adb connect ip:port ：
unable to connect to 192.168.0.113:7896:7896  端口号出现2次（1.0.31）

网络adb: service.adb.tcp.port=5555

1.手机：让adbd监听指定端口
setprop service.adb.tcp.port 5555
stop adbd #停止adbd
start adbd #启动adbd

2.手机：连接网络（3G或者WLAN）
假定你获得的IP地址为192.168.1.102
3.计算机：连接手机
adb connect 192.168.1.102:5555
4.计算机：检查是否成功
adb get-state
应当输出device或者emulator-5555，这取决于你的设置。

通过adb发出的命令是用户级的（实际在手机上的用户为shell），而切换监听方式所需的权限需要root才行。

4.2.1在Build Number上点7次显示adb开关

4.4 adb 1.0.31 connect成功，显示offline

nexus7 
1 unlock 方法
  fastboot工具可以在源码里面编译出来。先要安装ubuntu版本usb驱动:

out/host/linux-x86/bin/fastboot oem unlock   平板屏幕出现提示 Yes or No，选择Yes fastboot显示
...
(bootloader) erasing userdata...   //擦除了所有用户数据？
(bootloader) erasing userdata done
(bootloader) erasing cache...
(bootloader) erasing cache done
(bootloader) unlocking...
(bootloader) Bootloader is unlocked now.
OKAY [386.053s]
finished. total time: 386.053s

fastboot显示unlock状态，开机google logo下显示开锁图标

gaojie@gaojie:~/Work/Android/android-4.2.1_r1/out/host/linux-x86/bin$ ./fastboot  
flash recovery /home/gaojie/twrp-2.2.1-nexus7.img 
sending 'recovery' (6616 KB)...
OKAY [  0.785s]
writing 'recovery'...
OKAY [  1.665s]
finished. total time: 2.450s

* 在原生系统里重启后 TWRP或CWM 将被原生recovery替换。
在boot状态下可以 adb shell

fastboot oem unlock
fastboot flash recovery clockwork.img
fastboot reboot-bootloader
fastboot boot clockwork.img

chenyh:CIKAA手机，不能进recovery模式，就真的死活不能root，不能清除密码！
adb shell rm /data/system/gesture.key

模拟器上传/system/lib目录文件：
adb push 提示 out of memory 需要执行 
$emulator –avd youravdname –partition-size 256(实测4.0)

adb root 
adb remount

在已root的联想手机执行adb root:
adbd cannot run as root in production builds(root不彻底)
adb shell后$，su后#，exit先回到$，再exit退出shell

root原理：
若系统是eng版：
adb push su /system/bin  
adb push SuperSU.apk /system/app    
adb shell chmod 4755 /system/bin/su  使任意用户可调用（即set uid和set gid权限）
即完成，而实际user版不允许这样做，因system只读，chmod需要root（死循环）需要利用各种漏洞间接完成

用fastboot模式从sd卡烧一个eng版的**.img 
clockworkmod

过程：
进程调用su，su创建一个socket监听，向Superuser发送一个广播，说有程序请求root，su等待socket数据接收（有timeout） 
Superuser收到广播弹出对话框，根据用户选择回应socket，su根据socket结果处理是否可root执行（shell执行su弹出supersu提示）

superuser.apk 用于root后，管理root权限（白名单）防止被恶意程序滥用。

源码地址 http://superuser.googlecode.com/svn/trunk
这里的su是supersu提供的，而不是busybox的版本，因为后者不会发socket广播
su --help
SuperSU - Copyright (C) 2012-2013 - Chainfire (Chainfire的大神)

supersu若发现su文件不对，会把自带su写入system/bin/，写前supersu所需root权限可以用其他（如busybox/android）su获取（呵呵）
android版su： system/extras/su，获取supersu源码替换su.c和Android.mk文件编译即可

supersu如何知道有进程要调用su：
猜测：用busybox的su也行，只是任何程序都可以获取root权限了
adb install 安装在data/app 显示的不是文件名而是包名(如com.xxx.tv-1.apk  -1/-2 并非versionCode，何意？)

-----------
命令行启动apk
am start com.joysee.stb.tv/com.joysee.stb.tv.xxx (包名+activity名)
包名是aapt dump badging输出的 launchable-activity:字段

am bmgr bu ime input monkey pm svc 是shell脚本

INSTALL_PARSE_FAILED_NO_CERTIFICATES  //没有签名？？ 用platform.pk8 签名就好了
dumpsys package  可以打印很多信息

====

==property==

ro.build.version.incremental=1.0.19 版本

init用一个共享内存区存储属性

客户端以调用libcutils中的API函数以 GET/SET属性：
int property_get(const char *key, char *value, const char *default_value);
int property_set(const char *key, const char *value);

而libcutils又调用libc中的 __system_property_xxx 函数获得共享内存中的属性

属性服务调用libc中__system_property_init初始化共享内存，按顺序下列文件：
/default.prop
/system/build.prop
/system/default.prop
/data/local.prop
最后加载的属性保持在/data/property中（？）

System.getProperty()
System.setProperty()

默认属性加在 system/build.prop

ro.sf.lcd_density=200 //字体大小
persist.sys.strictmode.visual=off (严苛模式) //红色边框
persist.sys.strictmode.disable=1 (针对4.0)   //红色边框
ro.build.type=usr
ro.build.type=eng
ro.sf.lcd_density=250 //默认dpi 160
ro.build.characteristics=tablet
ro.build.characteristics=default
persist.service.adb.enable=1 //开启调试模式

ro.product.locale.language=zh //默认语言
ro.product.locale.region=CN
persist.sys.timezone=Asia/Shanghai //默认时区
ro.adb.secure = 1//adb offline，改为0即可 弹出提示框
net.dns1 = 202.106.0.20 //设置dns

system/core/init/property_service.c 里错误打印:
init: sys_prop: permission denied uid:1003  name:xx.xx.xx
权限问题

http://blog.csdn.net/jsonz/article/details/43765051  看这篇文章

PROPERTY_VALUE_MAX  android里定义为92

属性系统:
system/core/libcutils/ properties.c 
多个property_get 函数 情况不同 arm使用的是 HAVE_LIBC_SYSTEM_PROPERTIES


==========
un.h等 根据external/kernel-headers/original自动生成

socket 类型把AF_xx 都改成了PF_xx

bionic
更小更快的pthread；
	提供Android所需重要函数，如”getprop”, “LOGI”等；
	不完全支持POSIX标准，比如C++ exceptions，wide chars等；

bionic/libstdc++ -> libstdc++.so   //仅有几个文件

广播：
ACTION_BOOT_COMPLETED = "android.intent.action.BOOT_COMPLETED"
需要RECEIVE_BOOT_COMPLETED权限
sys.boot_completed  属性
frameworks/搜索BOOT_FINISHED  找到流程

3 测试 TestSurfaceview的时候 must voerride a superclass method 网上说 是java1.5不支持@Override 改为1.6即可 但是Apidemo 也有@Override 为什么就可以呢？
在Preference->Java->compiler 中改为1.6 果然编译通过并且也可以在2.2 AVD中运行

1 setting默认设置在framework里面修改，比如默认ip地址，画面尺寸等。
core/java/android/setdisplayattr/SetDisplayAttrService.java

3 dvb没在data区创建文件权限。data分区权限771，dev apk为user权限。将data
区改为777即可。但这样是否破坏android权限系统？ 可以查查平板电脑的权限如何。

4 多个home属性，开机出现选择界面
String HOME_CATEGORY 类别：主屏幕 (activity)，设备启动后显示的第一个 activity。 
"android.intent.category.HOME" 

new AlertDialog.Builder(this)  //new和.操作可以同时进行。

8 可通过修改xml和Android.mk最高获得system权限（要获得root权限需改init，变为服务有些麻烦）
  system权限仍然没有办法通过调用linux的系统调用设置时间。seting程序调用的是 systemClock.cpp 里面的setCurrentTimeMillis 里面操作了/dev/alarm设备节点

10 ApiDemo ./res/raw/test_cbr.mp3
11 <精通android3> Android java API 包含40多个包和700多个类，并且每一版的数量在不断增加。

12 android.media 包，此包核心是android.media.MediaPlayer类

13 android4.0/frameworks/base/core/java/android/os/Environment.java

udp socket创建失败，因为没有权限
在AndroidManifest.xml中，加上这一句话，取得权限。
<uses-permission android:name="android.permission.INTERNET" />

developer -  tools 下面有很多有用的工具。内存分析，cpu时间片使用等。

从Window -> preferences -> Java -> Editor -> Content assist -> Auto-Activation下，
我们可以在"."号后面加入我们需要自动提示的首字幕，比如"ahiz"。

xbmc里在 KeyPressTask extends TimerTask 里面调用的，而 TimerTask 本身也是个线程。
./libcore/luni/src/main/java/java/util/TimerTask.java

3 Preference 首选项
  Provides classes that manage application preferences and implement the preferences UI. 

4 ListActivity  extends  Activity 
   An activity that displays a list of items by binding to a data source such as an array or Cursor, 
and exposes event handlers when the user selects an item.

5  Fragment 就好比一个子 Activity。但是Activity 是Context的子类，而Fragment是由Object扩展而来。

android.graphics.drawable.shapes 这个包在
frameworks/base/graphics/java/android/graphics/drawable/shapes
这个目录中。

$ sudo mtpfs -o allow_other /media/nexus7
挂载好之后在文件浏览器应该可以看到一个新的挂载点，在里面可以任意管理里面的文件。
卸载的命令是：
$ umount /media/nexus7

init: skipping insecure file '/default.prop'
init: skipping insecure file '/init.rc'
需去除文件写权限
其实，root目录要放入到只读文件系统中。

7 一个库中添加1函数，调用此函数生成1可执行elf，然后库中此函数删除，编译拷贝，再执行elf打印：
mips_relocate_got(linker.cpp:1236): cannot locate "gaojie_test"...CANNOT LINK EXECUTABLE


每个event对象记录发生时间，在PhoneWindow.java中判断。
发生时间与当前时间之差达到一定长度就丢弃。但是电视/广播就必须在activity里面单独处理

public class KeyEvent implements Parcelable {
    /* Retrieve the time this event occurred, */
    public final long getEventTime() {
        return mEventTime;
    }
}

网络获取时间： NetworkTimeUpdateService

java标准类在/libcore，未使用jdk实现，就像bionic替代glibc。对标准库做了精简。
包括java.lang  java.net等。

public interface Runnable {
    public void run();
}

dalvik没有使用java字节码而是自己又定义了一套指令集
java指令集从0，1，2排到0xC9如： x4c astore_1

1 /dalvik/vm/Thread.c
2 dalvik/vm/mterp/ 各平台的汇编实现

java线程对应linux线程，从Thread.start 最终调用到 java_lang_VMThread.c 然后dvmCreateInterpThread

---
libcore
/libcore 生成：
core.jar(包含json解析)
core-libart.jar //art version core.jar
conscrypt.jar
libjavacore.so
libjavacrypto.so

JavaLibrary.mk:LOCAL_MODULE := core

---
system/etc/vold.fstab
dev_mount sdcard /mnt/sdcard auto /block/sda /block/sda/sda1
内部flash模拟sdcard，需要模拟触发vold。

暂时放这里：
ubuntu格式化u盘，不写卷标，就会分配一个UUID，挂载点：
/media/gaojie/xxxx-xxxx-xxxxxxxx (或显示卷标)

vold root权限运行，通过socket与其他的进程通讯

android的mount原理

int Volume::mountVol() 重要函数
外部可以动态挂载的都是 block 设备，
vold 支持磁盘多分区

only create android_secure on primary storage
注意，反复提到 primary storage

android上：
dev/device-mapper  10,58
./vold/cryptfs.c: if ((fd = open("/dev/device-mapper", O_RDWR)
./vold/Devmapper.cpp: if ((fd = open("/dev/device-mapper", O_RDWR)

/sys/devices/virtual  //PC kernel也有这个目录

sysfs和procfs

$man proc：
proc - process information pseudo-file system (interface to kernel data structures)
cmdline meminfo等放这里，有些牵强，但又能放哪呢？事情就是这样，任何艺术都是这个样子。

/mnt/secure/asec 这个目录是?

uevent

2 android_secure
这个文件夹里面的内容是app2sd产生的文件夹
---



frameworks/base/preloaded-classes 指定zygote预加载的类，所有apk子进程复制所有类。去掉它可提高开机速度，apk运行时再加载
模拟按键
KeyEvent mKeyEvent= new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_BACK);//new 按键
     onKeyDown(mKeyEvent.getKeyCode(),mKeyEvent);//派发给handler
删除了qemu里面的arm和x86的kernel结果：
No rule to make target `prebuilts/qemu-kernel/arm/LINUX_KERNEL_COPYING', needed by `out/target/product/generic_mips/obj/NOTICE_FILES/src/kernel.txt'
/generic_mips/obj/NOTICE_FILES/src/ 这个目录存放各个重要开发包的NOTICE，比如NOTICE_FILES/src/system/lib/libgif.a.txt
截屏
frameworks/base/cmds/ 
screencap > /cache/1.bin (fb内容)
screencap   /cache/1.png
可以抓视频层
screenshot                                                   
-s: play a sound effect to signal success
-i: autoincrement to avoid overwriting filename.png
screenshot -i x.png (x-1.png x-2.png x-3.png...)

M3执行screencap 得正确截图，用screenshot得到1920x1080图，只有1280x720部分有效其余空白。


I = Interface defines an object that will be accessible over binder
B = Base class implementation 
Bn = Base native (local object implementation)
Bp = Base proxy


keycode:
qwerty.kl:
# This file is no longer used as the platform's default keyboard layout.
# Refer to Generic.kl instead

android 换遥控器就是换.kl文件

输入系统由event驱动组成，包括libui库中的eventhub
eventhub 读取 *.kl文件，操作/dev/input/eventx

1 标准usb键盘的scan code

usb键盘驱动： driver/hid/ 
104键键盘按键码对照
A 65
B 66
C 67
D 68
Esc 27 / 0x1b

js用这个

ascii码和104键盘码表 有一部分是对应的

android java代码使用的是：
view/KeyEvent.java (跟.kl的联系？)中定义的如：
KEYCODE_DPAD_UP  19
KEYCODE_DPAD_DOWN  20  (真正在usb上的扫描码是多少？)
KeyEvent.KEYCODE_HOME

view/KeyEvent.java
interceptKeyBeforeDispatching
按键映射文件位置：
system/usr/keylayout/*.kl

映射关系 framework/base/data/keyboards/Generic.kl :
key 103   DPAD_UP
key 108   DPAD_DOWN
key 106   DPAD_RIGHT
而103 108 106可以通过 getevent 得到

按键处理的精髓是map：android看似好多层，其实就.kl文件一次映射，其他部分都是直连吧

usr/icu/icudt48l.dat 8M 何用？

struct input_dev

插入usb鼠标
getevent (system/core/toolbox/getevent.c  打开 /dev/input)                                     
add device 1: /dev/input/event6
  name:     "Logitech USB Keyboard"
add device 2: /dev/input/event5
  name:     "Logitech USB Keyboard"


linux/drivers/input/keyboard/atakbd.c : (一款游戏机)
定义：
 0x67: Up       103
 0x6c: Down     108
 0x69: Left     105
 0x6a: Right    106


在命令行里，F12等，显示~, 编辑状态显示 ^[[24~
^[[24~   F12

^[[21~   F10
^[[20~   F9
^[[19~   F8
^[[18~   F7
^[[17~   F6
^[[16~   F5

^[OS     F4
^[OR     F3
^[OQ     F2

--logcat--
logcat *:S MountService:V

./system/core/include/log/log.h 定义：
ALOGD
ALOGE

http://elinux.org/Android_Logging_System

logcat时候，串口和adb shell 输出同样的东西。串口不停的输出，也是要占用部分cpu资源的吧

logcat 系统，将fd 0，1，2 重定向到 /dev/null
logcat 设备节点：
/dev/log/
events
main
radio
system

-b 切换buffer，默认是main，可切换到events或radio

Viewing Alternative Log Buffers:

logcat中 好像也能打印 stdio

Viewing stdout and stderr:

$ adb shell stop
$ adb shell setprop log.redirect-stdio true
$ adb shell start

init 中 open_devnull_stdio 函数重映射

logcat -s tag1:v tag2:v
logwrapper 可以把第三方使用printf的bin打印转到logcat系统

1 Log系统 system/core/liblog
  此系统既生成 .a 也生成 .so。最终生成target使用的liblog.so包括logd_write.c、logprint.c、event_tag_map.c三文件，不含fake_log_device.c
  log打印格式在logprint.c中android_log_formatLogLine函数里 D/libEGL(xxx) 括号里面的代表 pid
----------

编译apk:
include $(BUILD_PACKAGE)

import_includes
export_includes
编译过程中生成，大小0，仅做标识作用
设置java环境变量时，最后 xx/bin/:$PATH 不行，bin后不能有/，否则编译java时出错

s805:
make modules  生成了一堆东西，好像有cts，WiFiDirectDemo什么的，研究下！(20160424 这个好像不同于kernel的make modules)
androd目录编译内核
make V=1 out/target/product/m200/obj/KERNEL_OBJ/arch/arm/boot/uImage
//因为uImage作成了android 大make系统的目标了

1 envsetup.sh
	1 envsetup.sh help
		croot:   到android根目录
		m:       Makes from the top of the tree.
		mm:      编译当前目录
		mmm:     编译指定目录
		cgrep:   grep C/C++文件
		jgrep:   grep java文件
		resgrep: grep res/*.xml 文件
		godir:   到包含某个文件的目录
	3 lunch  
		envsetup.sh : add_lunch_combo()

device目录下的各平台目录，直接影响lunch显示数量		

APK :Android Package
resources.arsc 编译后的二进制资源文件

android4.2.2 prebuilts/gcc 原始1.4G，可删除darwin(Apple),及linux mips/x86（intel灵动） arm-eabi-4.6(用于kernel，linaro替代，区别？)

---- 重要----
android 4.4 有4.6，4.7 两套编译器，外部定义 TARGET_GCC_VERSION_EXP=4.6可改变版本（一般不需要）
build/core/combo/TARGET_linux-arm.mk :

endif

TARGET_CC := gcc
TARGET_CXX := g++

envsetup.sh后尚找不到编译器，执行lunch等调用setpaths函数才生效(a4.0)：
function setpaths(){
	ANDROID_EABI_TOOLCHAIN="/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.6/bin"
	ANDROID_TOOLCHAIN=     "/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.6/bin"
	ARM_EABI_TOOLCHAIN=    "/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin" (for kernel)
	并最终设置到PATH变量中： export PATH=$ANDROID_BUILD_PATHS$PATH （这是以上变量总和）
	#a4.4后很多字段用变量代替如$targetgccversion，而非写死4.6/4.7
	#这里根据TARGET_linux-arm.mk提取编译器路径并export
}

android编译时用的是全路径而非直接用arm-linux-androideabi-，那么setpaths的路径设置没用，除非用于直接指定编译器编译自己的库
systemimage: ext4

生成system.img在build/core/Makefile中

# $(1): output file
define build-systemimage-target
  @echo "Target system fs image: $(1)"
  @mkdir -p $(dir $(1)) $(systemimage_intermediates) && rm -rf $(systemimage_intermediates)/system_image_info.txt
  $(call generate-userimage-prop-dictionary, $(systemimage_intermediates)/system_image_info.txt)
  $(hide) PATH=$(foreach p,$(INTERNAL_USERIMAGES_BINARY_PATHS),$(p):)$$PATH build_image.py \
      $(TARGET_OUT) $(systemimage_intermediates)/system_image_info.txt $(1)
endef

Yaffs2：
M3 external/yaffs2 生成HOST程序mkyaffs2image
mmm external/yaffs2
编译：
LOCAL_SRC_FILES := \
	yaffs2/utils/mkyaffs2image.c \
	yaffs2/yaffs_packedtags2.c \
	yaffs2/yaffs_ecc.c \
	yaffs2/yaffs_tagsvalidity.c
成mkyaffs2image安装到out/host/linux-x86/bin
但amlogic m3并没有用这个，而是
M3预置程序: device/amlogic/common/tools/mkyaffsimage4k.dat & mkyaffsimage2K.dat （可能与ecc，nand类型有关导致原版不能用）
BoardConfig.mk：
TARGET_AMLOGIC_MKYAFFSIMG_TOOL := mkyaffsimage4K.dat
解开yaffs2 image用unyaffs2(不在android源码里需另找)

ext4：
MX/A20  BoardConfig.mk:  TARGET_USERIMAGES_USE_EXT4 := true
用make_ext4fs生成img  

mkuserimg.sh -s system.img ext4 system 536870912 (大小512M)  (-s 代表sparse)

./system/extras/ext4_utils/mkuserimg.sh
./out/host/linux-x86/bin/mkuserimg.sh

ubuntu支持ext4：mount -o loop (用simg2img还原到512M再mount)

a20:
make_ext4fs -s -l 536870912 -a system system.img out/.../system
simg2img system.img unsparse_system.img //sparse 稀疏的，最后这个文件被自动删除了
e2fsck -f -n unsparse_system.img  //检查fs

ext4 的 system.img 2种格式：raw和sparse (开头有3a ff 26 ed)
raw 包含零填充区，可mount，较大
sparse 即simg 将raw进行稀疏描述，去除零填充区，变小

#file system.img (不关心扩展名，靠内部数据就能识别)
system.img: data //识别为普通文件
#file unsparse_system.img //识别为ext4分区
unsparse_system.img: Linux rev 1.0 ext4 filesystem data, UUID=57f8f4bc-abf4-655f-bf67-946fc0f9f25b (extents) (large files)

userdata.img 也是ext4  a20 128M（unsparse后），mount后有几个文件夹，部署时候应该是没有用到。

mount unsparse_system.img /mnt  //可挂载
e2fsck :check a Linux ext2/ext3/ext4 file system
simg2img: android-tools-fsutils deb包

dd if=unsparse_system.img of=/dev/sdb  //可挂载

file ramdisk.img：
ramdisk.img: gzip compressed data (cpio打包gzip压缩)
rename ramdisk.img to ramdisk.img.gz
gunzip ramdisk.img.gz
cpio -i -F ../ramdisk.img 看ramdisk内容

system/core/mkbootimg/

recovery.img

工具在out/host/linux-x86/bin/

boot.img :
A20: mkbootimg --kernel kernel --ramdisk ramdisk.img --base  0x40000000 --output boot.img
805: mkbootimg --kernel kernel --ramdisk ramdisk.img --second meson.dtb --output boot.img
(meson8b_m200_1G.dtb <=> meson.dtb / acp -fp arch/arm/boot/uImage m200/kernel)

ramdisk.img (cpio + gzip) :
mkbootfs root | minigzip > ramdisk.img

img开头"ANDROID!"

make out/target/product/sugar-ref001/boot.img  showcommands

make out/target/... /ramdisk.img

Target ram disk: out/.../ramdisk.img
Target boot image: out/.../boot.img
----- Making recovery image ------
Copying baseline ramdisk...
Modifying ramdisk contents... //增加些额外文件
Made recovery image: out/.../recovery.img

mkbootfs 由 system/core/cpio/mkbootfs.c 编译，实现cpio打包
它需要引入android_filesystem_config.h(Permission.txt有说明)

mkbootfs out/.../root | minigzip > out/.../ramdisk.img

疑问：
ramdisk.img 与 kernel支持的内存文件系统有什么关系

==================================================
20160421:
s805的uboot单独处理了 "ANDROID!" 而mstar直接用uboot的image格式生成boot.img
==================================================

一、Android的编译系统
1 静态链接库 ./core/combo/TARGET_linux-arm.mk 中的

这个不是用于生成静态库的 而是用来生成.so 或者exe时候静态链接用的

静态链接为可执行文件（无需/system/bin/linker）

5 变量含义
	LOCAL_SRC_FILES := bar.c.arm #bar.c以arm模式编译
	LOCAL_ARM_MODE = arm  #arm模式
	LOCAL_DEX_PREOPT := false #生成完整apk，默认true，分出.odex（Optimized DEX）加速运行

repo:

1 切分支：
repo init -b 4.1.2 
repo sync (-l ??) //git<1.7.2 gc error
或：
repo forall -c git checkou xxtag

repo init -u -b (可SHA)下载repo.git 和 manifest.git
repo sync 不会自动合并本地和远程master分支，分支被切换到 a20/master 即远程master分支，即sync 不merge 本地各仓库的修改也不能自动提交。
repo forall -c command
repo help 
repo help init
repo manifest -o xx.xml -r  生成xx.xml -r 生成提交号  否则copy原manifest

--repo-url=指定repo仓库地址，代替修改repo文件REPO_URL=变量。-m default.xml链接到哪个xml

manifest 维护 default.xml
default.xml <remote  name="vc" //仓库remote名

不同项目个别仓库不同，可以通过manifest仓库，只把特定仓库建立项目分支。不必所有仓库建分支。实验证明：

lib32readline5-dev
 The GNU readline library aids in the consistency of user interface across discrete programs that need to provide a command line interface.
The GNU history library provides a consistent user interface for recalling lines of previously typed input. 

开机logo:RLE(run-length encoding游程编码)
convert命令将11.jpg转化为11.raw： convert -depth 8 11.jpg rgb:11.raw
将11.raw文件转换为initlogo.rle。在raw图片文件所在目录下执行：/out/host/linux-x86/bin/rgb2565 -rle <11.raw> initlogo.rle

意思是把 initlogo-robot-1280x720.rle 拷贝到 root/initlogo.720p.rle 中
phostshop 可以打开，但是gimp打不开。 ubuntu上可以用 golly程序打开（软件中心下载），不行，打不开。

LOCAL_MODULE_TAGS := optional  控制是否编译
LOCAL_PROGUARD_ENABLED := disabled

make: *** No rule to make target `out/target/common/obj/JAVA_LIBRARIES/com.android.phone.common_intermediates/javalib.jar',
 needed by `out/target/common/obj/APPS/Contacts_intermediates/classes-full-debug.jar'. Stop.

3 Android性能测试软件 nbench、benchmark、smartphone bench

如果想拿某个branch而不是主线上的代码，我们需要用-b参数制定branch名字，比如：
repo init -u git://android.git.kernel.org/platform/manifest.git -b cupcake

另一种情况是，我们只需要某一个project的代码，比如kernel/common，就不需要repo了，直接用Git即可。
git clone git://android.git.kernel.org/kernel/common.git

android提供了预制程序升级机制。可以在system/app 和 data/app 2个地方同时存在2分apk，运行后者，删除程序，提示apk会 恢复到初始版本。
/data/data/com.android.providers.settings/database 存储的是电商ip地址信息。电商存储信息用的是 setting的provider

编译android的时候  LOCAL_ARM_MODE 是没有定义的 所以
arm_objects_mode = arm
normal_objects_mode = thumb

cat cpu  时候 显示htc手机 Hardware: bravo
我的平台 hardware : NXP BL-STB platform
./arch/arm/mach-apollo/apollo.c:MACHINE_START(APOLLO, "NXP BL-STB platform")

make 开始打印在build/core/envsetup.mk 中$(info )

为什么prebuild/android-arm/kernel/kernel-qemu kernel-qemu-armv7这几个文件呢？  从文件名字来看 应该是qemu可以模拟armv7
编译好的文件在：/out/host/linux-x86/pr/sim/obj/SHARED_LIBRARIES/xxx

Android kernel/common 项目的Goldfish分支（该分支用于构建运行在emulator上的系统内核，而主线则是用于构建运行在实际设备上的内核代码）

1 LOCAL_ARM_MODE  从android源码看 这个是加到每个Android.mk文件中的 那么怎么变成全局的呢？
LOCAL_ARM_MODE := arm
注意你同样可以在编译的时候告诉系统编译特定的类型，比如
LOCAL_SRC_FILES := foo.c bar.c.arm
./core/binary.mk:LOCAL_ARM_MODE := $(strip $(LOCAL_ARM_MODE))
./core/binary.mk:arm_objects_mode := $(if $(LOCAL_ARM_MODE),$(LOCAL_ARM_MODE),arm)
./core/binary.mk:normal_objects_mode := $(if $(LOCAL_ARM_MODE),$(LOCAL_ARM_MODE),thumb)
./core/clear_vars.mk:LOCAL_ARM_MODE:=

external/zlib/Android.mk:
# measurements show that the ARM version of ZLib is about x1.17 faster than thumb
LOCAL_ARM_MODE := arm

我在./core/clear_vars.mk:LOCAL_ARM_MODE:= arm
结果整个项目都是 target arm c/c++ 了
我就在这个目录中的Android.mk中加上  LOCAL_ARM_MODE:= 空
那么这个目录就用thumb编译了 target thumb c

Windows->Preferences->Android 选择SDK位置 下面可以看到 Android2.1 Android2.2版本 API level 分别为7，8 
Windows->Android SDK and AVD Manager 可以看到android 虚拟设备 
eclipse 可以使用自己喜欢的版本 建议3.4 以上

./adb install ApiDemos.apk 可以安装一个apk
虚拟机目录 ~/.android/avd 

To start the SDK Manager, please execute the program "tools/android".  （无法直接执行）

3. 将下载的压缩包放入temp文件夹下
例如：D:\ProgramFiles\android-sdk-windows\temp
 
4. 点击SDK Manaer.exe，让其自动解压缩。  (linux版本怎么办？ 实践证明，解压缩拷贝到android-sdk目录下即可)
5.配置环境变量 PATH = D:\ProgramFiles\android-sdk-windows\tools 
    SDK安装完成
在sdk r13 中 执行 ./android (一个脚本) 会打开Android SDK and AVD Manager 但是 跟从eclipse 中打开的不一样

6 /development/samples 这个目录就是eclipse中可以单独下载的sample.tgz包

5 vendor/amlogic/prebuilt/  DLNA.apk 是 “媒体中心” 这个跟eHomeMediaCentor界面相同,但里面只有dex文件无jar包库。
RC_Client.apk  RC_Server.apk 实现手机遥控器
MiracastSink.apk 实现miracast功能

packages/amlogic/下面有些可用apk资源。
6 kernel中的 common/drivers/amlogic/display 是fb驱动

源码里面有pppoe的代码。
输入法有源码，做一下修改。
latinime.apk是手机自带的文字输入法,如果你安装有其他输入法,可以删除

在system/app下的apk包里不能包含.so,需要把so拷贝出来放到 /system/lib 目录下

整理好的 git仓库编译
build/core/java.mk:37: *** cts/apps/CtsVerifier: Invalid LOCAL_SDK_VERSION 'current' Choices are: . Stop.
原因是 prebuilt目录没有建立

telephony-common
mms-common 
这些模块应该不要编译

ffmpeg目录packages/amlogic/LibPlayer/amffmpeg/

python文件ota_from_target_files :
制作升级包或增量包(-i)

m3编译错误: File"ota_from_target_files" :local variable 'boot_img' referenced before assignment (版本问题?)

out/target/product/f16ref/obj/PACKAGING/target_files_intermediates/
这个目录内容会持续增加，每次编译都会留下记录

ota_from_target_files -v --amlogic -n -p out/host/linux-x86 -k build/target/product/security/testkey xx.zip xxx.zip


./docs/source.android.com/src/source/initializing.md:      zip curl zlib1g-dev libc6-dev lib32ncurses5-dev

mmm -B system/core/adb/ 编译出2个东西：
/root/sbin/adbd 运行在盒子上
system/bin/adb  # adb host tool for device-as-host (设备作为主机，有意思)
out/host/linux-x86/bin/adb 运行在主机

adb uninstall com.joysee.stb.tv 成功删除

HOST_OS_EXTRA=Linux-3.13.0-35-generic-x86_64-with-Ubuntu-14.04-trusty 这个是怎么读出来的？

加载动态库使用/system/bin/linker而不是常用的/lib/ld.so;
prelink工具不是常用的prelink而是apriori，源码/build/tools/apriori”
strip不是/prebuilt/linux-x86/toolchain /arm-eabi-4.2.1/bin/arm-eabi-strip，而是/out/host /linux-x86/bin/soslim

frameworks/base/core/java/android/os/display/DisplayManager.java:58: warning: unmappable character for encoding UTF8
原来是gb2312有汉字，另存为UTF8即可
能否有1个命令或一个脚本把所有非utf8编码文件修正。并修改windows为linux编码
编译 framework/base/ethernet

out/target/common/obj/JAVA_LIBRARIES/framework_intermediates
framework目录编译的中间目录。把这里的 class.jar 解压缩可以查到
EthernetManager.class

修改了framework目录下的某个文件的编译过程(技巧：故意将java源码改错助于露出端倪)：
以下路径前缀默认： out/target/common/obj/JAVA_LIBRARIES

java-source-list这个文件是如何生成的？
framework_intermediates/classes 这个目录的内容会变化，我修改了framework下的某个文件，然后编译make systemimage
然后盯着framework_intermediates这个目录，classes一出现就立即复制，捕捉到了java-source-list这个文件
这个文件包含了framework目录下2100多个java文件，怎么生成的？
仅仅解压class.jar 并没有这个文件，后面的部分是靠：
find ./framework_intermediates/src -name '*.java' >> ./framework_intermediates/classes/java-source-list; 
追加的，那么前面的呢？
在./core/definitions.mk 这里处理
找到根源了：# Common definition to invoke javac on the host and target.
看定义：

靠dump-words-to-file 生成 java-source-list

显示配备了这些device 最后的sdk/bash 是什么？

prebuilt 和 prebuilts 两个目录都需要，删除prebuilt 系统编译不过去
在这2个目录中删除了一些不用的编译器，比如过时的arm版本，x86编译器等。

c++的server都是由init启动
关于权限问题，xml可以制定 shared uid

system权限 1000 有权访问 apk目录吗？

nxp:
1 发布: source env.sh newbox retail license_free
2 调试(带打印): source env.sh newbox retail license_free_trace
3 编译SDK之外app，如测试程序
    source env.sh newbox retail license_free ;export _TMTGTCOPYAPP=1
4 编译SDK之外库，如dd，dm
    source env.sh newbox retail license_free ;export _TMTGTCOPYLIB=1
[export _TMECHO=1 显示编译详情]

2 编译
  a. sdk全部编译： 执行 make （sdk根目录）
  b. 只编译sdk用户空间部分： 执行 make change_toolchain 或者执行 make app （sdk根目录）
  c. 编译自己的库或者测试程序： 进入自己的makefile所在目录，执行 make

ndk : prebuiltLib/libutils.so: undefined reference to `__aeabi_f2ulz'  这个函数在libgcc.a中
什么样的c描述会调用这个函数？ 貌似是浮点运算,换成ndk-r4 就没这个打印

1 build/core/combo/select.mk 定义 
  $(combo_target)SHLIB_SUFFIX := .so  
  $(combo_target)STATIC_LIB_SUFFIX := .a

2 现在我要设置 TARGET_ARCH_VARIANT = armv7-a 需要修改哪里，直接TARGET_linux-arm.mk当然是最直接的
  make TARGET_ARCH_VARIANT=armv7-a 也行。
  找到了 ./htc/passion-common/BoardConfigCommon.mk:TARGET_ARCH_VARIANT := armv7-a-neon

一个HOST静态库的预编译，十分简单：
include $(CLEAR_VARS) 
LOCAL_PREBUILT_LIBS := ../prebuilt/libunz.a 
include $(BUILD_HOST_PREBUILT) 
这里还不能用 $(LOCAL_PATH) 用了会出现 external/webkit/external/webkit/../prebuilt 奇怪。

prebuilt.mk和multi_prebuilt.mk，对应的方法宏是BUILD_PREBUILT和 BUILD_MULTI_PREBUILT。

android中 .so里面是不包含 /system/bin/linker字符串

android 编译可执行文件
include $(CLEAR_VARS) 
/*CLEAR_VARS:= $(BUILD_SYSTEM)/clear_vars.mk 把各种变量赋为空*/

LOCAL_FORCE_STATIC_EXECUTABLE := true /*init工程加了这个*/

include $(BUILD_EXECUTABLE)
/* BUILD_EXECUTABLE:= $(BUILD_SYSTEM)/executable.mk 此文件判断 LOCAL_FORCE_STATIC_EXECUTABLE 决定静态链接还是动态链接（那么能否既静态又动态呢？）*/
/* 用-l 加库跟 变成.o 加在文件列表中是不同的，-l只链接用到的函数，那么.o呢？ */

LOCAL_MODULE_CLASS := ETC  //安装到system/etc目录
LOCAL_MODULE := init.godbox.sh
LOCAL_SRC_FILES := $(LOCAL_MODULE)
include $(BUILD_PREBUILT)

LOCAL_SRC_FILES:= 源文件
LOCAL_MODULE:= 生成的文件

3.6 libwebcore.so
3.6.1 问题
arm-linux-androideabi/bin/ld: libwebcore.a(CSSParser.o): 
CSSParser.cpp:5925: error: undefined reference to 'WebCore::CSSParser::lex()'
3.6.2 原因
一种可能是后续的编译过程需external/webkit/Source/WebCore/css/tokenizer.flex。但生成此文件失败
touch external/webkit/Source/WebCore/css/tokenizer.flex，再次make -j4。
编译过程看到了：
target Generated: libwebcore <= external/webkit/Source/WebCore/css/tokenizer.flex
因prebuilt/linux-x86/flex/flex-2.5.4a无执行权限，没有正确生成(ntfs惹的祸)

这时mmm -B webkit 因为虽然改了权限，已经编译好的 cssparser.o 已经错误，系统不会重新编译这个.o

某次编译bootable/recovery  BLKWIPEPART未定义，因为在bionic里把kernel头文件搞乱了（实验）
运行bionic/libc/kernel/tools/update_all.py即可 (运行也不行，external/kernel-headers就没有)

edify脚本 用于升级

prebuilts/gcc/linux-x86/host/
i686-linux-glibc2.7-4.4.3 (老版本不用了)
i686-linux-glibc2.7-4.6 (编译32bit版工具  -m32)
x86_64-linux-glibc2.7-4.6 （编译64bit版工具 -m64）
三套带glibc的gcc编译器，s805没有用系统编译器


找不到 : export_includes
undefined reference to 'android::ITvosAudioSettingService::asInterface   //服务没有实现接口
互相依赖　export_include 找不到


out/target/product/xx/obj/lib/crtbegin_dynamic.o, needed by 
out/target/product/xx/obj/EXECUTABLES/screencap_intermediates/LINKED/screencap

注意理解依赖，找不到types.h找不到问题，表面是安装了g++-multilib解决，实际是依赖安装了gcc-multilib
multilib 用于生成多平台的代码  32bit/64bit

---
电脑能装ia32-libs因为是12.04，不装adb(32bit的)运行不了
14.04没有此包，提示替代包:
lib32z1 lib32ncurses5 lib32bz2-1.0 (这是zlib库，与32bit程序无关)

找不到libstdc++.so因未安装g++-multilib

1 编译android环境：
	u14.04编4.2.x：bison flex libxml2-utils xsltproc g++-multilib gperf(makeprop.pl) libswitch-perl(Switch.pm >u14.04)
	bison flex类似yacc的语法解释器，用于aidl；
	build-essential  是gcc g++ 以及相应库。
	lib32z1-dev  32位版zlib开发库，32位版主机工具(gcc -m32)
	ia32-libs(u14.04无此包，安装gcc-multilib/g++-multilib即可)
	lib32ncurses-dev (32位new curses) 编译 ./system/core/adb时使用此库32位版(gcc -m32，1.0.31版(android4.2.2)adb不需)
	libncurses-dev (u10.04可能自带，u14.04被摒弃) 编译kernel menuconfig使用
	gawk 4.0.x (好像不需要)

2 jdk
	open:openjdk-6-jdk/openjdk-7-jdk(依赖openjdk-6-jre-headless)
    /usr/lib/jvm/java-6-openjdk-amd64

	sun: oracal官网注册下载如
    jdk-6u35-linux-x64.bin(jdk1.6第35个版本)，执行并拷贝到/usr/lib/jvm(与openjdk并列)
    PATH=$PATH:/usr/lib/jdk1.6.0_35/bin 或：
	update-alternatives --install "/usr/bin/java" "java" "/usr/lib/jvm/jdk1.6.0_35/jre/bin/java" 1
	update-alternatives --install "/usr/bin/javac" "java" "/usr/lib/jvm/jdk1.6.0_35/bin/javac" 1
	java/javac 切换到sun，其他仍用open可编ics

4 android 4.4.2 编译主机工具用prebuilts/gcc/linux-x86/host自带gcc，而4.0.4用系统gcc
用prebuilts/tools/gcc-sdk/gcc  脚本引导到源码自带编译器

4.0.4 

PRIVATE_CC := $(LOCAL_CC)
HOST_CC 在 select.mk:
$(combo_target)CC := $(CC) 这里设置

# Previously the prebiult host toolchain is used only for the sdk build,
# that's why we have "sdk" in the path name.
ifeq ($(strip $(HOST_TOOLCHAIN_PREFIX)),)
HOST_TOOLCHAIN_PREFIX := prebuilts/tools/gcc-sdk  //这里赋值也不同
endif
# Don't do anything if the toolchain is not there
ifneq (,$(strip $(wildcard $(HOST_TOOLCHAIN_PREFIX)/gcc)))
HOST_CC  := $(HOST_TOOLCHAIN_PREFIX)/gcc
HOST_CXX := $(HOST_TOOLCHAIN_PREFIX)/g++
endif

endif

4.2中找到原因：
HOST_linux-x86.mk :
对于Linux SDK: We need to use a special toolchain for Ubuntu 8.04 (Hardy) due to GLibc ABI 
mistmatches(Lucid is 2.11, Hardy is 2.7)，Lucid 编译的代码不能在previous versions 运行

4.4:
# Previously the prebiult host toolchain is used only for the sdk build
# that's why we have "sdk" in the path name. (指的是prebuilts/tools/gcc-sdk)
//所有情况都使用prebiult编译器了（对于我的应用没有必要）
prebuilts/gcc/linux-x86/host/  目录删除
这样也有弊端^_^ 
原来用prebuild编译器，相应库都在自己目录准备好了，如libz，现在用系统的编译s805 4.4.2 提示找不到 -lz，需要32bit开发版，倒是好解决^^
或者改成 -m64 更好，在 BoardConfig.mk 中增加：BUILD_HOST_64bit := 1

BUILD_HOST_64bit := 1 不行，无论系统cc还是prebuild gcc，在生成package-export.apk时一堆错误
猜测：64bit的 aapt 资源打包工具有问题:

说明系统gcc 是64bit程序，可加-m32/-m64参数，那prebuild分2个版本，分别是32bit/64bit程序（？兼容32bit ubuntu系统？）


删除x86_64-linux-glibc2.7-4.6还不行，因为工具一般-m32，个别的还是-m64
情况1：
提示找不到 x86_64-linux-glibc2.7-4.6/bin/x86_64-linux-ar
gcc-sdk/gcc 脚本：
# Choose 64-bit if -m64 only, -m64 appears after -m32, or neither exist (-eq)
-m32 -m64 都没有，默认-m64 


