Bjarne Stroustrup博士《The C++ Programming Language》

1. 请谈谈C++书
　没有一本书对于所有人来说都是最好的。不过对于那些真正的程序员来说，如果他喜欢从“经典风格”的书中间学习一些新的概念和技术，我推荐我的The C++ Programming Language。那本书讲的是纯而又纯的C++，完全独立于平台和库（除标准库）。所以这本书的重点在于概念和技术，而且在完整性和精确性上下了不少功夫。理解设计的原则和限制能帮助你写出更好的程序。

2. 学习C++要花多长时间
　  如果你是个C程序员，一天之内就能学会C++进行更出色的C风格编程。如果想完全掌握C++主要机制，例如数据抽象，面向对象编程，面向对象设计等，而此前又对这些东西不熟的话，花一两年不足为奇。如果学习一种新的语言不能使我们的工作和思想方式发生深刻变革，又何苦来哉？跟成为一个钢琴家或者熟练掌握一门外语相比，学习一种新的、不同的语言和编程风格还算是简单的。

3. 了解C是学习C++的先决条件吗？
　  NO! C++中与C相近的子集其实比C语言本身要好学，类型方面的错误会少一些，也不像C那样绕圈子，还有更好的支持库。所以应该从这个子集开始学习C++。

5. 我如何开始学习C++？
　  这取决于你的基础和学习动机。如果你是个初学者，我想你最好找个有经验的程序员来帮助你，要不然你在学习和实践中不可避免的犯下的种种错误会大大地打击你的积极性。另外，即使你的编译器配备了充足的文档资料，一本C++书籍也永远是必不可少的，毕竟文档资料不是学习编程思想的好教材。选择书籍时，该书要讲授标准C++，并且矢志不渝地使用标准库机制。例如，从输入中读取一个字符串应该这样：
	　　string s; // Standard C++ style
	　　cin >> s;
	　而不是这样：
	　　char s[MAX]; /* Standard C style */
	　　scanf("%s",s);

6. 怎样改进我的C++程序？
　　这取决于你是怎么使用该语言的。大多数人低估了抽象类和模板的价值，却肆无忌惮地使用造型机制(cast)和宏。
　　抽象类和和模板的作用当然是提供一种方便的手段建构单根的类层次或者重用函数，但更重要的是，它们作为接口提供了简洁的、逻辑性的服务表示机制。

7. 语言的选择是不是很重要？
　　是，但也别指望奇迹。很多人似乎相信某一种语言能够解决他们在系统开发中遇到的几乎所有问题，他们不断地去寻找完美的编程语言，然后一次次的失败，一次次的沮丧。另外一些人则将编程语言贬为无关紧要的细节，把大把银子放在开发流程和设计方法上，永远都在用着COBOL, C和一些专有语言。一种优秀的语言，例如C++，能帮助设计者和程序员做很多事情，而其能力和缺陷又能够被清楚地了解和对待。

8. ANSI/ISO标准委员会是不是糟蹋了C++？
　　当然不是！他们的工作很出色。你可以在一些细节上找些歪理来挑刺，但我个人对于这种语言以及新的标准库可是欣欣然。ISO C++较之C++的以前版本更出色更有条理。相对于标准化过程刚刚开始之初，你今天可以写出更优雅、更易于维护的C++程序。新的标准库也是一份真正的大礼。由于标准库提供了strings, lists, vectors, maps以及作用于其上的基本算法，使用C++的方式已经发生了巨大的变化。

9. 你现在有没有想删除一些C++特性？
　　没有，问这些问题的人大概是希望我回答下面特性中的一个：多继承、异常、模板和RTTI。但是没有它们，C++就是不完整的。在过去的N年中，我已经反复考虑过它们的设计，并且与标准委员会一起改进了其细节，但是没有一个能被去掉又不引起大地震。从语言设计角度讲，我最不喜欢的部分是与C兼容的那个子集，但又不能把它去掉，因为那样对于在现实世界里工作的程序员们来说伤害太大。与C兼容是一项关键的设计决策，绝不是噱头。兼容性的实现和维护十分困难，但确实使程序员们至今受益良多。但现在，C++已经有了新特性，程序员们可以从麻烦多多的C风格中解脱出来。例如，使用标准库里的容器类，象vector, list, map, string等等，可以避免与底层的指针操作技巧混战不休。

10. 如果不必和C兼容，你所创造的语言是不是就会是Java?
　　不是，差得远。如果人们非要拿C++和Java来作比较，我建议他们去阅读The Design and Evolution of C++，看看C++为什么是今天这个样子，用我在设计C++时遵从的原则来检验这两种语言。这些原则与SUN的Java开发小组所持的理念显然是不同的。除了表面语法的相似性之外，C++与Java是截然不同的语言。在很多方面，Java更像Smalltalk（译者按：我学习Java时用的是Sun的培训教材，里面清楚地写道：Java在设计上采用了与C++相似的语法，与Smalltalk相似的语义。所以可以说Java与C++是貌合神离，与Smalltalk才是心有灵犀）。Java语言相对简单，这部分是一种错觉，部分是因为这种语言还不完整。随着时间的推移，Java在体积和复杂程度上都会大大增长。在体积上它会增长两到三倍，而且会出现一些实现相关的扩展或者库。这是一条每个成功的商业语言都必须走过的发展之路。随便分析一种你认为在很大范围内取得了成功的语言，我知道肯定是无有例外者，而且实际上这非常有道理。

　　上边这段话是在Java 1.1推出之前写的。我确信Java需要类似模板的机制，并且需要增强对于固有类型的支持。简单地说，就是为了基本的完整性也应该做这些工作。另外还需要做很多小的改动，大部分是扩展。1998年秋，我从James Gosling（Java语言创始人）那里得到一份建议书，说是要在Java中增加固有类型、操作符重载以及数学计算支持。还有一篇论文，是数学分析领域的世界级大师，伯克利大学的W. Kahan教授所写的How Java’s Floating-Point Hurts Everyone Everywhere（“且看Java的浮点运算如何危害了普天下的芸芸众生”），揭露了Java的一些秘密。

　　我发现关于Java的鼓吹是不准确的，气势汹汹，让人讨厌。大肆叫嚣凡是非Java的代码都是垃圾，这是对程序员的侮辱；建议把所有的保留代码都用Java重写，这是丧心病狂，既不现实也不负责任。Sun和他的追随者似乎觉得为了对付微软罪恶的“帝国时代”，就必须如此自吹自擂。但是侮辱和欺诈只会把那些喜欢使用不同编程语言的程序员逼到微软阵营里去。

　　  Java并非平台无关，它本身就是平台。跟Windows一样，它也是一个专有的商业平台。也就是说，你可以为Windows/Intel编写代码，也可以为Java/JVM编写代码，在任何一种情况下，你都是在为一个属于某个公司的平台写代码，这些代码都是与该公司的商业利益扯在一起的。当然你可以使用任何一种语言，结合操作系统的机制来编写可供JVM执行的程序，但是JVM之类的东西是强烈地偏向于Java语言的。它一点也不像是通用的、公平的、语言中立的VM/OS。

　　私下里，我会坚持使用可移植的C++作大部分工作，用不同的语言作余下的工作。
　　（”Java is not platform-independent, it is the platform”，B.S的这句评语对于C++用户有着很大的影响，译者在国外的几个新闻组里看到，有些C++高手甚至把这句话作为自己的签名档，以表明对Java的态度和誓死捍卫C++的决心。实际上有很多程序员不光是把自己喜爱的语言当成一种工具，更当成一种信仰）

11. 您怎么看待C#语言？
　　就C#语言本身我没什么好说的。想让我相信这个世界还需要另外一个专有的语言可不是一件容易的事，而且这个语言还是专门针对某一个专有操作系统的，这就更让我难以接受。直截了当地说，我不是一个专有语言的痴迷者，而是一个开放的正式标准的拥护者。

12. 在做大项目时，您是不是真的推荐Ada，而不是C++？
　　当然不是。我不知道这是谁传出来的谣言，肯定是一个Ada信徒，要么是过分狂热，要么是不怀好意。

13. 你愿不愿意将C++与别的语言比较？
　　抱歉，我不愿意。你可以在The Design and Evolution of C++的介绍性文字里找到原因。
　　有不少书评家邀请我把C++与其它的语言相比，我已经决定不做此类事情。在此我想重申一个我很久以来一直强调的观点：语言之间的比较没什么意义，更不公平。主流语言之间的合理比较要耗费很大的精力，多数人不会愿意付出这么大的代价。另外还需要在广泛的应用领域有充分经验，保持一种不偏不倚、客观独立的立场，有着公正无私的信念。我没时间，而且作为C++的创造者，在公正无私这一点上我永远不会获得完全的信任。

　　人们试图把各种语言拿来比较长短，有些现象我已经一次又一次地注意到，坦率地说我感到担忧。作者们尽力表现的公正无私，但是最终都是无可救药地偏向于某一种特定的应用程序，某一种特定的编程风格，或者某一种特定的程序员文化。更糟的是，当某一种语言明显地比另一种语言更出名时，一些不易察觉的偷梁换柱就开始了：比较有名的语言中的缺陷被有意淡化，而且被拐弯抹角地加以掩饰；而同样的缺陷在不那么出名的语言里就被描述为致命硬伤。类似的，有关比较出名的语言的技术资料经常更新，而不太出名的语言的技术资料往往是几年以前的，试问这种比较有何公正性和意义可言？所以我对于C++之外的语言的评论严格限制在一般性的特别特定的范畴里。换言之，我认为C++是大多数人开发大部分应用程序时的最佳选择。

14. 别人可是经常拿他们的语言与C++比来比去，这让你感到不自在了吗？
　　当这些比较不完整或出于商业目时，我确实感觉不爽。那些散布最广的比较性评论大多是由某种语言，比方说Z语言的拥护者发表的，其目的是为了证明Z比其它的语言好。由于C++被广泛地使用，所以C++通常成了黑名单上的头一个名字。通常，这类文章被夹在Z语言的供货商提供的产品之中，成了其市场竞争的一个手段。令人震惊的是，相当多的此类评论引用那些在开发Z语言的公司中工作的雇员的文章，而这些经不起考验文章无非是想证明Z是最好的。特别是在这些比较中确实有一些零零散散的事实，（所以更具欺骗性——译者），毕竟没有一种语言在任何情况下都是最好的。C++当然不完美，不过请注意，特意选择出来的事实虽然好像正确，但有时是完全的误导。以后再看到语言比较方面的文章时，请留心是谁写的，他的表述是不是以事实为依据，以公正为准绳，特别是评判的标准是不是对于所引述的每一种语言来说都公平合理。这可不容易做到。
　　
15. 在做小项目时，C优于C++吗？
　　非也。除了由于缺乏好的C++编译器而导致的问题之外，我从没有看到哪个项目用C会比用C++更合适。
　　（不过现在C++编译器导致的问题还是不可忽略的，当你看到同样功能的C++程序可执行代码体积比C大一倍而且速度慢得多时，会对此有所感触的。——译者）

16. 如果您现在有机会从头设计C++语言，您会做些什么不同的事情？
　　永远不可能重新设计一种语言，没有意义，任何一种语言都是它那个时代的产物。如果让我今天再设计一种语言，我仍然会综合考虑逻辑的优美、效率、通用性、实现的复杂程度和人们的喜好。我会寻找一种简单得多的语法，把类型系统的冲突问题限制在很少的几种情况里，而且你能很容易的发现这些问题。这样就能够很容易的禁止不安全的操作。
　　（B.S的原则是：对于糟糕的代码，就算是不能完全禁止，至少也要让它大白于天下，而不是藏在阴暗的角落里暗箭伤人。C++实际上已经提供了这样的机制，例如如果你使用象reinterpret_cast<int>(pointer)这样的很明显是非常糟糕的表达式进行造型，别人会很容易地找到问题所在。只不过C++仍然允许你使用传统的、C风格的造型机制，而又有不少人一直使用这种老式的风格，所以才引来麻烦多多。B. S的意思是说，要是现在能够禁止老式的风格该有多好！作为语言设计者的他，恐怕是没有这个机会了，但是作为语言使用者的我们，却还有很大的希望去改进自己的代码。何去何从，应该是我们深思的时候了）
　　我还会把核心语言的体积尽可能搞得小一些，包括类和模板的关键的抽象特性，而把很多其它的语言特性放在库里来解决。当然我也会保证核心语言足够的强大，使得那些库本身也足以用这个核心语言来产生。我可不希望标准库的创建需要用到什么不属于该语言本身的神秘机制。另外我会让这个核心语言的定义更加精确。（有不少的语言在建库时使用了一些“不属于该语言本身的神秘机制”，比如VB和JAVA。从理论上讲，这是近乎无赖的行径，所以B.S不以为然。不过从实用出发倒也无伤大雅）
　　最重要的是，我会在该语言被广泛使用之前尽可能维持一个很长的酝酿期，这样我可以以其他人的反馈为基础进行改进。这可能是最困难的，因为一旦有什么东西是明显出色和有前途的，大家就会蜂拥而至的来使用它，此后作任何不兼容的修正都会是非常困难的。
　　我相信这些思想与我当初设计C++时的理念是非常类似的，同样也是这些思想指引着一二十年来C++的不断演化。当然，我认为现在还没有什么东西能让我觉得像是“完美的语言”。

　　17. 您预期C++做哪些增强，会不会删掉一些东西？
　　很不幸，虽然有一些东西很应该扔掉，但恐怕很难真的删掉任何东西。第一个应该抛弃的东西就是C风格的造型机制和类型截断转换。就算不禁止，编译器的作者们至少也应该对这种行为给与强烈的警告。我希望能用类似vector的东西彻底取代数组，但这显然是不肯能的。不过如果程序员们能主动使用vector来代替数组，就会立刻受益匪浅。关键是你不必再使用C++中最复杂难缠的技巧了，现在有优秀得多的替代方案。
　　至于主要的特性，我没想去掉任何东西。特别是那些把C++与C区别开来的主要特性恐怕没法风平浪静的被抛掉。通常问这些问题的人是希望我挑出诸如多继承、异常、模板等机制来接受批判。所以在这我想大声讲清楚，我认为多继承机制对于静态类型语言实现继承性来说是必需的，异常机制是在大系统中对付错误的正确方法，模板机制是进行类型安全的、精致的和高效的程序设计的灵丹妙药。我们可以在小的细节上对于这些机制挑挑刺，但在大的方面，这些基本的概念都必须坚持。
　　现在我们仍在学习标准C++，也正在标准所提供的特性基础上发展出更新的、更有趣的编程技术。特别是人们刚刚开始使用STL和异常机制，还有很多高效强大的技术鲜为人知，所以大可不必急匆匆的跑去增加什么新的机制。
　　我认为当前的重点是提供很多新的、比以前更加精致的、更有用的库，这方面潜力巨大。例如，如果有一个能被广泛使用的、更精致的支持并发程序设计的库，那将是一大福音——C风格的线程库（例如Pthread——译者）实在不够好。我们也就可以与各种其他的系统，例如SQL以及不同的组件模型更好地契合起来。数值计算领域的人们在这方面好像已经走在了前面，类似像Blitz++、POOMA、MTL之类的高效而精致的库的开发已经取得了非凡的成就。（译者在Internet上造访了Blitz++和POOMA的主页，前者是一个高性能数学库，据称其性能与Fortran 77不相上下，同时又支持大量的C++特性。我想凡是对于数值计算领域有所了解的人都知道这有多么伟大的意义。POOMA则是一个专门研究C++并行数学算法的项目，它的前景更加不可限量。译者非常认同B. S的这个观念。——译者）
　　有了足够的经验之后，我们就能更好的决定应该对标准做些什么调整。

18. 显然，这几年世界变了，正在走向一个以Web为中心、分布式计算为主流的时代。那么您觉得C++还能维持其地位吗？程序员们可不可能把若干种专用语言（比如Perl、Javascript）综合运用以彻底取代某一种通用语言？（C++就是这样的通用语言——译者）为了配合新的计算模式，C++及其标准库应该做怎样的调整？
　　从来没有哪一种语言能适合所有的工作，我恐怕以后也不会有。实际系统通常是用多种语言和工具构造起来的。C++只是想成为若干语言和工具中的一个，当某些专用语言在其领域里特别突出时，它们可以与C++互为补充。也就是说，我觉得如果大多数现在的专用语言能借助特定领域的C++库共同工作的话，它们会表现得更出色。脚本语言通常导致难以维护的代码，而且也没有给程序的结构、可扩展性和可维护性的优化留下什么余地。
　　我不敢肯定未来的代码是否真的会是以Web为中心的。就算是直接处理Web的系统也主要是由处理本地资源，如IP连接之类的程序模块构成的。
　　地理上的分布性以及服务器软件对于并发机制的高度依赖对于系统的建造者来说的确是个挑战。有些针对上述问题的库已经出现，也许我们将会看到它们最终得以标准化。当然，一些原操作和保证规则应该被加到核心语言中以提供对这些库的更佳支持。
　　总的来说，对于Web和网络，我们非常需要一个真正的系统/网络级的安全模型。指望JavaScript之类的脚本语言实现这个模型无异于白日做梦。注意，我也没说C++提供了这个问题的解决方式。C++的重心是高效的访问系统资源，而不是反欺诈。

19. 您看C++未来的走向如何？在接下来的10年里它会衰落吗？或者是基本保持现在的形式？或者发展变化呈不同的形式？
　　C++有着最美好的未来。用它你能写出伟大的代码。除了故意进行恶意欺诈，C++仍将是开发高性能、高复杂度系统的最好语言。据我所知，没有那种语言能在通用性、效率和精致三方面的统一上可与C++相提并论。
　　我没看到C++有衰落的征兆。在我能预见的未来里，它的用途还会不断增长。当然，在未来的十年里我们会看到一些变化，但不会像你想得那么显著。跟每一种语言一样，C++也会发展变化。“语言专家们”要求改进的喧嚣声震耳欲聋，但是系统开发者们的基本请求是保持稳定。
　　C++会改进，但是这些改进将主要是为了反映从实践中得来的经验教训，而不会是为了追风尚赶时髦。为了更高效地使用一些新的编程技术，比如通用编程技术，可能会增加一些小的特性。会有大量的库涌现，我预期会出现一种崭新的、更出色的库支持机制。我希望新的扩展主要集中在支持抽象方面的一般特性，而不是为支持某些特殊任务的特定机制。
　　例如，“属性”这个概念是很有用的，但我不认为在一种通用编程语言中有它的容身之地。用标准C++的一组类可以很容易地支持这一概念。如果我们感觉那族类对于“属性”这一概念的支持不尽如人意，也不会立刻跑去在语言里增加属性机制，而是仔细考虑如何改进类和模板以帮助库设计人员尽可能接近“属性”这个概念。也许通过改进函数对象的机制能够给这个问题一个满意的答复。
　　为了使C++在接下来的十几年中保持灵活可变，很基本的一点就是不要让标准C++赶什么学术或者商业的时髦。人们要求增加的特性中很大一部分通过使用现有的标准C++开发新库的方式都可以实现。还有，事实上人们渴望得到的很多特性已经被包括在标准C++中，并且被最新的编译器支持。对许多程序员来说，提高代码质量的最佳途径不是追求什么语言扩展，而是好好地、慢慢地品味最新的C++技术书籍（可惜我们到目前为止连这种机会都没有——译者）。

　　20. 您怎么看待脚本语言的兴旺态势？特别是Python，似乎提供了一种学习OO技术的更简单的途径
　　有些语言很不错。比如Python，我很喜欢。但是我认为你从不同的语言中学到的OO技术是不完全相同的。当然，每一个专业的程序员都需要通晓几门语言，并且了解各种语言在编程和设计技术上的不同。在我看来，用脚本语言建造的系统与用C++那样的通用语言建造的系统大不相同。从两类语言中学到的技术区别明显。在OO技术里也不存在什么通用部分对于各种系统的高效建造来说都是至关重要的。

　　21. 有没有计划往标准C++里增加一些新的特性以支持分布式计算？
　　没有，我也不认为有这个必要。用更好的库就差不多能解决问题了。最多，为了支持这类的库，我们可能会增加一些低级的原操作和规则

　　22. 未来C++有没有可能定一个可移植的二进制接口？
　　如果你说的“可移植”是指跨硬件和块操作系统的可移植，我想回答是不会。我们当然可以设计一个解释器或者虚拟机（如同Java的做法——译者），但这样一来，由于无法以最优的方式访问系统资源，C++的能力就会受到削弱，。我真正希望在不远的将来能够看见的东西是platform ABIs。例如，有人正在努力为Intel新的IA64体系定义C++ ABI，我想这些努力会得到用户们的巨大支持。
　　能够把不同编译器产生的代码编译在一起将会是一项十分有意义的事情。

23. 在不少流行领域，C++正在渐渐失去光芒，因为它要求人们花很大的精力去对付一些很基本的工作，比如管理内存（因为没有垃圾收集机制），管理模块之间的依赖性（因为没有包机制），管理组件的版本。C++缺乏一些现代语言已经视为标准的特性。比如传言中最酷的Java语言就特别重视这些问题。那么在解决这些问题是否会导致C++的发展背离其根本宗旨呢？C++应该怎样发展以保证我们在这种语言上的投资能有合理的回报，而不是被迫去重新使用另一种语言？
　　我倒还没有注意到C++比以前用的少了。相反，我看到的指标表明C+的使用还在稳定地增长着。只不过这种基数很大的稳定增长以及在标准性、移植性和库方面的不断提高并没有造成什么具有欺骗性的新闻效应而已。我认为你所说的“失去光芒”只不过是市场推销和新闻意义上的现象。
　　如果你需要垃圾收集机制的话，你可以在C++应用程序中插入一个垃圾收集器。有不少自由的和商业的垃圾收集器已经在重要的实践中被证明是很出色的。
　　如果你不想使用垃圾收集机制，也没关系。你可以使用标准容器类，它们大大减少了对于显式分配和回收内存的需要。这样，使用现代的库和现代的编程风格，你能够避免大部分的内存管理问题。
　　同样的技术还能够用来避免一般资源的管理问题。并不是只有内存才会泄漏，线程句柄、文件、互斥锁、网络连接等都是重要的资源，为了建立可靠的系统，这些资源必须被正确的管理。如果你觉得有了垃圾收集机制就可以解决所有的资源管理问题，那么你最好赶快从美梦中醒来。
　　C++提供了很多机制来管理一般性的资源。关键的手段——“获取资源就是初始化”——可以使用函数对象来管理生存期问题。语言中关于对象的局部构造和异常机制对这项技术提供了支持。
　　某些语言的狂热支持者总是用讽刺漫画的笔法描述C++，然而C++实际上要好得多。特别是我觉得很多其他的特性已经泛滥不堪了，在C++中，通常这些特性能够很容易的被模拟出来。相反的，新的语言在推广的过程中总是不断地增加新的特性，这就是为什么从一种语言诞生到被广泛使用，其体积通常会增加个两三倍。
　　目前，做为个人和组织，对于C++的最好投资就是去更好地理解标准C++和现代的C++设计编程技术。大多数人使用C++的方式实际上停留80年代中期的水平，甚至比那更陈旧。
　　至于模块依赖性问题，我的观点是，在编程语言的工作和系统的工作之间应该有一个明显的界线，依赖关系应该尽可能地与编程语言分开，而由系统来支持。
　　我不认为组建版本的问题应该由编程语言来解决，这是一个系统范畴里的问题，在语言里应该通过提供相应的库来解决。C++有这样的机制。解决这样的问题不会使C++偏离轨道。但是给C++增加很多特殊的特性就会使C++偏离轨道，而且在保持可移植性和平台独立性方面也会是一个倒退。

24. 标准C++推出有段时间了，Java也大踏步地往前走而且取得了显著的进步，您现在怎么比较Java与C++？您觉得Java想要变成像C++一样“好”的语言还需要做些什么？您举的C++从Java身上学到了什么经验吗？有没有什么Java的特性您认为是可以被C++吸纳的？
　　我不比较语言。做好这项工作是十分困难的，而且很少具有专业水准。
　　我认为C++的进步会是主要以它的用户在使用中遇到的问题以及其自身逻辑为基础。当然，其他语言中的某些思想也会被考虑，但不能被简单的移花接木过来。你必须审视那些机制在技术上和思想上的背景，并且找到在C++中支持这些技术的最佳方案。
　　有时最好的选择是综合使用几种语言。毕竟没有任何一种语言是放之四海而皆优的。C++现在是，将来也继续会是在广泛应用领域中最好的语言之一。但是，我们不能被拉下水，不能把所有可能的特性都加到C++里面来向大众献媚。我认为Java和C++现在和将来都会是十分不同的语言，语法相似，但背后的对象模型明显不同。
　　对于我来说，一个很重要的区别是C++有一个ISO标准，而Java则是一个专有语言。

25. 在Java刚刚出现的那几年，有很多欺骗性的言论说它将会是终极语言，会取代C++。您觉得在过去两三年里Java对C++的追随者们有什么影响？
　　到现在关于Java的不实之辞也还随处可见。暂且不提Java在过去5年间的创纪录的发展，狂热的大众似乎认为Java将最终取代的不仅仅是C++，而且还有所有其他的编程语言。但在另一方面，C++的使用仍在继续增长。我不认为Java对于C++的影响已经使得人们转而把本来打算用来创造更好的C++工具库的资源调过去开发Java工具库。Java对于学习编程的人来说没有太多的新东西，所以对于C++的定义也没什么影响。在那个领域，Java还得努力追赶。例如，我认为为Sun迟早会往Java里加入类似模板的机制。
　　人们应该认识到C++和Java的目标是何等的不同。 以C++的设计理念来衡量Java，或是以Java的设计理念来衡量C++，得出的结论都不会很好。
　　在访谈即将结束时，或许我该再次表明态度：C++仍然是我喜爱的语言，在写代码时你会发现没有那种语言能像它那样在如此广泛的应用领域和平台上同时达成如此的高效与精致。 
　　
-----
C++高级特性非常邪恶

Linus：“你可以用任何语言编写糟糕的代码。但是有些语言，尤其是带有一些心智(mental)包袱的语言(C++)本身就非常糟糕”

那么，C++比C多出来的东西，真会带来心智包袱吗？不好回答。单从C++特性的繁杂导致的不易掌握和误用这些角度是很难说服我的，更别说去说服那些比我聪明的多的C++程序员们。
我自认为对C++的高级特性掌握的不错，并运用在诸多实际项目中。他们相当有趣，在某种程度上也非常的有效。代码可以获得很高的效率，并可缩短编码时间，完成他们也有成就感。

我再引用Linus的一句说到我心坎里的话：“字符串/内存管理根本无关紧要。这不是重要的部分，而且也不复杂。唯一真正重要的部分是设计”，设计才是重中之重。

如果说10年的程序员生涯我学会了什么，我认为，我比以前能设计出更好的代码了。能更准确的把握设计的坏味道。而对编程语言的掌握，对OS的熟悉，相关知识的了解等，只是自然而然的事，是知识的积累，而非能力的提高。

“抽象”，“面向对象”，“设计模式”，这些重要吗？重要。对软件开发相当重要。但重要不是必要，执迷于“抽象”会使你离目标越来越远。当我们一次又一次的提取出事物的共性，建立起抽象层的时候，我们可能丢弃了真实。

C++继承了C中“信任程序员”这一设计哲学，致力于让程序员在建立抽象层时，可以不做出额外的消耗。他的解决方式是提供尽可能多的语言工具和设计选择，任何一个都允许你在不用的时候不带来额外的性能损失。

这是一个美好的愿景：C++程序员指望可以建立强大的可复用的抽象层，面对世界上一切的具体应用。同时CPU执行序列在穿越这个坚厚的抽象层的过程中，居然可以以光速通过。为此，C++创造了STL，Boost。它们共同的关键词是：效率、复用。

再往上呢？另一个问题产生了：“低效的抽象编程模型，可能在两年之后你会注意到有些抽象效果不怎么样，但是所有代码已经依赖于围绕它设计的‘漂亮’对象模型了，如果不重写应用程序，就无法改正。”这一段依旧是Linus语，我不停的引用，是因为我明白这一点，但是不能表达的更清楚。

C++程序员不断强调复用性，却不断需要重写代码。如果一段代码可以不被重写，那多半是因为对重写工程量的妥协。
是的，其实我们可以用C++的各种特性写出更好，更漂亮，更高效的代码。两年前的框架不那么完美，不是C++语言的错，是两年前能力有限的缘故。
但是因为需要改写的是设计框架，这意味着我们必须跟着变更已经完成的功能模块，或是加上桥接层。

STL和Boost由顶尖程序员完成，质量非常高。我不拿编译器兼容性和可移植性或是编译速度说事，虽然这些的确是现实问题，但不足以成为反对C++基础类库的理由。

用好C++当然得用好STL，Boost，读一下源码更好，合格的C++程序员应该做这个。否则你就违背了C++的设计哲学：C++信任了你，你就该对的起这种信任，搞清楚你写的每一行代码背后，机器都干了什么。

STL过于庞大，Boost更加。
这些高质量代码教会我很多。我隐隐担心的是，这么庞大的代码，它的设计不可能是永远正确的。两年之后，他们的设计肯定依旧正确，再两年还是的。但是我几乎敢肯定，放之更长远的时间来看，绝对会在某些设计领域发现其不是最佳的选择。到那一天，我们会选择修改吗？我想C++社区会被迫选择妥协。但是，C++程序员心中会充满痛苦。

C在这个问题上的抉择是不一样的。在效率问题上，C程序里最令人担心的是函数调用的消耗。C++程序员最津津乐道的案例就是std::sort全面击败了C库中的qsort。C语言的失败正在于多余的函数调用消耗。

但是，从一开始C就选择了承认函数调用的消耗，而这一点几乎是唯一。付出了这个代价后，设计失误导致的效率下降问题几乎总可以避免。C和C++都可以选择重写设计失败的部分，但不一样的是，C程序员几乎可以不考虑妥协的问题。同样的是考虑极端效率的语言，C语言坦然面对缺陷，才是真正的符合了KISS原则。

我对这个问题的见解，可以再引用Linus的一段话作为收场。“如果你想用更花哨的语言，C++绝对是最糟糕的选择。如果想要真正的高级特性，那就选择有垃圾回收或者好的系统集成的，而不是既缺乏C的简约，又缺乏C的直接而且没有（high-level bindings to important concepts）的东西。”。这是我最近几年来一直坚持的观点：C++的发展，一定要补充对GC支持所需要的特性。
我并不讨厌C++。我做的游戏引擎,第一版用C++，但没有用任何类库（包括STL）。第二版，去掉了所有C++高级特性，只用基本特性。重写第三版，换成C。这个项目的发展，反应出我对C/C++理解的心路过程。
Linus 曾尝试用C++开发Linux内核，失败了《Linux之父炮轰C++：糟糕程序员的垃圾语言》
一般场合下，C和C++的主要用途是系统级软件开发。具体说，C/C++写平台、工具和基础库，支持高层的语言来完成应用逻辑。
重要的是理解系统的运作方式，漂亮的抽象手法和高级特性是次要的。
系统软件老手，用一段C++后又回到C。在这个层次上，C++对于C的优势就不突出了。那些高级的抽象结构往往是不必要的，反而是由于抽象层次的提高，使得开发者要弄清楚“下面实际发生的事情”变得不太容易了。所以高手觉得C控制力更强，更得心应手。
C高手对于语言和编译器都很熟悉，写C时就已经知道编译器优化后产生汇编代码是什么样子，甚至可以改变C代码来引导编译器产生最优化的机器码。而C++机制丰富，很多机制是为了满足高层应用和框架的需求而准备的，在这个层次上发挥不出来，反而把清晰性给牺牲掉了。

微软工程师发现git是C而非C++，直言：“别拿可移植性说事儿，这是屁话“（他还批评Git蛮力地直接操作文本，既啰嗦又易错，而且很难跟上高层代码逻辑)

这引起Torvalds的强烈反应，用你才满嘴屁话，作为反驳的开场白。接着，他先转向了对C++的罕见的火药味十足的炮轰：

“C++是一种糟糕的语言。且因为有大量不标准的程序员在使用而使情况更糟，以至于极容易产生彻头彻尾的垃圾。老实说，选择C就是为了把C++程序员踢出去。我有这样的结论，任何喜欢用C++而不是C开发项目的程序员可能都是我希望踢出去的人，免得他们来搞乱我参与的项目。C++会导致非常糟糕的设计。你们这些C++程序员总是一上来就用语言的那些‘漂亮的’库特性比如STL、Boost和其他彻头彻尾的垃圾，这可能对你们的程序有所‘帮助’，但是却会导致：
1 当库无法工作时无穷无尽的折磨（别跟我说什么STL尤其是Boost很稳定而且可移植性很好，那全是屁话，而且一点都不可笑）
2 低效的抽象编程模型，可能在两年之后你发现有些抽象效果不怎么样，但所有代码已经依赖于围绕它设计的‘漂亮’对象模型，如果不重写应用程序，就无法改正。

也就是说，使用优秀的、高效的、系统级的和可移植的C++的唯一方式，最终还是限于使用C本身具有的所有特性。项目限制只用C，意味着参与的人不会捣乱，也意味着会得到许多真正懂得底层问题，而不会折腾那些白痴‘对象模型’垃圾的程序员。

对于Git这种效率优先的软件，C++的所谓优点只是巨大的错误。而我们将看不到这一点的人排除在外却成了一个巨大的附加优势。如果你想要用C++写的版本控制系统，去玩Monotone吧。他们确实使用了‘真格的数据库’，使用了‘漂亮的面向对象库’、使用了‘漂亮的C++抽象’。可是说老实话，所有这些对某些计算机专业人士而言富于吸引力的设计决定，其最终结果确是一堆可怕、难以维护的垃圾。”

Dmitry：

“随着只用C编程的恐龙们逐渐灭绝，你很快就会发现只剩下自己一个人在固执己见。用Git贡献者的数量是说明不了问题的。显然C++开发者也能够贡献C代码。但是以为他们喜欢这种方式，那可就错了。没有C的时候我用汇编编程，然后我转向了C，现在我使用C++和C#，而且不再走回头路。差劲的程序员用任何语言都写不出好程序。但是为了将差劲的贡献者拒之门外这样一个没谱的理由而惩罚优秀的开发者，这简直是胡闹。”

Torvalds：

“和你不同的是，我实实在在地给出了不喜欢C++的原因，而且指出了它可能导致的各种问题的一些例子。而你呢，没有给出一条像样的使用C++的理由。
事实上，Git比其他软件配置管理软件都要好，而好的品味（taste）和C正是原因之一。”
“说得更具体些：简单和清晰的核心数据结构，非常精益（lean）且颇具雄心的暧昧管理着它们，
将“简单胜于花哨”这一方法发挥到极致。有意识地不抽象数据结构和算法，因为它们恰恰是Git核心的全部要素（whole point）。

Dmitry：

“我说过，这是一种信仰问题。因此，任何讲道理和争论都会无穷无尽，而且也毫无意义，就像任何其他宗教问题一样。

我来讲讲Git开发应该使用C++的理由（而不是一般意义上C++对任何项目都更好的理由，这种说法同样也是毫无意义的）：

1. 好的String类能够大大提高代码的可读性（而且代码也会显著减少）
2. 好的Buffer类——理由同上
3. 管理内存和文件/套接字/锁句柄的智能指针和智能句柄
就目前而言，通过这种繁琐的宏管理字符串和内存，很难看出高层逻辑。”

接下来他的语气变得缓和，甚至最后还用了一个笑脸：
“以我之见，Git具有非常漂亮的高层设计（对象数据库，使用散列，数据和元数据的简单而且容易访问的存储）向你赞一个！

但是具体实现方式——C和shell脚本的混合、自底向上发展出来的命令行界面就很一般了。

我可没有将C与汇编语言相提并论。我只是要指出我曾经用许多不同的语言编程，目睹了糟糕的程序员用任何语言都会写出差劲的代码。因此这实际上是与语言无关的。”

Torvalds则依然怒气未消，他反驳Dmitry对Git用宏管理字符串和内存的批评：

“完全是屁话，字符串/内存管理根本无关紧要。还是去看看源代码吧（我打赌你没看过）。这不是重要的部分，而且也不复杂。唯一真正重要的部分是设计。有些部分之所以是用“原型化语言”编写，恰恰是因为它们不是核心部分，而且会被C慢慢地替换掉。C++可没有办法替换shell脚本或者Perl代码。而且C++也没办法让真正核心的部分变得更好。

显然你这一辈子已经经历了汇编->C->C++/C#的转变过程，你将我这样一直坚持用C的比作恐龙，似乎这是一种向更好/更现代的语言不可避免的演进。这是毫无根据的，因为C在很多方面都远远优于C++（更优于C#），包括可移植性，还有接口和低层支持。

你当然可以用任何语言编写糟糕的代码。但是，有些语言，尤其是带有一些心理（mental）包袱的语言本身就非常糟糕。你这样的新手跑来指出一些绝对无关紧要的补丁特性（此处应该指C++对C的增强特性），用它们作为一种语言优越的论据（这些东西语言原作者都不喜欢），这一事实本身恰恰说明你满脑子都是糊涂概念，应该好好醒悟一下了。

对于Git核心代码真正重要的，是诸如这样的事情：编写自己的对象分配代码，使内存占用尽可能小，从而能够高效地记录百万对象的标志。这实际上是为树形关系的多个对象编写本质上非常优化的分析程序，因为这里没有任何抽象。这绝对是在原始内存字节一级上的。

这些事情能够用C之外的语言编写吗？当然可以。但是那些认为C++字符串处理这样的高级特性很重要的人肯定是写不出来的。

事实上，这正是C擅长的事情。不仅指语言本身，还包括一种必需的心态（mentality）。C最大的优点之一，就是它不会使你认为程序是什么高层的东西。正是后一种心态会使你明显偏向其他语言，但实际上从Git的角度看来，所谓'高层'恰恰是错误的。”

Dmitry回帖：
我不仅看过源代码，而且还做过很多调试工作。我发现的问题大多数都与处理Windows上的路径（也就是字符串处理）有关。

他表示不再纠缠于“C与C++孰优孰劣”的讨论，而是介绍了一下自己的出发点：

“我的目的是使用Git。当有些功能无法使用时，我想能够在尽可能最短时间和花费最小的力气进行改正并贡献改正的代码。对我来说，这只是我主要工作的一种消遣而已。而Git用C编写这一事实，对这一目的毫无好处。建议使用C++是现有C代码基础的唯一出路。所以，虽然C++可能从学术上来讲并非最佳选择，但是唯一切合实际的选择。现在，我认识到自己只是一个不太活跃的贡献者，但我希望自己的声音能够被人听到。而那些承担开发和维护Git主要重任的人也应该发出自己的声音。”

此后，Torvalds没有再发言，大概是认为自己已经大获全胜。而另外一些Git贡献者继续对Dmitry进行反驳，可以看出，Torvalds的看法并不是他的私见。

Theodore Tso说：
Dmitry有一点是正确的，语言之争更多的是一种类似宗教信仰上的，所以很难有结果，也没有实际意义。这种争论因为出自高手之间，所以还是会透露出很多重要的信息。比如：

对于要求性能高的系统编程领域，C++其实未必胜过C，而且事实上，也确实有很多此类项目是选择C作为主要语言的。C的生命力目前仍然毋庸置疑。
 C++目前确实处于一种被夹攻的态势，一方面在企业级系统开发（数据密集、业务规则复杂多变）中，C++已经基本被Java和C#等淘汰出局.另一方面在系统编程和嵌入式等更接近硬件的领域，又遭到C的强烈狙击。

C++的困境，很大程度上是由于此前的图书和文献曾经一度倾向于炫技，陶醉于对语言各种细节的深入探索，有华丽化、复杂化的趋势，语言设计者们苦心设计出来各种丰富的特性和多范型的编程风格，却成了学习者和使用者的负担，加上微软等开发工具又用MFC之类的糖衣，结果造就了大批基础不牢、半桶水叮当响的C++程序员，而且因为自以为掌握了世上最难的语言，往往有目空一切的傲气。这样开发出来的代码质量，可想而知。

对C++的各种误解和不良使用习惯漫天飞。这种局面造成C++逐渐成为一般人心目中望而生畏、学不好教不好更用不好的“专家语言”，越来越无法吸引新入行的程序员。老人毛病多多，新人青黄不接，C++社区的确面临危机。

这几年，C++界的核心人物，对此局面有过较多的反思，痛定思痛之后，写作了《Learning C++ as a New Language》、《C++ Primer》、《C++编程规范》、《Accelerated C++》和《C++必知必会》等返璞归真的文章和图书。其核心变化，是对标准库（Torvalds对STL和Boost也很不屑，不知是何原因）、规范化、领域概念和设计的强调，弱化底层语言细节，或者说强调更规范地选择使用语言特性。

比较同一作者的《C++ Primer》第四版和第三版、《C++编程规范》和《Modern C++ Design》以及Exceptional C++系列，可以清楚地看到这一点。

比如Primer第三版一上来就突出C++的多种编程风格（过程式编程、基于对象编程、面向对象编程、泛型编程），并且以此作为布局谋篇的主线，很容易使初学者晕倒。到了第四版，则更多地把力气花在打好扎实的基础，介绍那些实际开发中通用的、行之有效的编程技术，在特定场合，C++提供的丰富“武器库”中应该选择哪些设施、应该注意哪些问题、业界已经总结了哪些优秀的编程实践和易犯的错误等，成了书中的主干。这使此书成为目前最适合的C++学习和使用的百科全书。


迪杰斯特拉在《The Threats to Computing Science》上说:
“想给那些已经接触Basic的学生教好编程规范，几乎不可能。因为这些人的脑子已经被摧残，并且没有痊愈的希望”

用C/C++写代码，就像在没有保护设施的链锯上奔跑。—— 鲍勃·格雷（作家）
C语言可以让你容易用枪打到自己的脚；而C++则更不容易打到脚，但如果你硬开枪，则会轰烂你整个腿。 —— Bjarne Stroustrup
编程语言进化过程：Fortran是无类型语言；C是弱类型语言；Ada是强类型语言；C++是一种高度言过其实的语言。—— Ron Sercely
我发明了“面向对象”这个术语，但我脑子中并没有C++。—— 艾伦·凯（Smalltalk语言创造者）
C++中的最新特性就是用来修正之前的新特性。—— David Jameson
Java就是没有枪支、刀具和棍棒的C++。 —— 詹姆斯·高斯林（Java 之父）
世间只有两类编程语言：常被人喷的和没人用的。—— Bjarne Stroustrup

java之父评价C之父：
一位巨星的陨落。我仍然爱着C语言。如此简单，如此强大。里奇是个天才。IT业的所有都基于肯贝汉和里奇的成果
----

有时觉得架构太复杂，然后开始内心的纠结，
判定标准：用更“简单”架构能否解决同样的问题，能，说明别人设计的复杂了，不能，说明我没理解到问题的复杂性。

所以，这种继承只是用另外一种方法把这些逻辑组织了起来。
实际上，最重要的还是ui的逻辑，而不是OO，逻辑没有想明白，再牛逼的OO也解决不了实际的逻辑问题。
