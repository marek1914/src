Bjarne Stroustrup博士《The C++ Programming Language》

1. 请谈谈C++书
  　没有一本书对所有人来说都是最好的。不过对于那些真正的程序员来说，我推荐The C++ Programming Language，那是纯而又纯的C++，完全独立于库（除标准库）。

2. 了解C是学习C++的先决条件吗？
　  NO! C++中与C相近的子集其实比C语言本身要好学，类型方面的错误会少一些，也不像C那样绕圈子，还有更好的支持库。所以应该从这个子集开始学习C++。

3. 如何开始学习C++？
　  一本C++书是必不可少的，文档资料不是学习编程思想的好教材。要矢志不渝地使用标准库。如，从输入中读取一个字符串应该这样：
	　　string s; // Standard C++ style
	　　cin >> s;
	　而不是：
	　　char s[MAX]; /* Standard C style */
	　　scanf("%s",s);

4. 怎样改进我的C++程序？
　　大多数人低估了抽象类和模板的价值，却肆无忌惮地使用造型机制(cast)和宏。
　　抽象类和模板的作用当然是提供一种方便的手段建构单根的类层次或者重用函数，但更重要的是，它们作为接口提供了简洁的、逻辑性的服务表示机制。

5. 语言的选择是不是很重要？
　　是，但也别指望奇迹。很多人似乎相信某一种语言能够解决他们在系统开发中遇到的几乎所有问题，他们不断地去寻找完美的编程语言，然后一次次失败。
另一些人则将编程语言贬为无关紧要的细节，把大把银子放在开发流程和设计方法上，永远在用C和一些专有语言。一种优秀的语言，如C++，能帮助程序员做很多事。

6. ANSI/ISO标准委员会是不是糟蹋了C++？
　　他们的工作很出色。你可以在一些细节上找些歪理来挑刺，但我个人对于这种语言以及新的标准库可是欣欣然。ISO C++较之C++的以前版本更出色更有条理。
相对于标准化过程开始之初，你今天可以写出更优雅、更易于维护的C++程序。新标准库提供了strings, lists, vectors, maps以及作用于其上的基本算法，使用C++的方式已经发生了巨大的变化。

7. 你现在有没有想删除一些C++特性？
　　没有，问这些问题的人大概是希望我回答下面特性中的一个：多继承、异常、模板和RTTI。但没有它们，C++是不完整的。在过去的N年中，我已经反复考虑过它们的设计，并且与标准委员会一起改进了其细节，但是没有一个能被去掉又不引起大地震。从语言设计角度讲，我最不喜欢的部分是与C兼容的那个子集，但又不能把它去掉，因为那样对于在现实世界里工作的程序员们来说伤害太大。与C兼容是一项关键的设计决策，绝不是噱头。兼容性的实现和维护十分困难，但确实使程序员们至今受益良多。但现在，C++已经有了新特性，程序员们可以从麻烦多多的C风格中解脱出来。
例如，使用标准库里的容器类，象vector, list, map, string等等，可以避免与底层的指针操作技巧混战不休。

8. 如果不必和C兼容，你所创造的语言是不是就会是Java?
　　不是，差得远。如果人们非要拿C++和Java来作比较，我建议阅读 The Design and Evolution of C++，看看C++为什么是今天这个样子，用我在设计C++时遵从的原则来检验这两种语言。这些原则与Java所持的理念显然是不同的。除了表面语法的相似性之外，C++与Java是截然不同的语言。在很多方面，Java更像Smalltalk（译者按：Sun培训教材写道：Java在设计上采用了与C++相似的语法，与Smalltalk相似的语义。所以说Java与C++是貌合神离，与Smalltalk才是心有灵犀）。Java语言相对简单，这部分是一种错觉，部分是因为这种语言还不完整。随着时间的推移，Java在体积和复杂度上会大大增长。在体积上它会增长两到三倍，而且会出现一些实现相关的扩展或者库。这是每个成功的商业语言都必须走过的发展之路。随便分析一种你认为在很大范围内取得了成功的语言，我知道肯定是无有例外者，而且实际上这非常有道理。

　　上边这段话是Java 1.1推出之前写的。我确信Java需要类似模板的机制，并且需要增强对于固有类型的支持。简单地说，就是为了基本的完整性也应该做这些工作。另外还需要做很多小的改动，大部分是扩展。1998年秋，我从Java语言创始人那里得到一份建议书，说是要在Java中增加固有类型、操作符重载以及数学计算支持。还有一篇论文，是数学分析领域的世界级大师，伯克利大学的W. Kahan教授所写的How Java’s Floating-Point Hurts Everyone Everywhere，揭露了Java的一些秘密。
　　”Java is not platform-independent, it is the platform” B.S这句评语对于C++用户有很大影响，有些C++高手把它为签名，以表誓死捍卫C++的决心。喜爱的语言既是工具，更是信仰。

9. 您怎么看待C#语言？
　　就C#语言本身我没什么好说的。想让我相信这个世界还需要另外一个专有的语言可不是一件容易的事，而且这个语言还是专门针对某一个专有操作系统的，这就更让我难以接受。我不是一个专有语言的痴迷者，而是一个开放的正式标准的拥护者。

10. 你愿不愿将C++与别的语言比较？
　　抱歉，我不愿意。你可以在The Design and Evolution of C++的介绍性文字里找到原因。
　　有不少书评家邀请我把C++与其它的语言相比，我已经决定不做此类事情。在此我想重申一个我很久以来一直强调的观点：语言之间的比较没什么意义，更不公平。主流语言之间的合理比较要耗费很大的精力，多数人不会愿意付出这么大的代价。另外还需要在广泛的应用领域有充分经验，保持一种不偏不倚、客观独立的立场，有着公正无私的信念。我没时间，而且作为C++的创造者，在公正无私这一点上我永远不会获得完全的信任。

　　人们试图把各种语言拿来比较长短，有些现象我已经一次又一次地注意到，坦率地说我感到担忧。作者们尽力表现的公正无私，但是最终都是无可救药地偏向于某一种特定的应用程序，某一种特定的编程风格，或者某一种特定的程序员文化。更糟的是，当某一种语言明显地比另一种语言更出名时，一些不易察觉的偷梁换柱就开始了：比较有名的语言中的缺陷被有意淡化，而且被拐弯抹角地加以掩饰；而同样的缺陷在不那么出名的语言里就被描述为致命硬伤。类似的，有关比较出名的语言的技术资料经常更新，而不太出名的语言的技术资料往往是几年以前的，试问这种比较有何公正性和意义可言？所以我对于C++之外的语言的评论严格限制在一般性的特别特定的范畴里。换言之，我认为C++是大多数人开发大部分应用程序时的最佳选择。

12. 别人可是经常拿他们的语言与C++比来比去，这让你感到不自在了吗？
　　当这些比较不完整或出于商业目时，我确实感觉不爽。那些散布最广的比较性评论大多是由某种语言，比方说Z语言的拥护者发表的，其目的是为了证明Z比其它的语言好。由于C++被广泛地使用，所以C++通常成了黑名单上的头一个名字。通常，这类文章被夹在Z语言的供货商提供的产品之中，成了其市场竞争的一个手段。令人震惊的是，相当多的此类评论引用那些在开发Z语言的公司中工作的雇员的文章，而这些经不起考验文章无非是想证明Z是最好的。特别是在这些比较中确实有一些零零散散的事实，（所以更具欺骗性——译者），毕竟没有一种语言在任何情况下都是最好的。C++当然不完美，不过请注意，特意选择出来的事实虽然好像正确，但有时是完全的误导。以后再看到语言比较方面的文章时，请留心是谁写的，他的表述是不是以事实为依据，以公正为准绳，特别是评判的标准是不是对于所引述的每一种语言来说都公平合理。这可不容易做到。
　　
13. 做小项目时，C优于C++吗？
　　非也，我从没有看到哪个项目用C会比用C++更合适。

14. 如果您现在有机会从头设计C++语言，您会做些什么不同的事情？
　　永远不可能重新设计一种语言，没有意义，任何一种语言都是它那个时代的产物。如果让我今天再设计一种语言，我仍然会综合考虑逻辑的优美、效率、通用性、实现的复杂程度和人们的喜好。我会寻找一种简单得多的语法，把类型系统的冲突问题限制在很少的几种情况里，而且你能很容易的发现这些问题。这样就能够很容易的禁止不安全的操作。
　　（B.S的原则是：对于糟糕的代码，就算是不能完全禁止，至少也要让它大白于天下，而不是藏在阴暗的角落里暗箭伤人。C++实际上已经提供了这样的机制，例如如果你使用象reinterpret_cast<int>(pointer)这样的很明显是非常糟糕的表达式进行造型，别人会很容易地找到问题所在。只不过C++仍然允许你使用传统的、C风格的造型机制，而又有不少人一直使用这种老式的风格，所以才引来麻烦多多。B. S的意思是说，要是现在能够禁止老式的风格该有多好！作为语言设计者的他，恐怕是没有这个机会了，但是作为语言使用者的我们，却还有很大的希望去改进自己的代码。何去何从，应该是我们深思的时候了）
　　我还会把核心语言的体积尽可能搞得小一些，包括类和模板的关键的抽象特性，而把很多其它的语言特性放在库里来解决。当然我也会保证核心语言足够的强大，使得那些库本身也足以用这个核心语言来产生。我可不希望标准库的创建需要用到什么不属于该语言本身的神秘机制。另外我会让这个核心语言的定义更加精确。（有不少的语言在建库时使用了一些“不属于该语言本身的神秘机制”，比如VB和JAVA。从理论上讲，这是近乎无赖的行径，所以B.S不以为然。不过从实用出发倒也无伤大雅）
　　最重要的是，我会在该语言被广泛使用之前尽可能维持一个很长的酝酿期，这样我可以以其他人的反馈为基础进行改进。这可能是最困难的，因为一旦有什么东西是明显出色和有前途的，大家就会蜂拥而至的来使用它，此后作任何不兼容的修正都会是非常困难的。
　　我相信这些思想与我当初设计C++时的理念是非常类似的，同样也是这些思想指引着一二十年来C++的不断演化。当然，我认为现在还没有什么东西能让我觉得像是“完美的语言”。

15. 您预期C++做哪些增强，会不会删掉一些东西？
　　很不幸，虽然有一些东西很应该扔掉，但恐怕很难真的删掉任何东西。第一个应该抛弃的东西就是C风格的造型机制和类型截断转换。就算不禁止，编译器的作者们至少也应该对这种行为给与强烈的警告。我希望能用类似vector的东西彻底取代数组，但这显然不可能。不过如果程序员主动使用vector代替数组，会立刻受益匪浅。关键是你不必再使用C++中最复杂难缠的技巧了，现在有优秀得多的替代方案。
　　至于主要的特性，我没想去掉任何东西。特别是那些把C++与C区别开来的主要特性恐怕没法风平浪静的被抛掉。通常问这些问题的人是希望我挑出诸如多继承、异常、模板等机制来接受批判。所以在这我想大声讲清楚，我认为多继承机制对于静态类型语言实现继承性来说是必需的，异常机制是在大系统中对付错误的正确方法，模板机制是进行类型安全的、精致的和高效的程序设计的灵丹妙药。我们可以在小的细节上对于这些机制挑挑刺，但在大的方面，这些基本的概念都必须坚持。
　　当前重点是提供更精致、更有用的库。数值计算领域在这方面走在了前面，像Blitz++、POOMA、MTL之类的高效而精致的库的开发已经取得了非凡的成就。

16. 现在是以Web为中心的时代。您觉得C++还能维持其地位吗？程序员们可不可能把若干种专用语言（如Perl、Javascript）综合运用以彻底取代某一种通用语言？C++及标准库应该做怎样的调整？
　　从来没有哪一种语言能适合所有的工作，我恐怕以后也不会有。实际系统通常是用多种语言和工具构造起来的。C++只是想成为若干语言和工具中的一个，当某些专用语言在其领域里特别突出时，它们可以与C++互为补充。也就是说，我觉得如果大多数现在的专用语言能借助特定领域的C++库共同工作的话，它们会表现得更出色。脚本语言通常导致难以维护的代码，而且也没有给程序的结构、可扩展性和可维护性的优化留下什么余地。
　　我不敢肯定未来的代码是否真的会是以Web为中心的。就算是直接处理Web的系统也主要是由处理本地资源，如IP连接之类的程序模块构成的。
　　地理上的分布性以及服务器软件对于并发机制的高度依赖对于系统的建造者来说的确是个挑战。有些针对上述问题的库已经出现，也许我们将会看到它们最终得以标准化。当然，一些原操作和保证规则应该被加到核心语言中以提供对这些库的更佳支持。
　　总的来说，对于Web和网络，我们非常需要一个真正的系统/网络级的安全模型。指望JavaScript之类的脚本语言实现这个模型无异于白日做梦。注意，我也没说C++提供了这个问题的解决方式。C++的重心是高效的访问系统资源，而不是反欺诈。

17. C++未来的走向如何？它会衰落吗？或者是基本保持现在的形式？
　　C++有着最美好的未来。用它你能写出伟大的代码。除了故意进行恶意欺诈，C++仍将是开发高性能、高复杂度系统的最好语言。据我所知，没有那种语言能在通用性、效率和精致三方面的统一上可与C++相提并论。
　　我没看到C++有衰落的征兆。在我能预见的未来里，它的用途还会不断增长。当然，在未来的十年里我们会看到一些变化，但不会像你想得那么显著。跟每一种语言一样，C++也会发展变化。“语言专家们”要求改进的喧嚣声震耳欲聋，但是系统开发者们的基本请求是保持稳定。
　　C++会改进，但是这些改进将主要是为了反映从实践中得来的经验教训，而不会是为了追风尚赶时髦。为了更高效地使用一些新的编程技术，比如通用编程技术，可能会增加一些小的特性。会有大量的库涌现，我预期会出现一种崭新的、更出色的库支持机制。我希望新的扩展主要集中在支持抽象方面的一般特性，而不是为支持某些特殊任务的特定机制。
　　例如，“属性”这个概念是很有用的，但我不认为在一种通用编程语言中有它的容身之地。用标准C++的一组类可以很容易地支持这一概念。如果我们感觉那族类对于“属性”这一概念的支持不尽如人意，也不会立刻跑去在语言里增加属性机制，而是仔细考虑如何改进类和模板以帮助库设计人员尽可能接近“属性”这个概念。也许通过改进函数对象的机制能够给这个问题一个满意的答复。
　　为了使C++在接下来的十几年中保持灵活可变，很基本的一点就是不要让标准C++赶什么学术或者商业的时髦。人们要求增加的特性中很大一部分通过使用现有的标准C++开发新库的方式都可以实现。还有，事实上人们渴望得到的很多特性已经被包括在标准C++中，并且被最新的编译器支持。对许多程序员来说，提高代码质量的最佳途径不是追求什么语言扩展，而是好好地、慢慢地品味最新的C++技术书籍（可惜我们到目前为止连这种机会都没有——译者）。

18. 您怎么看待脚本语言的兴旺态势？特别是Python，似乎提供了一种学习OO技术的更简单的途径
　　有些语言很不错。比如Python，我很喜欢。但是我认为你从不同的语言中学到的OO技术是不完全相同的。当然，每一个专业的程序员都需要通晓几门语言，并且了解各种语言在编程和设计技术上的不同。在我看来，用脚本语言建造的系统与用C++那样的通用语言建造的系统大不相同。从两类语言中学到的技术区别明显。在OO技术里也不存在什么通用部分对于各种系统的高效建造来说都是至关重要的。

19. 有没有计划往标准C++里增加一些新的特性以支持分布式计算？
　　没有，我也不认为有这个必要。用更好的库就差不多能解决问题了。最多，为了支持这类的库，我们可能会增加一些低级的原操作和规则

20. 未来C++有没有可能定一个可移植的二进制接口？
　　不会。我们当然可以设计一个解释器或虚拟机（如同JVM），但这样一来，由于无法以最优的方式访问系统资源，C++的能力就会受到削弱。我真正希望看见的东西是platform ABIs。能够把不同编译器产生的代码编译在一起将会是一项十分有意义的事情。

21. 在不少流行领域，C++正渐渐失去光芒，因为它要求人们花很大的精力去对付一些很基本的工作，比如管理内存(无垃圾回收)，管理模块之间的依赖性（无包机制）。C++缺乏一些现代语言已经视为标准的特性。
　　我没有注意到C++比以前用的少了。相反，我看到的指标表明C+的使用还在稳定地增长着。我认为你所说的“失去光芒”只不过是市场推销意义上的现象。

　　如果你需要垃圾收集机制，你可以在C++应用程序中插入一个垃圾收集器。有不少自由的和商业的垃圾收集器已经在重要的实践中被证明是很出色的。
　　如果你不想使用垃圾收集机制，也没关系。你可以使用标准容器类，它们大大减少了对于显式分配和回收内存的需要。这样，使用现代的库和现代的编程风格，你能够避免大部分的内存管理问题。
　　同样的技术还能够用来避免一般资源的管理问题。并不是只有内存才会泄漏，线程句柄、文件、互斥锁、网络连接等都是重要的资源，为了建立可靠的系统，这些资源必须被正确的管理。
    如果你觉得有了垃圾收集机制就可以解决所有的资源管理问题，那么你最好赶快从美梦中醒来。
　　C++提供了很多机制来管理一般性的资源。关键的手段——“获取资源就是初始化”——可以使用函数对象来管理生存期问题。语言中关于对象的局部构造和异常机制对这项技术提供了支持。
　　某些语言的狂热支持者总是用讽刺漫画的笔法描述C++，然而C++实际上要好得多。特别是我觉得很多其他的特性已经泛滥不堪了，在C++中，通常这些特性能够很容易的被模拟出来。相反的，新的语言在推广的过程中总是不断地增加新的特性，这就是为什么从一种语言诞生到被广泛使用，其体积通常会增加个两三倍。

　　个人对于C++的最好投资是去更好地理解标准C++和现代的C++设计编程技术。大多数人使用C++的方式停留80年代中期水平，甚至更陈旧。
　　至于模块依赖性问题，我的观点是，在编程语言的工作和系统的工作之间应该有一个明显的界线，依赖关系应该尽可能地与编程语言分开，而由系统来支持。
　　我不认为组建版本的问题应该由编程语言来解决，这是一个系统范畴里的问题，在语言里应该通过提供相应的库来解决。C++有这样的机制。解决这样的问题不会使C++偏离轨道。但是给C++增加很多特殊的特性就会使C++偏离轨道，而且在保持可移植性和平台独立性方面也会是一个倒退。

22. 标准C++推出有段时间了，Java也大踏步地往前走而且取得了显著的进步，您现在怎么比较Java与C++？您觉得Java想要变成像C++一样“好”的语言还需要做些什么？您举的C++从Java身上学到了什么经验吗？有没有什么Java的特性您认为是可以被C++吸纳的？
　　我不比较语言。做好这项工作是十分困难的，而且很少具有专业水准。
　　我认为C++的进步会是主要以它的用户在使用中遇到的问题以及其自身逻辑为基础。当然，其他语言中的某些思想也会被考虑，但不能被简单的移花接木过来。你必须审视那些机制在技术上和思想上的背景，并且找到在C++中支持这些技术的最佳方案。
　　有时最好的选择是综合使用几种语言。毕竟没有任何一种语言是放之四海而皆优的。C++现在是，将来也继续会是在广泛应用领域中最好的语言之一。但是，我们不能被拉下水，不能把所有可能的特性都加到C++里面来向大众献媚。我认为Java和C++现在和将来都会是十分不同的语言，语法相似，但背后的对象模型明显不同。

23. 很多欺言论说java将是终极语言，会取代C++。
　　到现在关于Java的不实之辞也还随处可见。暂且不提Java在过去5年间的创纪录的发展，狂热的大众似乎认为Java将最终取代的不仅仅是C++，而且还有所有其他的编程语言。但在另一方面，C++的使用仍在继续增长。我不认为Java对于C++的影响已经使得人们转而把本来打算用来创造更好的C++工具库的资源调过去开发Java工具库。Java对于学习编程的人来说没有太多的新东西，所以对于C++的定义也没什么影响。在那个领域，Java还得努力追赶。例如，我认为为Sun迟早会往Java里加入类似模板的机制。
　　人们应该认识到C++和Java的目标是何等的不同。以C++的设计理念来衡量Java，或是以Java的设计理念来衡量C++，得出的结论都不会很好。
　　
    我该再次表明态度：C++仍是我喜爱的语言，在写代码时你会发现没有那种语言能像它那样在如此广泛的应用领域和平台上同时达成如此的高效与精致。 
　　
-----
C++高级特性很邪恶

Linus：“你可以用任何语言编写糟糕的代码。但是有些语言，尤其是带有一些心智(mental)包袱的语言(C++)本身就非常糟糕”

那么，C++比C多出来的东西，真会带来心智包袱吗？不好回答。单从C++特性的繁杂导致的不易掌握和误用这些角度是很难说服我的，更别说去说服那些比我聪明的多的C++程序员们。
我自认为对C++的高级特性掌握的不错，并运用在诸多实际项目中。他们相当有趣，在某种程度上也非常的有效。代码可以获得很高的效率，并可缩短编码时间，完成他们也有成就感。

我再引用Linus的一句说到我心坎里的话：“字符串/内存管理根本无关紧要。这不是重要的部分，而且也不复杂。唯一真正重要的部分是设计”，设计才是重中之重。

如果说10年的程序员生涯我学会了什么，我认为，我比以前能设计出更好的代码了。能更准确的把握设计的坏味道。而对编程语言的掌握，对OS的熟悉，相关知识的了解等，只是自然而然的事，是知识的积累，而非能力的提高。

抽象，面向对象，设计模式，这些重要吗？对软件开发相当重要。但重要不是必要，执迷于“抽象”会使你离目标越来越远。当一次次提取出事物的共性，建立起抽象层时，我们可能丢弃了真实。

C++继承了C“信任程序员”这一设计哲学，致力于让程序员在建立抽象层时，可以不做出额外的消耗。他的解决方式是提供尽可能多的语言工具和设计选择，任何一个都允许你在不用的时候不带来额外的性能损失。

这是一个美好的愿景：C++程序员指望可以建立强大的可复用的抽象层，面对世界上一切的具体应用。同时CPU执行序列在穿越这个坚厚的抽象层的过程中，居然可以光速通过。为此，C++创造了STL，Boost。它们共同的关键词是：效率、复用。另一个问题产生了：“低效的抽象编程模型，可能在两年之后你会注意到有些抽象效果不怎么样，但是所有代码已经依赖于围绕它设计的‘漂亮’对象模型了，如果不重写应用程序，就无法改正。”这是Linus语，我不停的引用，是因为我明白这一点，但是不能表达的更清楚。

C++程序员不断强调复用性，却不断需要重写代码。如果一段代码可以不被重写，那多半是因为对重写工程量的妥协。
是的，其实我们可以用C++的各种特性写出更好，更漂亮，更高效的代码。两年前的框架不那么完美，不是C++语言的错，是两年前能力有限的缘故。
但是因为需要改写的是设计框架，这意味着我们必须跟着变更已经完成的功能模块，或是加上桥接层。

Linus: “如果你想用更花哨的语言，C++绝对是最糟糕的选择。如果想要真正的高级特性，那就选择有垃圾回收或者好的系统集成的，而不是既缺乏C的简约，又缺乏C的直接而且没有（high-level bindings to important concepts）的东西。”。
Linus 曾尝试用C++开发Linux，失败了《Linux之父炮轰C++：糟糕程序员的垃圾语言》
重要的是理解系统的运作方式，漂亮的抽象手法和高级特性是次要的。
在系统软件层次，C++对于C的优势不突出，高级抽象结构往往是不必要的，反而由于抽象层次的提高，使得开发者要弄清楚“下面实际发生的事情”变得不容易。C++很多机制是为高层应用而准备，在这个层次上发挥不出来，反而把清晰性给牺牲掉。

微软工程师发现git是C而非C++，直言：“别拿可移植性说事儿，这是屁话“（他还批评Git蛮力地直接操作文本，既啰嗦又易错，而且很难跟上高层代码逻辑)

这引起Torvalds的强烈反应，用你才满嘴屁话，作为反驳的开场白。接着，他先转向了对C++的罕见的火药味十足的炮轰：

“C++是一种糟糕的语言。且因为有大量不标准的程序员在使用而使情况更糟，以至于极容易产生彻头彻尾的垃圾。老实说，选择C就是为了把C++程序员踢出去。我有这样的结论，任何喜欢用C++而不是C开发项目的程序员可能都是我希望踢出去的人，免得他们来搞乱我参与的项目。C++会导致非常糟糕的设计。你们这些C++程序员总是一上来就用语言的那些‘漂亮的’库特性比如STL、Boost和其他彻头彻尾的垃圾，这可能对你们的程序有所‘帮助’，但是却会导致：
1 当库无法工作时无穷无尽的折磨
2 低效的抽象编程模型，可能在两年之后你发现有些抽象效果不怎么样，但所有代码已经依赖于围绕它设计的‘漂亮’对象模型，如果不重写应用程序，就无法改正。

也就是说，使用优秀的、高效的、系统级的和可移植的C++的唯一方式，最终还是限于使用C本身具有的所有特性。项目限制只用C，意味着参与的人不会捣乱，也意味着会得到许多真正懂得底层问题，而不会折腾那些白痴‘对象模型’垃圾的程序员。

对于Git这种效率优先的软件，C++的所谓优点只是巨大的错误。而我们将看不到这一点的人排除在外却成了一个巨大的附加优势。如果你想要用C++写的版本控制系统，去玩Monotone吧。他们确实使用了‘真格的数据库’，使用了‘漂亮的面向对象库’、使用了‘漂亮的C++抽象’。可是说老实话，所有这些对某些计算机专业人士而言富于吸引力的设计决定，其最终结果确是一堆可怕、难以维护的垃圾。”

Dmitry：

“随着只用C编程的恐龙们逐渐灭绝，你很快就会发现只剩下自己一个人在固执己见。用Git贡献者的数量是说明不了问题的。显然C++开发者也能够贡献C代码。但是以为他们喜欢这种方式，那可就错了。没有C的时候我用汇编编程，然后我转向了C，现在我使用C++和C#，而且不再走回头路。差劲的程序员用任何语言都写不出好程序。但是为了将差劲的贡献者拒之门外这样一个没谱的理由而惩罚优秀的开发者，这简直是胡闹。”

Torvalds：

“和你不同的是，我实实在在地给出了不喜欢C++的原因，而且指出了它可能导致的各种问题的一些例子。而你呢，没有给出一条像样的使用C++的理由。
事实上，Git比其他软件配置管理软件都要好，而好的品味（taste）和C正是原因之一。”
“说得更具体些：简单和清晰的核心数据结构，非常精益（lean）且颇具雄心的暧昧管理着它们，
将“简单胜于花哨”这一方法发挥到极致。有意识地不抽象数据结构和算法，因为它们恰恰是Git核心的全部要素（whole point）。

Dmitry：

“我说过，这是一种信仰问题。因此，任何讲道理和争论都会无穷无尽，而且也毫无意义，就像任何其他宗教问题一样。

我来讲讲Git开发应该使用C++的理由（而不是一般意义上C++对任何项目都更好的理由，这种说法同样也是毫无意义的）：

1. 好的String类能够大大提高代码的可读性（而且代码也会显著减少）
2. 好的Buffer类——理由同上
3. 管理内存和文件/套接字/锁句柄的智能指针和智能句柄
就目前而言，通过这种繁琐的宏管理字符串和内存，很难看出高层逻辑。”

接下来他的语气变得缓和，甚至最后还用了一个笑脸：
“以我之见，Git具有非常漂亮的高层设计（对象数据库，使用散列，数据和元数据的简单而且容易访问的存储）向你赞一个！

但是具体实现方式——C和shell脚本的混合、自底向上发展出来的命令行界面就很一般了。

我可没有将C与汇编语言相提并论。我只是要指出我曾经用许多不同的语言编程，目睹了糟糕的程序员用任何语言都会写出差劲的代码。因此这实际上是与语言无关的。”

Torvalds则依然怒气未消，他反驳Dmitry对Git用宏管理字符串和内存的批评：

“完全是屁话，字符串/内存管理根本无关紧要。还是去看看源代码吧（我打赌你没看过）。这不是重要的部分，而且也不复杂。唯一真正重要的部分是设计。有些部分之所以是用“原型化语言”编写，恰恰是因为它们不是核心部分，而且会被C慢慢地替换掉。C++可没有办法替换shell脚本或者Perl代码。而且C++也没办法让真正核心的部分变得更好。

显然你这一辈子已经经历了汇编->C->C++/C#的转变过程，你将我这样一直坚持用C的比作恐龙，似乎这是一种向更好/更现代的语言不可避免的演进。这是毫无根据的，因为C在很多方面都远远优于C++（更优于C#），包括可移植性，还有接口和低层支持。

你当然可以用任何语言编写糟糕的代码。但是，有些语言，尤其是带有一些心理（mental）包袱的语言本身就非常糟糕。你这样的新手跑来指出一些绝对无关紧要的补丁特性（此处应该指C++对C的增强特性），用它们作为一种语言优越的论据（这些东西语言原作者都不喜欢），这一事实本身恰恰说明你满脑子都是糊涂概念，应该好好醒悟一下了。

对于Git核心代码真正重要的，是诸如这样的事情：编写自己的对象分配代码，使内存占用尽可能小，从而能够高效地记录百万对象的标志。这实际上是为树形关系的多个对象编写本质上非常优化的分析程序，因为这里没有任何抽象。这绝对是在原始内存字节一级上的。

这些事情能够用C之外的语言编写吗？当然可以。但是那些认为C++字符串处理这样的高级特性很重要的人肯定是写不出来的。

事实上，这正是C擅长的事情。不仅指语言本身，还包括一种必需的心态（mentality）。C最大的优点之一，就是它不会使你认为程序是什么高层的东西。正是后一种心态会使你明显偏向其他语言，但实际上从Git的角度看来，所谓'高层'恰恰是错误的。”

Dmitry回帖：
我不仅看过源代码，而且还做过很多调试工作。我发现的问题大多数都与处理Windows上的路径（也就是字符串处理）有关。

他表示不再纠缠于“C与C++孰优孰劣”的讨论，而是介绍了一下自己的出发点：

“我的目的是使用Git。当有些功能无法使用时，我想能够在尽可能最短时间和花费最小的力气进行改正并贡献改正的代码。对我来说，这只是我主要工作的一种消遣而已。而Git用C编写这一事实，对这一目的毫无好处。建议使用C++是现有C代码基础的唯一出路。所以，虽然C++可能从学术上来讲并非最佳选择，但是唯一切合实际的选择。现在，我认识到自己只是一个不太活跃的贡献者，但我希望自己的声音能够被人听到。而那些承担开发和维护Git主要重任的人也应该发出自己的声音。”

此后，Torvalds没有再发言，大概是认为自己已经大获全胜。而另外一些Git贡献者继续对Dmitry进行反驳，可以看出，Torvalds的看法并不是他的私见。

Theodore Tso说：
Dmitry有一点是正确的，语言之争更多的是一种类似宗教信仰上的，所以很难有结果，也没有实际意义。这种争论因为出自高手之间，所以还是会透露出很多重要的信息。比如：

对于要求性能高的系统编程领域，C++其实未必胜过C，而且事实上，也确实有很多此类项目是选择C作为主要语言的。C的生命力目前仍然毋庸置疑。
 C++目前确实处于一种被夹攻的态势，一方面在企业级系统开发（数据密集、业务规则复杂多变）中，C++已经基本被Java和C#等淘汰出局.另一方面在系统编程和嵌入式等更接近硬件的领域，又遭到C的强烈狙击。

C++的困境，很大程度上是由于此前的图书和文献曾经一度倾向于炫技，陶醉于对语言各种细节的深入探索，有华丽化、复杂化的趋势，语言设计者们苦心设计出来各种丰富的特性和多范型的编程风格，却成了学习者和使用者的负担，加上微软等开发工具又用MFC之类的糖衣，结果造就了大批基础不牢、半桶水叮当响的C++程序员，而且因为自以为掌握了世上最难的语言，往往有目空一切的傲气。这样开发出来的代码质量，可想而知。

对C++的各种误解和不良使用习惯漫天飞。这造成C++逐渐成为人心目中望而生畏、学不好用不好的“专家语言”，越来越无法吸引新入行的程序员。老人毛病多，新人青黄不接，C++社区的确面临危机。

Primer
第三版一上来就突出C++的多种编程风格（过程式编程、基于对象编程、面向对象编程、泛型编程），并且以此作为布局谋篇的主线，很容易使初学者晕倒。
第四版，则更多地把力气花在打好扎实的基础，介绍那些实际开发中通用的、行之有效的编程技术,业界已经总结了哪些优秀的编程实践和易犯的错误等。


《The Threats to Computing Science》:
“想给那些已经接触Basic的学生教好编程规范，几乎不可能。因为这些人的脑子已经被摧残，并且没有痊愈的希望”

C语言可以让你容易用枪打到自己的脚；而C++则更不容易打到脚，但如果你硬开枪，则会轰烂你整个腿。 —— Bjarne Stroustrup
编程语言进化过程：Fortran是无类型语言；C是弱类型语言；Ada是强类型语言；C++是一种高度言过其实的语言。—— Ron Sercely
我发明了“面向对象”这个术语，但我脑子中并没有C++ —Smalltalk创造者
C++中的最新特性就是用来修正之前的新特性。— David Jameson
Java就是没有枪支、刀具和棍棒的C++ —Java 之父
世间只有两类编程语言：常被人喷的和没人用的 — Bjarne Stroustrup

java之父评价C之父：一位巨星陨落。我仍然爱着C，如此简单，强大。里奇是个天才，IT的所有都基于他的成果



STL之父Alex Stepanov (亚历山大·斯特潘诺夫)访谈

问：您认为编程的好的方法是什么？对于编程来说，一种工具是不是必需的？
Alex：我认为学习多种不同的编程语言是非常重要的。我用过 Lisp, C, C++, Java,和多种汇编。
然而，也不能仅仅局限于程序语言，它仅仅是种表达算法和数据结构的工具——并且是种有缺陷的工具。
Niklaus Wirth有句精辟见解：程序=算法+数据结构。 

问：您认为计算机语言和人类的语言有什么区别？
Alex：没有人尝试过用计算机语言写出诗歌来。计算机语言发展到能允许我们解决一些真正美好的现实生活中的东西，还有很长的路要走。

问：STL一开始被设想为今天这个样子吗？即所谓的C++标准库，或者，它是从别的什么项目来的？告诉我们一些关于STL的历史好吗？ 
答： 1976年，又要说回到苏联了，我因为吃生鱼片得了严重的食物中毒而住院，在精神恍惚中，我忽然意识到并发的加法计算能力是基于加法是结合性的,
同时，我意识到并发的减法运算是和半群结构类型有关联的，这就是最基本的重点：算法是定义于代数结构基础之上的。我又花了一些年头，
意识到必须在正规公理上加入复杂性必要条件以扩展结构的概念，接着又花了15年之久才完成全面的架构。（我直到现在都不能确定我是否成功地让我朋友小圈子之外的任何人理解了这一点）。
我相信迭代器理论是计算科学的中心就象环或Banach区间理论是数学的中心一样。每次当我找到一个算法时，我都要努力去寻求它所定义的结构基础。
我想做的就是泛化地描述算法，并乐此不疲。我可以花一个月时间去精确地描述一个众所周知的算法的泛化表示。迄今为止，在向人们解释我这种行为的重要性方面，我是异乎寻常的失败。
然而，不知何故，这种行为的结果─STL却是如此成功。关于STL还有很多故事：STL如何成为C++标准的呢？Stepanov先生有下面的表述，表述中也有他对C++之父Bjarne Stroustrup先生的精彩描述。

问：有一件事情我一直都很惊奇—C++标准委员会那么快就采纳了STL。我的意思是，这些委员会可都是以谨慎和保守而出名的。这一点，你怎么解释？
答：Bjarne Stroustrup的支持至关重要。他真的想把STL弄到标准里，他办到了。他象骡子一样固执。甚至逼着我去改STL——我从来都不会为第二个人这么做——我也是个顽固分子。
但他是我所认识的最有主见的人，他花了一些时间去理解STL是干啥的。他对STL的贡献还在于他支持“不止一种编程方法是‘合理的’”的观点——这对立于十来年认同“唯一”方法的无休止的争执和夸大
而坚持把弹性、效率、重载、类型安全结合在模板里以致于STL成为可能。我很乐意明白地声明Bjarne是我这一代人里卓越的语言设计家。

问：您是由于什么原因而发明了STL？发明的过程是什么样子的？它对您的生活和研究有什么影响吗？
Alex：STL的发明源于我多年对程序灵活性和参数化探索的结果。我对此仍不太满意：因为C++语言上的一些缺憾，使得我不能完全表达我要表达的意思。
很难形容STL对我生活和研究的影响。STL并未从本质上改变我的生活，因为我没有通过它赚到任何钱。我想向我的几个朋友展示一下正确的编程方法，而 STL正是为他们而做的。
事实上将这项工作完成带给我很多快乐，当我听说它帮助某人解决了问题时，我更加快乐。当然也有人说如果让他们设计他们可以设计出更好的东西来，也有人对STL嗤之以鼻。这些攻击也确实伤害到我。

和STL形成对照的是OO——面向对象编程。OO思想困绕着许多程序员，从未有人对OO表达过如此强烈的想法——除了Stepanov先生。
我想：作为程序员，这种东东一定是要掌握的，但是，请看Stepanov的观点： 

问： 您对面向对象是怎样理解的？它是不是一种好的可接受的编程思考方式？有没有学习OO必须的有用的工具？

Alex：我尽量避免用OO思考问题，我对他们编程的方法不感冒。我发现 OOP 在技术上是有问题的，它妄图用基于单一类型的不同接口来分解世界，
为了处理不同的实际问题，你需要不同种类的代数方法以横跨不同类型的接口族；我发现OOP在思想上是不健全的，它声称一切都是一个对象。
即使真的是这样这也没什么意思─说一切都是对象跟什么都没说一样；我发现OOP的方法论是错误的，它从类开始。就好像数学要从公理开始一样。
你不是从公理开始─你是从证明开始。直到你找到了一大堆相关证据你才能归纳出公理，以公理结束。编程上存在着同样的事实：你要从有趣的算法开始。
只有很好地理解了算法，你才有可能提出合理的接口以让其他组件共同工作。程序是描述算法和数据结构的，而不是描述继承性和多态。


觉得架构复杂，内心纠结时，判定标准：
用更简单架构能否解决同样的问题，能，说明设计复杂了，不能，说明没理解到问题的复杂性。

所以，这种继承只是用另外一种方法把这些逻辑组织了起来。
实际上，最重要的还是ui的逻辑，而不是OO，逻辑没有想明白，再牛逼的OO也解决不了实际的逻辑问题。

-----
这个lib带来的问题似乎比它解决的还要多

脚本人生
老子要喝咖啡：执行后，先等候17秒，打开一个SSH进程，连接到咖啡机，咖啡机开始工作，等待24秒，倒进杯里。脚本运行全程，是程序员从办公桌前起身，走到咖啡机所需要时间。
请假：定时任务，仅在工作日早8点后服务器依然没有活动SSH进程时，自动发一封“今天身体不适”的邮件，并从库中随机抽选一条理由附上
傻逼：扫描邮箱，发现某某邮件时，进一步扫描是否出现“求助”“出问题了”“抱歉”等关键字，如有，连上客户服务器，复位数据库。并回复邮件：“没事儿，下次小心点。”
拍马屁：定时触发，若9点之后还有活跃的SSH进程，给妻子发“今天加班”的短信，同时随机选取一条加班理由。


vi 之大道如我心之禅，
vi 之漫路即为禅修，
vi 之命令禅印于心，
未得此道者视之怪诞，
与之为伴者洞其真谛，
长修此道者巨变人生
皈依gnu

