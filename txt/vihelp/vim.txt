vim: tw=80

基于 eclipse 的 ide， 各种匹配补全功能也很完善，甚至比vi好用

atom 支持 C++

.cpp indent 有时不灵

ga 查看字符 ascii值
g8 打印utf-8 的16进制， 一个汉字3个字节

:set setting options (internal variables for switches special effects)
:let assigning a value to a variable.

字典带空格，解决不了

:h registers  # = .ect
:h expression
:h quickref
:h usr_01.txt # 02 03 04 41...
web2 (Webster's Second International) 字典23万条太多，只需6级的5000+ 单词

ctrl-x s  #拼写检查
:h spell 拼写检查

:h i_CTRL-X_CTRL-L  整行完成
文档说c-l 会检查cpt定义的buffer，可实测不检测字典
sp 然后open 那个文件，或 :badd file （Add file name to buffer list, without loading it）
明白了：cpt 的u 是：
 scan the unloaded buffers that are in the buffer list
 如果没有u，那么badd的文件，也是无法c-x c-l的！！！
还是有问题，当我写注释的时候，前面有 * 此时 c-l就不灵了，必须前面是空格或tab的时候才灵！
 
因C-X C-L 无法解决开头不是空格或Tab的情况，可以这样用于C语言注释
* a good example.
或者在空白处写，编辑后再拷贝到注释里


ctrl-x ctrl-f 插入文件名如
/etc/c-x_c-f

ctrl-x ctrl-o      调用 omnifunc 确定的函数  Omni completion
ctrl-x ctrl-u ??   调用 completefunc 确定的函数  User defined completion
这2个有啥区别？

vim74/autoload/ccomplete.vim 实现了 ccomplete#Complete

i_CTRL-R :Insert the contents of a register
ignorecase/noic 忽略大小写

.c文件用2个空格替换tab:
// vim:set ts=2 sw=2 et:  （expandtab）

针对python文件，我加了 ts=2 sw=2 et  有效，但为啥tab按键还是4个空格？

:e foo.c   #此时e是 edit
:e dir     #此时e是 explore

set tags+=~/foo/bar/tags

v characterwise-visual
V linewise-visual
CTRL-V blockwise-visual

ctrl-v I // esc   批量注释C/C++

http://www.cnblogs.com/songfy/p/5635757.html

:help complete
:help cpt (有2个complete入口，如何区分?)

vim.base Huge version
vim.tiny Small version

vim-nox // support python

gcc -fpreprocessed -dD -E foo.c 删除注释

打分号问题，没完美解决

brew install vim

3 自带netrw足够好，不用nerdtree

foldmethod   怎么用
foldlevelstart

rtp :runtimepath

ultisnips (配合vim-snippets) 默认：
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<c-b>"
let g:UltiSnipsJumpBackwardTrigger="<c-z>"
需要vim支持python（安装vim-nox），否则：
UltiSnips requires py >= 2.7 or py3

ft: filetype
./ftplugin
./after/ftplugin  两个目录行为不同，after要单独加在rtp里

completeopt
preview-window
ft-c-omni (ft:filetypes)

---
Omnicomplete(category) 一类基于 Vim's omnicompletion feature 的插件
Omnicppcompleter: C/C++ completion base ctags(放弃20171101) 需使用 Modified libstdc++ headers 版本较老
clang_complete (c++ 要想达到很好的补全效果，必须基于clang) 与omnicppcmp 插件不兼容
先安装 llvm-3.8  clang-3.8 

.clang_complete 文件
-I/usr/include/c++/4.8

clang_complete 与 auto pairs 冲突问题：
let g:AutoPairsMapCR=0   //默认是1, 作用是如：{|} 出现
{
   |
}
的效果
否则用了自动补全后，回车出现 <SNR>24_AutoPairsReturn

用了clang_complete后，.c 也用了clang，fopen memcpy等就不用原来的基于tags的了，但效果差不多
但要注意，想不全 memcpy 必须先添加 #include <string.h> 因为他是基于语义的

最好不要影响 .c 

vector自动提示
必须std:vector<char> foo;
foo. 才可以  不加名字空间，匹配不上
你麻痹，时灵时不灵

cscope - interactively examine a C program
cscope -bkq -i cscope.files
-b Build the cross-reference only
-k Kernel Mode, turns off the use of the default include dir (/usr/include)
-q Enable  fast symbol lookup via an inverted index. 
   This option causes cscope to create 2 more files (cscope.in.out and cscope.po.out )
   This allows a faster symbol search algorithm that provides
   noticeably faster lookup performance for large projects.
-i all files listed in namefile



默认对 c++ 支持不好  :h cs 可见：
Also you can download cscope 13.x and mlcscope 14.x (multi-lingual cscope
which supports C, C++, Java, lex, yacc, breakpoint listing, Ingres, and SDL)
from World-Wide Exptools Open Source packages page:

V15.8，已扫描 .cpp，但不识别 namespace 关键字包裹部分，去掉namespace 就好了
导致 调用谁 和 被谁调用 命令不能用，但 s命令即 搜索字符串可用

修改cscope(fscan.l 和 scan.l 仿照class 增加 namespace)，能识别 
namespace android {
}

但匿名namespace 和 嵌套namespace 仍然无法识别


for cpp:
1 ctags -R --c++-kinds=+p --fields=+iaS --extra=+q  //omnicpp doc
2 ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ //Modified libstdc++ headers

libc++ 用modified 1.7M，用/usr/include/c++/4.8 2.3M(必须用命令2，否则有些成员没有)

开始
omnifunc=ccomplete#Complete
omnicpp 插件生效后变为
omnifunc=omni#cpp#complete#Mai， 然后原来的 fopen c-x c-o 不好用了, set omnifunc=ccomplete#Complete 又好用了
使用 clang_complete 后 omnifunc=ClangComplete了，也支持fopen提示，用的是系统头文件，set omnifunc=ccomplete#Complete 后，又是基于tag的

omnicpp/after/ftplugin/c.vim 这个删除，不要影响 .c文件

必须用修改过的 libc++头，用android/external/libcxx 中的也不行，

如 android libcxx 的vector  synopsis部分是注释掉的，把这部分放开，其他的删除，就很完美 


:helptags {dir} 
:helptags $VIMRUNTIME/doc #生成所有 (系统目录的doc无写权限)

默认插件：
/usr/share/vim/vim74/ 

ccomplete.vim中的ccomplete#Complete(findstart, base)

g:AutoPairsCenterLine 保持编辑代码位置保持在中间位置

formatoptions 默认tcq 不能自动添加 // 和 *  
但我的vi值是 croql  (不知道谁改的)，
vimrc中并未配置  (help formatoptions 貌似与compitable有关)


:help <leader>

cindent模式

/usr/share/vim/vim74/colors  README
:colorscheme
colorscheme koehler

改不了背景色
需要修改terminal程序的背景色
atom背景色： #282c34

set background=dark/light


—- python complete —-
Pydiction
默认Tab 和 Shift+Tab 代替了C-P和C-N
由于Tab与snippet冲突，改为 C-P,和S-Tab （也不合理）
pythoncomplete.vim(vim自带，足够用)
Jedi

pythoncomplete 和jedi同样问题：
c = range(1,5)
c.reverse() # c. C-x C-o 不提示（程序不运行无法判断c的类型？）
sqlite3 函数返回变量. 不提示
import sys
sys. 提示
c = list()
c. 提示

折衷办法：
c = range(1,50)
c = list()
c. 提示后再删除c=list 行


K: .c触发man/ .py触发pydoc


Pydiction 利用 iskeyword 在c-n中识别 . 和( , 
可增加 32(空格)不行  set isk+=\ ,   已经把空格加入了，但还是不行
也无法增加 中文逗号

iskeyword 增加了. 后， 比如 dw命令，删除一个word， 遇到. 就不会终止了

dict的帮助里说，一行多词时，可以用 no-keyword 分隔，首选空格，说明空格是非关键词，那将空格变成关键词，逻辑应该对呀



:h complete

inoremap <F5> <C-R>=ListMonths()<CR>

func! ListMonths()
  call complete(col('.'), ['January', 'February', 'March',
		\ 'April', 'May', 'June', 'July', 'August', 'September',
		\ 'October', 'November', 'December'])
  return ''
endfunc
		
		
		
		
		
		
		
		
		
Cursor movement

h - move left
j - move down
k - move up
l - move right
w - jump by start of words (punctuation considered words)
W - jump by words (spaces separate words)
e - jump to end of words (punctuation considered words)
E - jump to end of words (no punctuation)
b - jump backward by words (punctuation considered words)
B - jump backward by words (no punctuation)
0 - (zero) start of line
^ - first non-blank character of line
$ - end of line
G - Go To command (prefix with number - 5G goes to line 5)
Note: Prefix a cursor movement command with a number to repeat it. For example, 4j moves down 4 lines.

Insert Mode - Inserting/Appending text

i - start insert mode at cursor
I - insert at the beginning of the line
a - append after the cursor
A - append at the end of the line
o - open (append) blank line below current line (no need to press return)
O - open blank line above current line
ea - append at end of word
Esc - exit insert mode
Editing

r - replace a single character (does not use insert mode)
J - join line below to the current one
cc - change (replace) an entire line
cw - change (replace) to the end of word
c$ - change (replace) to the end of line
s - delete character at cursor and subsitute text
S - delete line at cursor and substitute text (same as cc)
xp - transpose two letters (delete and paste, technically)
u - undo
. - repeat last command
Marking text (visual mode)

v - start visual mode, mark lines, then do command (such as y-yank)
V - start Linewise visual mode
o - move to other end of marked area
Ctrl+v - start visual block mode
O - move to Other corner of block
aw - mark a word
ab - a () block (with braces)
aB - a {} block (with brackets)
ib - inner () block
iB - inner {} block
Esc - exit visual mode
Visual commands

> - shift right
< - shift left
y - yank (copy) marked text
d - delete marked text
~ - switch case
Cut and Paste

yy - yank (copy) a line
2yy - yank 2 lines
yw - yank word
y$ - yank to end of line
p - put (paste) the clipboard after cursor
P - put (paste) before cursor
dd - delete (cut) a line
dw - delete (cut) the current word
x - delete (cut) current character
Exiting

:w - write (save) the file, but don't exit
:wq - write (save) and quit
:q - quit (fails if anything has changed)
:q! - quit and throw away changes
Search/Replace

/pattern - search for pattern
?pattern - search backward for pattern
n - repeat search in same direction
N - repeat search in opposite direction
:%s/old/new/g - replace all old with new throughout file
:%s/old/new/gc - replace all old with new throughout file with confirmations
Working with multiple files

:e filename - Edit a file in a new buffer
:bnext (or :bn) - go to next buffer
:bprev (of :bp) - go to previous buffer
:bd - delete a buffer (close a file)
:sp filename - Open a file in a new buffer and split window
ctrl+ws - Split windows
ctrl+ww - switch between windows
ctrl+wq - Quit a window
ctrl+wv - Split windows vertically
