CF卡转接 CompactFlash
A0-A11  D0-D15， 锁存器?

64pin:data 和 addr 只采集不转发，只转发几个控制信号, 但是网口写功能时，无法屏蔽左侧信号
所以还是要 100pin的

------------
mcu选型
F103VC  72MHz
F405VG  168MHz


按着右下角2个按键上电，进入开机模式，选第7项，  SRAM BACKUP 是写sd card， SRAM RESTORE 是读
最终目的是 无法 BACKUP


注意，pcmcia的封装， 1 35 2 36 3 37 4 38

pcmcia:
http://ww38.pcmcia.org/pccard.htm



原装正品FANUC发那科系统CF卡槽 A66L-2050-0025A#B CNC 卡座插口  这个都有卖的


数据备份过程大概5s，采集数据8s即可



CF:
cd1 cd2 引脚短
VCC GND 引脚长

pcmcia to cf 的对应关系
http://www.synchrotech.com/support/faq-compact_flash_memory_cards.html

http://pinouts.ru/Slots/PcCard_pinout.shtml


a0-a10 都有信号，说明不是 true ide 模式， 
2k地址空间

没操作CF卡时， a1，a2 有周期信号, 

WAIT 是 是输出信号（相对于ca卡来说）没有抓到信号，一直是高电平

重要实验结果：
开始就把wait信号强制接地，提示 Memory card mount error
当开始读取数据的时候，再接地，发现读取速度明显变慢
说明我可以通过控制wait信号 调节速度！



Memory Mode 和 I/O Mode 区别： 还没有明白真正的本质区别在哪里
引脚定义上，仅 24 37 45 46  四个引脚不同

Pin43 -INPACK  测得有信号，而 Memory Mode 不用这个信号，这更加证明是 I/O 模式
Pin34 -IORD  Memory模式不用，I/O 用 
Pin35 -IOWR  Memory模式不用，I/O 用

IORD IOWR 都测到了信号，

向卡里写数据时，IORD信号比较稀疏

-REG:
Memory Mode: High- Common Memory, Low- Register(Attribute 属性) Memory.
I/O Mode : Low during I/O Cycles when the I/O address is on the Bus(也就是说 没啥用)

发现 IORD / IOWD 为低的时候， REG 都为低（对了）


那么 I/O 模式 如何区分 Attribute Memory 呢？

----------------------------------------
现在需要集中精力 弄清除 I/O 模式的工作原理




CF卡 addr 11 + data 16  VCC/GND 4   控制信号19条 

换一个思路：
检测到有文件，就删除，单片机去删除，前提是实现FAT文件系统


----DigitalIn----

Control:
FDwfDigitalInReset
FDwfDigitalInConfigure
FDwfDigitalInStatus
FDwfDigitalInStatusSamplesLeft
FDwfDigitalInStatusSamplesValid
FDwfDigitalInStatusIndexWrite
FDwfDigitalInStatusAutoTriggered
FDwfDigitalInStatusData
FDwfDigitalInStatusRecord

Configuration:
FDwfDigitalInInternalClockInfo
FDwfDigitalInClockSourceInfo
FDwfDigitalInClockSourceSet
FDwfDigitalInClockSourceGet
FDwfDigitalInDividerInfo
FDwfDigitalInDividerSet
FDwfDigitalInDividerGet
FDwfDigitalInBitsInfo
FDwfDigitalInSampleFormatSet
FDwfDigitalInSampleFormatGet
FDwfDigitalInBufferSizeInfo
FDwfDigitalInBufferSizeSet
FDwfDigitalInBufferSizeGet
FDwfDigitalInSampleModeInfo
FDwfDigitalInSampleModeSet
FDwfDigitalInSampleModeGet
FDwfDigitalInAcquisitionModeInfo
FDwfDigitalInAcquisitionModeSet
FDwfDigitalInAcquisitionModeGet


Trigger:
FDwfDigitalInTriggerSourceInfo
FDwfDigitalInTriggerSourceSet
FDwfDigitalInTriggerSourceGet
FDwfDigitalInTriggerPositionInfo
FDwfDigitalInTriggerPositionSet
FDwfDigitalInTriggerPositionGet
FDwfDigitalInTriggerAutoTimeoutInfo
FDwfDigitalInTriggerAutoTimeoutSet
FDwfDigitalInTriggerAutoTimeoutGet


Trigger Detector:
FDwfDigitalInTriggerInfo
FDwfDigitalInTriggerSet
FDwfDigitalInTriggerGet

In:逻辑分析仪
Out: 产生时序
IO: 模拟按键，控制LED等

感觉  xx_Info 和 xx_Get 功能一样呢？


The states are defined in dwf.h DwfState type.
- Ready: Initial state. After FDwfDigitalInConfigure or any FDwfDigitalIn*Set function call goes to this state. With
FDwfDigitalInConfigure, reconfigure goes to Configure state.
- Configure: The digital in auto trigger is reset.
- Prefill: Prefills the buffer with samples need before trigger.
- Armed: It waits for trigger.
- Running: For single acquisition mode remains in this state to acquire samples after trigger set by
FDwfDigitalInTriggerPositionSet. Scan screen and shift modes remain until configure or any set function of this
instrument.
- Done: Final state.



pin 1 接高电平，循环开始的 检测状态的到  DwfStateArmed  = 1

只循环了51次 开始状态都是3(Triggered and Running) 最后一次是2 (Done)
每次读出的数据 在2000个上下，并非一次读出一组数据


Armed: It waits for trigger

需要靠
FDwfDigitalInTriggerSet(hdwf, 0, 0x0040, 0, 0);  设置触发条件， 低电平 高电平 上升沿 下降沿   每个参数16bit

读取 100000 个数据， 
FDwfDigitalInDividerSet(hdwf, 1000); // 100MHz/100 = 100KHz 程序执行 1s
FDwfDigitalInDividerSet(hdwf, 10000); // 100MHz/1000 = 10KHz 程序执行 10s

FDwfDigitalInTriggerSourceSet 参数 trigsrcDetectorDigitalIn 设置digital 输入为触发源


 
// acquisition modes:
acqmodeSingle     = 0;
acqmodeScanShift  = 1;
acqmodeScanScreen = 2;
acqmodeRecord     = 3;
acqmodeOvers      = 4;
acqmodeSingle1    = 5;



FDwfDigitalInInternalClockInfo(hdwf, &hzSys);
这个函数 返回 100000000  即 100MHz

FDwfDigitalInBufferSizeInfo(hdwf, &cSamples);
返回 4096

