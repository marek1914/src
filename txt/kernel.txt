kernel.org

v1.0  1994
v1.1  1994-1995
v2.6.0-.39   2003-2011
v3.00.1 :2011  
v3.10.1 :2013

Doug Lea malloc(dlmalloc) linux默认malloc内存分配器

/dev/block/platform/... /by-name   by-num

major.h
#define MMC_BLOCK_MAJOR	179
#define LOOP_MAJOR		7

kernel 头文件:

debian: linux-headers-generic

android:
un.h等 根据external/kernel-headers/original自动生成
bionic/libc/kernel/tools/update_all.py 生成头文件 

make headers_install  生成经过净化的内核头文件


Documentation/devices.txt  内核能识别的设备

/dev/ttyS0 ttyS1 ?
/dev/root  什么设备？ 
SD卡锁开关，开关与否，usb读卡器自动mount后显示(rw,...) (ro,...) 怎么做到的？！
有时U盘或usb sd卡边的不可写，是因为挂载点除root外不可写，如：
drwxr-xr-x  3 root root 4096 Mar 23 16:40 8b389afc-9ffa-4d80-aae9-5803d2b34a91
可以增加写权限，可为啥会这样呢？

zImage  gxxxxxxx-dirty可分辨版本
insmod 用 init_module 系统调用


/proc/config.gz

oops
bit0 == 0 :no page found, 1 means protection fault
bit1 == 0 :read, 1 means write
bit2 == 0 :kernel, 1 means user-mode
bit3 == 0 :data, 1 means instruction

kenel/sysctl.c生成/proc/sys/kernel项

linux/drivers/video/skeletonfb.c
file_operation: read/write/ioctl/mmap，在fbmem.c中实现，检测fb_ops->fb_mmap(vpmfb.c中)是否定义

[]只有空*两种状态  <>有空*M 3 中状态

Kernel hacking  打开会增加很多打印

CONFIG_PRINTK_TIME 打印时间

ifeq ($(CONFIG_AEABI),y)
CFLAGS_ABI      :=-mabi=aapcs-linux -mno-thumb-interwork
else
难道AEABI 跟thumb 是冲突的？

Kernel Features  --->
            [*] Use the ARM EABI to compile the kernel                  
            [*]   Allow old ABI binaries to run with this kernel (EXPERIMENTA)

Perface
    对内核修改的记录。

1 20100531 内核使用NandFlash
	在3slp平台上设置内核支持nand flash 的操作如下：
	(1) 修改内核配置Device Drivers->Memory Technology Device (MTD) support  
->NAND Device Support->nand flash support for NEC EMMAXXX Soc(BROI)
       （2）修改linux/include/asm-mips/emma/emma3slp.h中EMMA_NAND_BASE和EMMA_NAND_SIZE两个宏，
其中EMMA_NAND_BASE为nand flash的基地址，EMMA_NAND_SIZE为nand flash的大小。
       （3）修改linux/arch/mips/emma/nec-emma3slx/platform.c    文件，修改emma_nand_platform_data结构如下：
	struct emma_nand_platform_data emma_nand_pdata = {
 	.parts          = nand_parts,
	.nr_parts       = ARRAY_SIZE(nand_parts),
	.large_page     = 2112,//nand flash一页的大小
	.cachprg_support    = 0,
	.use_dma        = 1,
	.nand_cs        = EMMA_NAND_CS0,//nand flash使用的片选
	.dma_channel        = EMMA_DMA_MEM_CHANNEL_0,
	};
2 内核增加串口1支持
   修改arch\mips\emma\nec-emma3slx\setup.c 里面的 emma3slx_sio_setup函数 把CONFIG_KGDB注释掉就可以支持 串口1了。应该不能把CONFIG_KGDB打开，打开后会打开内核调试吧。

4 linux/include/asm-mips/emma/emma3slp.h里面定义了 内存大小 Flash大小等信息。这个文件定义了EMMA_NAND_ROM_MODE 但是从来没有用


ARCH=arm 不靠 xx_defconfig 设置死，因为 _defconfig分布在各arch目录下，如arm/configs  mips/configs
在xx_里包含目录信息不合理。搜索所有configs目录？这可以，但要保证所有config不重名，可以做到，kernel没做而已

mstar写了些脚本，可以从.config检测CONFIG_ARM=y 判断是arm，虽工作，但逻辑并不严密

CROSS_COMPILE   ?= $(CONFIG_CROSS_COMPILE)
$(info ======= $(CROSS_COMPILE) ====)
$(info ======= $(CONFIG_CROSS_COMPILE) ====)
//为什么info 不出来值？

$(CONFIG_CROSS_COMPILE:"%"=%)  //去引号
变量展开模式匹配，但实验没有成功：
aa="helloworld" //1
b=${aa:"%"=%}  //我没法模拟一个带“”的字符串，行1赋给aa，已经没有双引号了，转义也不行


2016/04/23 刚刚明白这句话的意思
SUBARCH := $(shell uname -m | sed -e s/i.86/x86/ -e s/x86_64/x86/ \
				  -e s/sun4u/sparc64/ \
				  -e s/arm.*/arm/ -e s/sa110/arm/ \
				  -e s/s390x/s390/ -e s/parisc64/parisc/ \
				  -e s/ppc.*/powerpc/ -e s/mips.*/mips/ \
				  -e s/sh[234].*/sh/ -e s/aarch64.*/arm64/ )
在pc上执行返回 x86，raspberry pi上执行返回arm


版本
VERSION =
PATCHLEVEL =
SUBLEVEL =
EXTRAVERSION = (-rc1 或用户自维护)

make help 帮助(help一个目标)

CROSS_COMPILE设置方法有4：
(makefile 里CROSS_COMPILE  ?= xx 是条件赋值)
1 直接修改Makefile中CROSS_COMPILE= (非官方，但常用)
2 命令行 make CROSS_COMPILE=xx-linux-
3 设置环境变量CROSS_COMPILE=
4 使用.config CONFIG_CROSS_COMPILE="" (在xx_defconfig中配置好，或General setup->Cross-compiler tool prefix)
注：在
ifeq ($(dot-config),1)  # Read in config
-include include/config/auto.conf
后，才可以$(info $(CONFIG_CROSS_COMPILE))

CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%) // 

Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile (eg. uboot)


ARCH(默认是编译它的机器)设置：
1 直接修改Makefile中 ARCH= （不好）
2 命令行 make ARCH=xx
3 设置环境变量ARCH=
4 没法在.config中指定！(因为这是第一级入口，也无法在xx_defconfig中指定，因为这个文件在arch/*/下，不知道进入哪个*)

make xx_defconfig :

1 生成.config，例如：
	S805(meson8): make ARCH=arm CROSS_COMPILE=arm-xxx-eabi- meson8b_defconfig (output .config)

4 执行过程
SHIPPED: (什么含义？)
	cat zconf.tab.c_shipped > zconf.tab.c
	cat zconf.lex.c_shipped > zconf.lex.c
	cat zconf.hash.c_shipped > zconf.hash.c (rename ??)
 
	conf.c -> conf.o
	zconf.tab.c -> zconf.tab.o
	conf.o + zconf.tab.o -> conf

有时：
zconf.lex.c
zconf.tab.c
zconf.hash.c
No such file or directory   mrproper可解决

make vmlinux 生成vmlinux
make modules 编译ko

modules_install (安装，raspberry pi 交叉编译用到)

all: 目标生成 vmlinux Image zImage modules


编译
  clean     Remove most generated files but keep the config and enough build support to build external modules
  mrproper  Remove all generated files + config + various backup files
  distclean mrproper + remove editor backup and patch files(distribution)

wikipedia Mr._Clean词条：
"make mrproper" is used to "clean up" in the Linux kernel build system 
all files from past builds and restore the build directory to its original clean state. 
The reason "make mrproper" is used instead of "make mrclean" is because Linus Torvalds, 
was familiar with the name "Mr. Proper" as this is the brand 
widely known in Europe." Mr.Proper是欧洲一清洁产品商标，Linux借用它表示彻底清除


scripts/kconfig :
将下面的c编译为 conf 程序

linux-3.10.33.tar.xz  xz比7z还要小。 xz -d 要解压的文件

--build-id
Request creation of ".note.gnu.build-id" ELF note section. The contents of the note are unique bits identifying this linked file
prefix-gcc -c -o  logger.o logger.c  奇怪，编译ko的时候并没有加 -fPIC 难道ko 不是位置无关代码吗？

--Kconfig--
理解arch/arm/Kconfig :

config x
depends on xx  体现在menuconfig上：只有选择了xx，才会出现x config

menu "System Type" 这之前没有理解 (vi 为何认menu，关键词？)
之后：

config MMU
	bool "MMU-based Paged Memory Management Support" #bool型，显示名称"xx"
	default y  #默认值 y
	help  #帮助信息
	  xxx.
表现为一个前面有[]的独立选择框

choice  #一组选择
	prompt "ARM system type" #选择项的名字 
	default PLAT_MESON  #默认值，没有就默认第一个选项
config ARCH_REALVIEW
	bool "ARM Ltd. RealView family" #bool型，显示名称"xx"
	select ARM_AMBA #设置变量xx
	...
	select GPIO_PL061 if GPIOLIB
	help
	  xxx.

config PLAT_MESON
	bool "Amlogic Meson"
	select GENERIC_ALLOCATOR (select表示选择了这个config，就设置GENERIC_ALLOCATOR为y)
	...
	select CPU_V7
	help
	  xxx.

endchoice

source "arch/arm/plat-meson/Kconfig"
source "arch/arm/mach-at91/Kconfig"

arch/arm  mach-xx表示一个平台 plat-xx表示一个系列，其中Kconfig重复上面过程：
choice
config
endchoice
source "arch/arm/mach-meson1/Kconfig"
source "arch/arm/mach-meson2/Kconfig"
注意：
mach-meson1，mach-meson2 并不在plat-xx目录下

choice 里面的config不能有defaults
defaults for choice values not supported

mx，mrproper后，make menuconfig 直接定位到meson，因为arch/arm/Kconfig 有choice
	prompt "ARM system type"
	default PLAT_MESON


//路径没有仅warning 未错误退出  isource 没变色，不是关键词？
//而source 若没有则提示can't open file，make返回错误
isource "../hardware/.../rtl8xx/Kconfig"  (应该是amlogic自己加的)

由打印提示后有没有执行exit(1);  (scripts/kconfig里面的代码)

mx:
用arm-linux-gnueabihf-gcc 4.7.3出错：
inlining failed in call to always_inline ‘meson_set_cpu_ctrl_reg’: function body not available
meson_set_cpu_ctrl_reg 这个函数是inline的，不能外部引用，这是gcc4.7的bug，见https://gcc.gnu.org/bugzilla/show_bug.cgi?id=33763
见 http://blog.csdn.net/laohuang1122/article/details/8137981
必须用指定的codesourcery

s805目录的编译kernel的4.7同样的错误，用s805/4.6编译器ok(存放2个版本编译器的原因^^)
用s805/android4.6也能编译kernel成功（nxp时代就测试过），有什么区别呢？为什么专门提供了编译kernel的gcc呢？

如何就编译了mach-meson6目录：
arch/arm/Makefile :

machine-$(CONFIG_ARCH_MESON6)		:= meson6 # CONFIG_ARCH_MESON6被配置为y
machdirs := $(patsubst %,arch/arm/mach-%/,$(machine-y))

mx在根makefile中自己定义了一个customer，把相关xx_defconfig 等文件另外放一个目录。
s805也有customer的影子，但没用。不好！恢复本来面目。

module 编译

.dtb编译

==Makefile.clean===

//$(wildcard ...) 可用于判断文件是否存在
include $(if $(wildcard $(kbuild-dir)/Kbuild), $(kbuild-dir)/Kbuild, $(kbuild-dir)/Makefile)

整个源码中 Kbuild 文件不多，更普遍的是Makefile文件

编译完后，删除一个目录，make clean提示：
scripts/Makefile.clean:18: .../Makefile: No such file or directory
./drivers/amlogic/input/Makefile 里  obj-y   += sensor/ 了  （这里应该可配置）

==Makefile.build==

# The filename Kbuild has precedence over Makefile  //Kbuild优先于Makefile
kbuild-dir := $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))
include $(if $(wildcard $(kbuild-dir)/Kbuild), $(kbuild-dir)/Kbuild, $(kbuild-dir)/Makefile)

====

根Makefile include $(srctree)/arch/$(SRCARCH)/Makefile

arch/arm/Makefile:
boot := arch/arm/boot


Kbuild.include:
# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.build obj=
# Usage:
# $(Q)$(MAKE) $(build)=dir
build := -f $(if $(KBUILD_SRC),$(srctree)/)scripts/Makefile.build obj

zImage Image uImage: vmlinux  #3个目标都从这里进入
	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/$@

如make uImage，展开：
make -f scripts/Makefile.build obj=arch/arm/boot MACHINE=arch/arm/mach-at91/ arch/arm/boot/uImage

这里出现 obj=$(boot) 效果，$(boot)/$@ 在Makefile.build中用 $(1)引用

arch/arm/boot/Makefile：
#bin化arch/arm/boot/compressed/vmlinux得到zImage
$(obj)/zImage:　$(obj)/compressed/vmlinux
	$(call if_changed,objcopy)
arch/arm/boot/compressed/Makefile：
$(obj)/vmlinux: $(obj)/vmlinux.lds $(obj)/$(HEAD) $(obj)/piggy.o $(addprefix $(obj)/, $(OBJS))
	$(call if_changed,ld)
$(obj)/piggy.gz: $(obj)/../Image
	$(call if_changed,gzip)
$(obj)/piggy.o:　$(obj)/piggy.gz


zImage Compressed kernel image (arch/$(ARCH)/boot/zImage)
Image  Uncompressed kernel image (arch/$(ARCH)/boot/Image)
uImage U-Boot wrapped zImage (zImage+64byte u-boot)
bzImage ??

zImage生成：
1 根目录生成elf文件vmlinux
2 arm-xx-objcopy -O binary -R .comment -S  vmlinux arch/arm/boot/Image
3 gzip -n -f -9 arch/arm/boot/Image > arch/arm/boot/compressed/piggy.gzip
4 arch/arm/boot/compressed/piggy.gzip.S 将piggy.gzip作为数组包含进程序:
	input_data:
		.incbin	"arch/arm/boot/compressed/piggy.gzip"
	input_data_end:
5 生成新的vmlinux:
	arm-xx-ld head.o piggy.gzip.o misc.o ... decompress.o -o arch/arm/boot/compressed/vmlinux
	piggy.gzip.o是Image压缩后的数据，其他.o是解码程序(解压代码来自gzip)
6 arm-xx-objcopy -O binary -R .comment -S  arch/arm/boot/compressed/vmlinux arch/arm/boot/zImage (此文件不能用gzip解压)

vmlinux elf转bin，可用uboot go命令启动
nxp  :arm-xx-objcopy -O binary -R .note.gnu.build-id -S vmlinux vmlinux.bin (同Image，不标准)
Hisi :arm-xx-objcopy -O binary -R .note.gnu.build-id -S vmlinux arch/arm/boot/Image

uImage：
在zImage(kernel默认)或Image或lzo/gzip等压缩的Image前追加64字节头变成uImage，用zImage或Image要指定无压缩，lzo等要指定相应压缩方式
A20:
./arch/arm/boot/.uImage.cmd: 
./scripts/mkuboot.sh -A arm -O linux -T kernel -C none -a x -e xx -n 'x' -d arch/arm/boot/zImage arch/arm/boot/uImage

Hisi:
Image Name:   Linux-2.6.35.7_hi3716c //这是生成时打印，不同于uboot.txt中运行时打印
Created:      Sat Nov 26 19:18:51 2011
Image Type:   ARM Linux Kernel Image (uncompressed) //uncompressed指的是uboot没有对他压缩，与kernel本身压缩(zImage)无关
Data Size:    1947664 Bytes = 1902.02 kB = 1.86 MB
Load Address: 80800000
Entry Point:  80800000

xipImage      - XIP kernel image, if configured (arch/$(ARCH)/boot/xipImage)'
install       - Install uncompressed kernel'
zinstall      - Install compressed kernel'

arch/arm/Makefile 和 arch/arm/boot/Makefile (谁来包含这个呢？)

根Makefile include $(srctree)/arch/$(SRCARCH)/Makefile

arch/arm/Makefile有：

boot := arch/arm/boot
./scripts/Kbuild.include:
build := -f $(if $(KBUILD_SRC),$(srctree)/)scripts/Makefile.build obj

arch/arm/boot/bootp 生成bootpImage

注意：arch/arm/boot/compressed/vmlinux 是位置无关的：
　　EXTRA_CFLAGS　:= -fpic

arch/arm/boot/Makefile：
$(obj)/uImage:  看到了，有2个uImage目标，但是1个是纯uImage 1个是$(obj)/uImage 

Makefile.build include Makefile.lib(这2个文件逻辑混乱)
$(build)=$(boot) 这里调用了 -f Makefile.build

Makefile.lib :
lib-y := $(filter-out $(obj-y), $(sort $(lib-y) $(lib-m)))  
如果obj-y包含的lib-y也包含，则从lib-y中剔除


Makefile.build:
__build:  此时还是一个空 目标 没有依赖 没有命令
真正的目标在下面 ， 在很下面的位置有一条
__build:
中的__built 很奇怪  
有两处 ，第二处 有一个 @:  不知道什么意思。
__built:
但是什么也没有写 
在下面有定义了
__built:
真正去执行那一个target   但是文件开头的__built不写是不行的。
可见，执行的是第85行的那个 __build:
而那一行  KBUILD_BUILTIN 为真  则需要先生成  built-in.o  而生成built-in.o

Makefile.build:

ifneq ($(KBUILD_SRC),)
# Create output directory if not already present
_dummy := $(shell [ -d $(obj) ] || mkdir -p $(obj))

# Create directories for object files if directory does not exist
# Needed when obj-y := dir/file.o syntax is used 【实际上并不支持 】
_dummy := $(foreach d,$(obj-dirs), $(shell [ -d $(d) ] || mkdir -p $(d)))
 endif 

例如：
obj-y += dir/xx1.o
obj-y += xx2.o
会直接略过xx1.o去编译xx2.o  的。 怎么掠过去的呢？

obj-y +=dir/xxx.o的时候 确实是创建了 obj编译目录下面的 响应dir目录  但是怎么不去编译

Makefile.build  .c到.o使用显示规则而不是潜规则：
 %.o: %.c
    $(call cmd,force_checksrc)
根Makefile:
KBUILD_BUILTIN := 1

为什么lib-y 就编译子目录  obj-y 就不编译子目录呢？
lib-y 就支持 dir/xxx.o  obj-y就不支持 dir/xxx.o

%.o: %.c这种隐式规则 是不怕文件路径的   有路径也没有问题。 经过了验证的。

调用这个函数 call echo-cmd 的地方在
makefile.build:
	$(call echo-cmd,checksrc) $(cmd_checksrc)
这里的echo 中显示的内容 就直接影响了  CC LD 等

escsq = $(subst $(squote),'\$(squote)',$(1)) 
将单引号‘替换成\'转义字符

# Descending 用来进入子目录
$(subdir-ym): //Makefile.lib里赋值
	$(Q)$(MAKE) $(build)=$@  这里面与 根 Makefile中的写法一样
-ym代表-y和-m 即选择了y和m的模块

Kbuild.include:
# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.build obj=
# Usage:
# $(Q)$(MAKE) $(build)=dir
build := -f $(if $(KBUILD_SRC),$(srctree)/)scripts/Makefile.build obj

而Makefile.build 上来后就是  src := &(obj)  此时的obj变量 就是此时赋值的

filter函数里面必须有%  但是不能出现连个%  比如 过滤xx  用%i% 过滤不出来。
根部的Makefile 只需要把 跟目录的几个写上就行了  所以可以做到不修改跟 Makefile 

core-y  libs-y ？ lib-y 和 obj-y 有何区别

考虑 Makefile 的lib-y 和 obj-y
built-in.o 是什么东西？？？

Makefile 和 script/Makefile.build  里面都包含 Kbuild.include  


Makefile.build
cmd_link_multi-y = $(LD) $(ld_flags) -r -o $@ $(link_multi_deps) 

从这里看 lib-target  和 obj-target 还是一样的？为什么obj能递归进入  lib确不能。

config CMDLINE

里面还显示
Defined at arch/mips/Kconfig.debug:21
指示在哪个文件哪一行定义的这个宏。

./arch/mips/kernel/setup.c 这个文件里面处理这个参数行。

Starting application at 0x863b2000 ... //u-boot打印。


内核从哪里开始运行要看lds
zImage 2次链接：生成vmlinux(arch/arm/boot/vmlinux.lds（由arch/arm/kernel /vmlinux.lds.S生成）)；
生成arch/arm/boot/compressed/vmlinux (arch/arm /boot/compressed/vmlinux.lds（由arch/arm/boot/compressed /vmlinux.lds.in生成）) 
zImage入口点_start由arch/arm/boot/compressed/vmlinux.lds决定。


merge_config.sh 用于合并配置文件（原生kernel提供，s805用到了）：
merge_config.sh <device>_defconfig android-base.cfg android-recommended.cfg

=== end make ===

== image ==

file recovery.img 
recovery.img: u-boot legacy uImage, MStar-linux(recovery), Linux/ARM, Multi-File Image (Not compressed), 34259256 bytes, Tue Sep 29 15:08:34 2015, Load Address: 0x20208000, Entry Point: 0x20208000, Header CRC: 0xBEBA903B, Data CRC: 0x97678412

image 原理：

问题1 
raspberry pi image写入后，容量可扩展到全盘 （如何实现的？）

问题2
image文件，分区size要大于img文件，原理。。。。

sd卡/u盘启动板子，用ubuntu Disks工具格式化，提示promission denied,
sudo mkfs -t ext4
或
sudo mkfs.ext4
就可以

-----
mstar tvservice.img, 直接可以在ubuntu中打开！（Open With Disk Image Mounter）

image制作工具：

//来自mtd-utils
mkfs.jffs2
mkfs.ubifs


ubuntu系统也有一套，mkfs (tab)显示：
mkfs          mkfs.cramfs   mkfs.ext3     mkfs.ext4dev  mkfs.minix    mkfs.ntfs     
mkfs.bfs      mkfs.ext2     mkfs.ext4     mkfs.fat      mkfs.msdos    mkfs.vfat

问题，3个工具有区别吗？
mkfs -t ext4
mkfs.ext4

/drivers/staging/android/lowmemorykiller.c  用到了global_page_state(NR_FILE_PAGES)
debugfs



有git时 2.6.37-2.8-g1069bbf-dirty //修改未 commit
./scripts/setlocalversion 有解释


.ko不能strip: module has no symbols(stripped?)

–build-id选项(根Makefile中)用于在生成的elf中加入一个id
core dump/debuginfo时可以定位这个模块是哪次build出来的，可定位模块版本
http://fedoraproject.org/wiki/Releases/FeatureBuildId

early stage 状态

linux提供了 /etc/shadow文件，密码放在这个文件里面，只有root可读，保证安全
/etc/passwd文件的每个条目有7个域，分别是名字：密码：用户id：组id：用户信息：主目录：shell如：
ynguo:x:509:510::/home/ynguo:/bin/bash

maps 里显示的  (deleted)  在内核里搜 "" (deleted)""  在dcache文件里
Linux用“权能（capability）”表示一进程所具有的权力。一种权能仅仅是一个标志，它表明是否允许进程执行一个特
定的操作或一组特定的操作。这个模型不同于传统的“超级用户对普通用户”模型，在后一种模型中，一个进程要么能做
任何事情，要么什么也不能做，这取决于它的effective UID

super uid
super gid 文件属性里的s标志

fb显示kernel控制台
gwb调通recovery fb显示console内容
recovery使用自己的字库
drivers/video/console 也有字库用于fb显示console

console (5,1)  drivers/char/tty_io.c

major.h: 
#define TTYAUX_MAJOR  5

device_create(tty_class, NULL, MKDEV(TTYAUX_MAJOR, 1), NULL,"console");

/dev/tty       5 0
/dev/console   5 1
/dev/ptmx      5 2
/dev/ttyprintk 5 3


/dev/tty0     4 0
/dev/tty1     4 1

/dev/ttyS0    4 64
/dev/ttyS1    4 65

2
1 arch/arm/kernel/traps.c 中
int __die(): "Process %.*s (pid: %d, stack limit = 0x%p)\n"

看打印：
Process Binder Thread # (pid: 1043, stack limit = 0xd9a942f8 )  //这里看出 2 page的内核栈开始地址 0xd9a94000  thread结构体的大小为 0x2f8 
stack limit 意思是 栈不能超过这个地址。
下面：
Stack: (0xd9a95df4 to 0xd9a96000)   这里的开始地址是由上面的 sp: d9a95df4 决定的。
5de0:.....
.....

	if (in_interrupt())
		panic("Fatal exception in interrupt");
	if (panic_on_oops)    // oops错误的时候，打印 Kernel panic - not syncing: Fatal exception
		panic("Fatal exception");

panic(): "Kernel panic - not syncing: %s\n"


Kernel hacking 里ARM_UNWIND  配置，Enable stack unwinding support  （unwind 松开，解开）
显示函数调用关系，需要栈帧(CONFIG_FRAME_POINTER)

mode specifies the permissions to use in case a new file is created.  
这里的权限就指 用户，组，其他的读写可执行等
只有指定 O_CREAT 参数的时候，mode才有意义，否则直接赋值为0即可，即使不赋0，内部也会把他清零。

堆栈回溯
typedef struct frame_pointer_t
{
    struct frame_pointer_t *pre;
    unsigned int    ret_address;
}frame_pointer;

frame_pointer* fp;
void stack_trace(int n)
{
    __asm("sw  $30, fp"); 
    while (n--) {
       dl_printf("\r\n frame is 0x%x, ret address is 0x%x \r\n", (unsigned int)fp->pre, fp->ret_address);
       fp = fp->pre;
    }
}

这里要注册中断号码。基本是按照一级中断寄存器定义的。

重要信息
#elif defined(CONFIG_BRCM_UPPER_768MB)
/* uncached kseg1 does not exist in this configuration */

BMIPS应该是专指博通MIPS


打印看出 struct page 是32字节  mem_map 数组建立在0x81000000 位置，即16M位置

开机调用的是 init_bootmem_node  没有调用 init_bootmem

从 arch/mips/kernel/setup.c 中的 bootmem_init 调用过去

可见，这种内存的处理需要针对特定平台去做。

early_param("bmem", bmem_setup); 命令行遇见bmem= 就调用bmem_setup函数。所以命令行写几个bmem= 就会调用几次。
bmem_setup(char *str)
{
}
这个函数的参数都是char *，会被赋成 bmem=后面的字符串。


mem_map 数组是如何创建的
/mm/page_alloc.c
用map = alloc_bootmem_node(pgdat, size); 函数分配， size= size =  (end - start) * sizeof(struct page);
其中：start=0; end=0x50000; size=0x50000*0x20/*32bytes*/ = 0xa00000 = 10Mbyte
256M内存需要2M mem_map空间，现在5*256M 需要10M内存mem_map空间。

只考虑最简单的FLAT模型，没有不连续

所以，mem_map 空间10M（0xa00000）   membitmap 空间 40K(0xa000) 都是0x50000项，前者32字节一项，后者1bit一项 


bootmem::init_bootmem_core nid=0 start=0 map=8b5 end=50000 mapsize=a000
bmem: adding 55 MB LINUX region at 8 MB (0x0374b000@0x008b5000)

init_bootmem_core 函数初始化位图

0x8b5个页应该是kernel占用的空间了

iomem 里面的内容是怎么出来的

但是cat /proc/iomem
  00001000-0063cf9f : Kernel code
  0063cfa0-00759edf : Kernel data
kernel没有占到那么大啊！多出了1M多。

Freeing unused kernel memory: 220k freed  

Memory: 420276k/1048576k available (6383k kernel code, 628300k reserved, 1139k data, 220k init, 0k highmem)
1048576 是1024M   420276k + init释放的220k = 420496 = free 看到的total mem

1048576k-420276 = 628300k（reserved）= 402M+192M +20044k
20044k = 0x8b5000(code+data+init+bss 8916k) + 40k(bitmap) + (10240k)mem_map  + 212个页（800多k，后面其他alloc_bootmem_core调用）

192M@64M  402M@512M 这种配置

虽然没有在iomem中显示，但通过
extern char __init_begin[], __init_end[];
extern char __bss_start[], __bss_stop[]; 
用这些符号查System.map 发现init空间释放的就是220k 剩下即bss空间

分配mem_map 的时候调用alloc_bootmem_core函数
bootmem::alloc_bootmem_core nid=0 size=a00000 [2560 pages] align=40 goal=1000000 limit=0
align:要求对齐的字节数
goal:最佳分配起始地址 0x1000000（其实此时空闲地址从0x808b5000+bitmap空间0xa000 为0x808BF000 不到0x81000000）

#define alloc_bootmem_node(pgdat, x)  __alloc_bootmem_node(pgdat, x, SMP_CACHE_BYTES, __pa(MAX_DMA_ADDRESS))
MAX_DMA_ADDRESS 就是goal参数
而此平台

/*
 * The maximum address in KSEG0 that we can perform a DMA transfer to on this
 * platform.  This describes only the PC style part of the DMA logic like on
 * Deskstations or Acer PICA but not the much more versatile DMA logic used
 * for the local devices on Acer PICA or Magnums.
 */
#define MAX_DMA_ADDRESS		(PAGE_OFFSET + 0x01000000)

而实际上，这个是针对pc机器的，对于我先在的平台，没有任何限制，我可以把他改成 0  从而让mem_map分配的地址直接在bitmap/*0x808bf000*/的后面
PC机器上一般：
ZONE_DMA: 0-16M
ZONE_NORMAL:16M-896M
ZONE_HIGHMEM:896M-xx   在嵌入式上没有这种限制

这样修改后：
bootmem::alloc_bootmem_core nid=0 size=a00000 [2560 pages] align=40 goal=0（注意这里） limit=0
打印返回的地址真的就是：808bf000 了

bootmem::alloc_bootmem_core nid=0 size=a00000 [2560 pages] align=40 goal=0 limit=0
bootmem::__reserve nid=0 start=8bf end=12bf flags=1 （在bitmap里面把这些位置1 ：flag=1 就被reserve了）
 0 0 50000 a00000 808bf000

现在 code，text，init，bss，bitmap，mem_map就连到一起了。

#define __pfn_to_page(pfn)	(mem_map + ((pfn)))
#define __page_to_pfn(page)	((unsigned long)((page) - mem_map)  /*这个挺好玩，结构体做减法得到间隔的个数 结构体加法没有意义*/

下面再考察一下mem_map是如何初始化的，应该由bitmap的情况来初始化mem_map吧
系统不会直接操作mem_map数组了，都是通过 pfn_to_page 操作的

不考虑高端内存
mem_init函数中：
在此之前，totalram_pages是0
totalram_pages += free_all_bootmem();  // 返回 105070 = 420280k
totalram_pages -= setup_zero_pages();	/* Setup zeroed pages.  */
设置1个0页，剩余 105069 = 420276k，这个0页不知道做什么用的

free_all_bootmem - release free pages to the buddy allocator
Returns the number of pages actually released.

bootmem::free_all_bootmem_core nid=0 start=0 end=50000 aligned=1
bootmem::free_all_bootmem_core nid=0 released=19a6e
从0-50000页范围检测，释放出19a6e个页

注意free_all_bootmem_core函数最后将bitmap占用的40k也释放了，终于懂了！
此函数前半部分去查位映射区域的0位，但为运算方便，做了转换，变成检测1位:
vec = ~map[idx / BITS_PER_LONG];
if (vec & 1) {
  page = pfn_to_page(start + off);
  __free_pages_bootmem(page, 0);
  count++;
}

bmem_get_page （纯粹是博通添加的函数，不是标准linux的机制）

get_user_pages函数的用法（这个是linux标准的）
发现get_user_pages()接口真是个好东东，它能获取用户区进程使用内存的某个页(struct page)，有什么用呢？
get_user_pages的作用是得到用户的页面。

cp  /dev/mem /data/mem.bin 读到256M以上时内核崩溃，说明读到寄存器了，这个方法拿到了bitmap数据
去0x8bf000偏移位置，找到了page结构体，32字节一组

可是 free_all_bootmem_core 没有处理reserved区域啊？最后在winhex里面看的时候，winhex区域怎么也是初始化了的呢？

free_all_bootmem()函数
  这个函数用来在引导时释放页面，并清除bootmem分配器。
   函数原型为：
       void free_all_bootmem (void);
       void free_all_bootmem_core(pg_data_t *pgdat);

搜索bootmem位图，找到空闲页，并把mem_map中对应的项标记为空闲。set_page_count()函数把page结构的count域置1，
而__free_page()真正的释放页面，并修改伙伴（buddy）系统的位图。 （伙伴系统还有位图？）

关于宏PageReserved
在./include/linux/page-flags.h 定义
Page
  
TESTPAGEFLAG(Locked, locked)  
/* 上面的宏展开后得到如下代码： */  
int PageLocked(struct page *page)   
{   
    return test_bit(PG_locked, &page->flags);   
} 

free_all_bootmem_core函数注释掉：
#if 0
	page = virt_to_page(bdata->node_bootmem_map);
	pages = bdata->node_low_pfn - bdata->node_min_pfn;
	pages = bootmem_bootmap_pages(pages);
	count += pages;
	while (pages--)
		__free_pages_bootmem(page++, 0);
#endif
即不要释放这个映射区域，否则就被别的数据冲掉了。
从这个映射区域可以看出：
0x8b5000 - 0x8b5270(大概)全是 0xFF 近20M code data init bss bitmap mem_map
0x8b5270 - 0x8e5800 到64M 全是 0x00 表示空闲
然后到914M 是ff （512+402） 然后到1024+256 又是0x00

void free_init_pages(const char *what, unsigned long begin, unsigned long end)

没有用到bitmap 映射表，所以映射表中没有体现出init部分 是0

FLAT模型并不代表物理内存真的连续，他只是一个模型。

cat /proc/meminfo  为方便，删除显示为0k的区域
fs/proc/meminfo.c


一般情况下 __pfn_to_bus 就是  __virt_to_bus
#define PHYS_OFFSET UL(0x00000000)

CONFIG_PAGE_OFFSET  更改2g/2g  3g/1g 后.config文件中的东西

那么PHYS_OFFSET  物理偏移又是什么呢？
apollo定义的PHYS_OFFSET 为0

MAX_NUMNODES 都是1 NUMA 在多处理器上才有用

Memory: 128Mb 128Mb = 256Mb total
Memory: 130552kb ....
init.c/mem_init()

	printk("Memory:");
	num_physpages = 0;
	for (i = 0; i < meminfo.nr_banks; i++) {
		num_physpages += bank_pfn_size(&meminfo.bank[i]);
		printk(" %ldMB", bank_phys_size(&meminfo.bank[i]) >> 20);
	}
	printk(" = %luMB total\n", num_physpages >> (20 - PAGE_SHIFT));

totalram_pages 就是在 mem_init函数中
totalram_pages += free_all_bootmem_node(pgdat); 这里赋值的

	/* this will put all unused low memory onto the freelists */
	for_each_online_node(node) {   //这个循环只执行一次
		pg_data_t *pgdat = NODE_DATA(node);

		free_unused_memmap_node(node, &meminfo);

		if (pgdat->node_spanned_pages != 0)
			totalram_pages += free_all_bootmem_node(pgdat);
	}

kernel.org arm.linux.org.uk linux-arm.org 和邮件列表之间的关系

1 内核源码树中的REPORTING-BUGS向导，但是要使用linux-arm-kernel邮件列表来报告问题，
  而非使用linux-kernel邮件列表·  Mailing Lists
  lists.arm.linux.org.uk Mailing Lists administrated by Russell King
   arm.linux.org.uk 的邮件列表由Russell King维护
3 http://www.linux-arm.org/git - GIT trees for the Linux kernel and U-Boot
  maintained by ARM Ltd. 来自Wiki，原来这个网站由ARM公司来维护。
  http://www.arm.com/linux, and http://www.arm.com/products/os/linux_download.html
  the latest kernel and filesystem to run on the ARM Ltd platforms。提供的下载
  也发布在linux-arm.org/git上 【http://www.linux-mips.org/也是MIPS公司维护】

4 From: Catalin Marinas  <catalin.marinas@arm.com> 
  http://www.linux-arm.org/git 中
  linux-2.6-stable.git ARM Ltd stable kernel Catalin Marinas
  armdroid.git Android  Vasileios Laganakos（ARM公司的人）
  linux-2.6.stable.git 和 linux-2.6.git有什么区别

5 http://git-scm.com  Every Git clone is a full-fledged repository
  
  Cloning and Creating a Patch  产生一个patch
   $ git clone git://github.com/git/hello-world.git
   $ cd hello-world
   $ (edit files)
   $ git add (files)
   $ git commit -m 'Explain what I changed'
   $ git format-patch origin/master

6 我在http://git.kernel.org中可以看到 
  1) linux/kernel/git/stable/linux-2.6-stable.git
  2) linux/kernel/git/stable/linux-2.6.11.y.git
     ...
  3) linux/kernel/git/stable/linux-2.6.35.y.git
   1里面维护了2-3所有的单独仓库：
   description	Unified stable trees mirror
   owner	Linux Kernel Distribution System
   那么这个仓库就是所有2.6.x.y仓库的集合，注意，是包括rc版本和修正版本的，各个离散的git仓库
   在这里以分支的形式存在。

7 现在就清楚了：http://www.linux-arm.org/git网站 维护的linux-2.6-stable.git
  就对应着git.kernel.org里面的 linux-2.6-stable.git了

8 明白nxp的kernel改动的来源：首先是针对驱动的改变如DMA，STAT，mach-apollo
  Ethernet等，其次是针对Cortex-A9的改动，收集了邮件列表里面的信息。
  而 http://android.git.kernel.org/ kernel/common里面的代码都是以http://git.kernel.org
  中的代码为基础的，所以可能没有包含最新的针对ARM处理器的修改，比如NEON、VFPv3、Thumb2、L2 cache等
  现在考虑升级内核可能会带来风险，因为Nxp的东西对2.6.28.10的依赖性太强了。
  以cache-l2x0.c为例：这个文件很有代表性:
  分别比较 N2.6.28.10  S2.6.33  linux-arm2.6.33(打过arm补丁的2.6.33)
  N对S2.6.28.10的修改，有的已经收到 S2.6.33 有的收到 linux-arm.org 对2.6.33 打的补丁中
 
2.6.28.10 在2.6.29 后发布
2.6.28.10：2009.05.02
2.6.29：2009.03.23
2.6.28：2008.12.24

3 关于arm/include/asm/cache.h 
  A2.6.29 对 S2.6.29 
  1 #define L1_CACHE_SHIFT 5 改成  #define L1_CACHE_SHIFT CONFIG_ARM_L1_CACHE_SHIFT
    (这个是android加的) 
    但是CONFIG_ARM_L1_CACHE_SHIFT还是配置成了5 相当于没有改
    同时,android对应的在 arch/arm/mm/Kconfig 增加
    config ARM_L1_CACHE_SHIFT
	int
	default 6 if ARCH_OMAP3  （注意 ompa3 的时候 是6 但是embinux 的kernel还是5啊）
	default 5

  2 对于下面这段 
   /* With EABI on ARMv5 and above we must have 64-bit aligned slab pointers. */
   #if defined(CONFIG_AEABI) && (__LINUX_ARM_ARCH__ >= 5)
   #define ARCH_SLAB_MINALIGN 8
   #endif
   S2.6.29 在 arch/arm/include/asm/page.h中 A2.6.29 改移到了arm/include/asm/cache.h
   O2.6.29 没有改这里，仍然在page.h中。 android移动这个不是吃饱撑的！
 
  3 下面这段 是A2.6.29加的 S2.6.29 没有
/*
 * Memory returned by kmalloc() may be used for DMA, so we must make
 * sure that all such allocations are cache aligned. Otherwise,
 * unrelated code may cause parts of the buffer to be read into the
 * cache before the transfer is done, causing old data to be seen by
 * the CPU.
 */
#define ARCH_KMALLOC_MINALIGN	L1_CACHE_BYTES （cache line 的长度）

  在mm/slab.c (slab 片)有注释：

4 L1_CACHE_SHIFT 和 L1_CACHE_BYTES 是什么意思？
  CONFIG_ARM_L1_CACHE_SHIFT=5  (这表示cache line 为32字节)
  【知识】关于cache line
   The basic unit of storage in a cache. It is always a power of two words in size(
    usually fore or eight words),and is required to be aligned to a suitable memory boundary

5 关于N2.6.28.10 增加 CONFIG_CPU_NO_CACHE_BCAST 定义
  这个跟smp有关系  所以N2.6.28.10 对比 S2.6.28.10 在arch/arm/kernel/smp.c中增加了几处
  CONFIG_CPU_NO_CACHE_BCAST的处理
  但是NXP平台并没有打开这个宏 这个宏在nxp平台的逻辑是：
  config CPU_NO_CACHE_BCAST
        bool
        depends on SMP
        default y if CPU_V6
  也就是说，跟armv6 的smp有关系，跟armv7无关！
  arm-linux 官方的2.6.33 都没有定义这个宏！
  从网上找到一个git的commit注释：
  Broadcast the DMA cache operations on ARMv6 SMP hardware
  nxp这段程序也是从arm-linux网站合里的应该，我猜测！


6 关于 CONFIG_CPU_CACHE_VIPT
  nxp平台 CONFIG_CPU_CACHE_VIPT=y  OMAP3530 也是y
  跟这个相关的在cacheflush.h 中有两个函数 flush_cache_vmap和flush_cache_vunmap
  N2.6.28.10相对S2.6.28.10 关于这2个函数的修改，其实S2.6.29已经改了，一模一样的
  [知识]cache的 VIVT VIPT PIPT

7 关于elf.h里面增加的几个定义
  #define R_ARM_V4BX	40
  #define R_ARM_PREL31 42
  #define R_ARM_MOVW_ABS_NC	43
  #define R_ARM_MOVT_ABS 44 
	1) A2.6.29 在 S2.6.29基础上增加了这几个定义
	2) N2.6.18.10在S2.6.28.10基础上也增加了这个定义
	3) 但是O2.6.29并没有增加这几行
	4) ARM-linux官方 2.6.33 也有这个定义
  这些定义只在arch/arm/kernel/module.c中的 apply_relocate函数中使用
  而这个module.c 只有menuconfig时候的  Enable loadable module support选上之后
  设置了CONFIG_MODULES 才会被编译。而这一组宏，跟模块（共享库）的重定位（relocation）有关
  这一组宏叫做重定位码 relocation code
  The code which is stored in the ELF32_R_TYPE component of the r_info field.
  R_ARM_ABS32: 使用32bit绝对地址重定位引用
  R_ARM_PC24 ：使用24bit的PC相对地址重定位引用
  R_ARM_V4BX： v4bx 代表armv4t BX指令
[知识]MOV MOVT 配合 可以把一个32位数放到一个寄存器中，此功能MIPS早就有

8 ptrace.c 
  ptrace: progress trace 有/kernel/ptrace.c 和各arch下相应ptrace.c
  man ptrace：
  The  ptrace()  system call provides a means by which a parent process may observe and 
  control the execution of another process, and examine and change its core image
  and registers.  It is primarily used to implement breakpoint debugging and system call tracing.
  
  arch/arm/kernel/ptrace.c 就是增加了VFP的支持 S2.6.29到A2.6.29  S2.6.28.10 到 N2.6.28.10做了同样修改
  也就是说S2.6.29 都没有加这些修改。
  主要增加ptrace_getvfpregs()/ptrace_setvfpregs()
  ptrace.h增加:
  #define PTRACE_GETVFPREGS	27
  #define PTRACE_SETVFPREGS	28

9 关于signal.c  包含在/kernel/signal.c  arch/xx/kernel/signal.c 
  arch/arm/kernel/signal.c中，android做了修改：
  1 restart_syscall 增加几行
  2 do_signal 中增加一行regs->ARM_r0 = -EAGAIN;
  OMAP2.6.29 的signal.c跟Android的一模一样

  nxp对arch/arm/kernel/signal.c也有修改但是跟android改的地方不同
  1 setup_return函数增加了
   #if __LINUX_ARM_ARCH__ >= 7
     /* clear the If-Then Thumb-2 execution state */
     cpsr &= ~PSR_IT_MASK;
   #endif 这里N2.6.28.10增加的 arm-linux官方2.6.33 也增加了这几行
   O2.6.29 S2.6.29 A2.6.29 都没有这几行。应该增加！
   内核虽然没有编译成thumb2模式，但是应用程序是有thumb2指令的！
  2 do_signal函数的no_signal:处

    [知识] signal.h里面原来有：
     #define KERN_SIGRETURN_CODE	(CONFIG_VECTORS_BASE + 0x00000500)
     而CONFIG_VECTORS_BASE 在.config文件中是 0xffff0000
     这个宏在arch/arm/Kconfig中定义：
    config VECTORS_BASE
        hex
        default 0xffff0000 if MMU || CPU_HIGH_VECTOR
        default DRAM_BASE if REMAP_VECTORS_TO_RAM
        default 0x00000000
        help
          The base address of exception vectors.

    N2.6.28.10的修改能在网上的git中找到，并不是nxp自己改的。比如http://android.git.kernel.org/中就有
    [git.kernel.org]
    关于这个的修改记录，跟nxp的修改一样。是Russell King 2009-10-25提交，注释：
    ARM: Fix signal restart issues with NX and OABI compat

    The signal restarting code was placed on the user stack when OABI
    compatibility is enabled.  Unfortunately, with an EABI NX executable,
    this results in an attempt to run code from the non-executable stack,
    which segfaults the application.

    Fix this by placing the code in the vectors page, along side the
    signal return code, and directing the application to that code.
    （segfaults意思是段错误，显然是一个缩写不是一个单词）
    奇怪的是，在2.6.29和 2.6.33 的代码中怎么没有合这些程序呢？
    我知道了：这个提交是2009-10-25，而S2.6.29发布日期是2009-3-23 肯定是没有了。
    从git信息中可以看到，这个代码是在 2.6.32-rc5之后的2009-10-25由russell King 合并到stable版本的
    下面是具体的修改记录git地址：
    http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=ab72b00734ae4d0b5ff273a0f6c7abeaa3713c76
    修改了3个文件：signal.c  signal.h traps.c
    从网址中可以看到 linux/kernel/git/torvalds/linux-2.6.git 而正式发布的kernel来之 linux/kernel/git/stable/linux-2.6.git

调试init错误的时，内核里加打印 发现错误的时候，do_exit(arg) arg传进来的参数是11,就是SIGSEGV
可见，开始init打印 Attempted kill the init  跟后来运行打印Segmentation fault本质上是一个错误。

./arch/arm/kernel/setup.c:#ifdef CONFIG_THUMB2_KERNEL

内核改变后thumb2 支持后 有两处更改
CONFIG_ARM_ASM_UNIFIED 和   CONFIG_THUMB2_KERNEL

init不起动问题
1 kernel/exit.c 
find_new_reaper函数打印的这个提示

出错的时候，do_exit(code) 传进如的参数是11
 
core/combo/arch/arm/armv7-a.mk" [noeol] 22L, 674C 

On Android project page the source code of the kernel is available
Android project page 就是 http://code.google.com/p/android/downloads/list

调整make  menuconfig  thumb2选项影响

 # CONFIG_PREEMPT is not set
 CONFIG_HZ=100
-CONFIG_THUMB2_KERNEL=y
-CONFIG_ARM_ASM_UNIFIED=y
+# CONFIG_THUMB2_KERNEL is not set
+# CONFIG_ARM_ASM_UNIFIED is not set
 CONFIG_AEABI=y

nxp平台kernel 需关闭TLS或修复bionic tls的bug (40天解决init无法运行的问题)

3 nxp的kernel 名字是2.6.28.10 但是解压缩后 makefile中显示的是2.6.28.9 
4 http://code.google.com/p/ 这个是一个什么地址？
由于目前从android网站git后的源代码中不包括kernel，所以需要单独下载android kernel

5 http://android.git.kernel.org
kernel/common.git
kernel/experimental.git
kernel/linux-2.6.git 
description Mirror of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
description： Linus' kernel tree

kernel/lk.git  (L)ittle (K)ernel bootloader 是一个boot程序

先看kernel/common.git 先比较以下common下面：
android-2.6.29 和 android-goldfish-2.6.29的区别

一个仓库中有多个branch的时候，tag是针对所有的branch的

进入http://android.git.kernel.org/?p=kernel/common.git;a=summary目录后
显示的shortlog 第一条有一个绿色标签 显示 android-2.6.27 说明这组shortlog是针对2.6.27的
在下面点击2.6.29  就会显示相应2.6.29的shortlog

android.git.kernel.org里面没有2.6.28.x  只有2.6.2x.rcx

在oslinux/comps/kernle下面 有 r7.3  r7.6  r8.0  r8.1.2 r8.1.3

一个实验：
在 git.kernel.org 中在 kernel2.6.29.y.git 和 kernel2.6.28.y.git 找到同一个版本比如2.6.28.9
看看两个仓库到底是什么关系
2.6.28.y.git 只有2.6.28 和2.6.28-rcx  没有2.6.28.9 这个tag了

版本演变过程：2.6.28 2.6.28.1 2.6.28.2  2.6.28.3  ----2.6.28.10 到 2.6.29-rc1  到 2.6.29-rc8 到2.6.29

内核版本有两种：稳定版和开发版。
1. a.bb.cc 
其中，各部分的含义如下：
a是主版本号，取数字0～9之间的一个数，目前最高为2。
bb是次版本号，取值为00～99之间。 为基数表示不稳定版本
cc是修订版本号。
如果次版本号是偶数，则该内核是稳定版；若是奇数，则该内核是开发版。

2.5.74表示是一个测试版就的内核，2.6.12表示是一个稳定版的内核
数字从1跳跃到2是在1996年6月，正式推出“稳定版”2.0，之后又有“不稳定版”2.1 分支，然后“稳定”的2.2, 2.4和2.6 kernel树，不稳定kernel树
目前2.6.Z发布已经持续了很长时间，什么时候推出2.7呢？


===MTD===
http://www.linux-mtd.infradead.org (infradead??)


jffs2 建立在mtdblock设备节点之上，而不是直接mtd设备。那这么说，我完全可以在mtdblock设备上建立fat？ 原来我一直以为yaffs/jffs2 都是直接建立在flahs驱动上的


mtd //主设备号 90 / 31   （在最新内核源码里面看，90已经被占用了呀！）
/dev/mtd0 //字符设备
/dev/mtdblock0 //块设备


/dev/block/mmcblk0p1  //emmc flash
/dev/block/mtdblock3  //nand flash


s805
/dev/block

brw------- 179,  0  mmcblk0
brw------- 179,  1  bootloader
brw------- 179,  2  reserved
brw------- 179,  3  cache
brw------- 179,  4  env
brw------- 179,  5  logo
brw------- 179,  6  recovery
brw------- 179,  7  misc
brw------- 179,  8  boot
brw------- 179,  9  system
brw------- 179, 10  data
brw------- 179, 16  mmcblk0boot0
brw------- 179, 32  mmcblk0boot1

分区大小怎么指定的？ 这不是mtd，所以不是mtd_partitions

现在的emmc flash，如何分区的？


mtdparts参数支持: Device Drivers -> Memory Technology Device (MTD) support -> Command line partition table parsing

/dev/sdb   代表整个设备
/dev/sdb1  代表分区1

mtd-utils (apt-get install实际pc安装了并没有mtd设备可供操作呀 20160418)

包含工具：

flash_erase
flash_lock
flash_unlock
flash_otp_info
...
jffs2dump
jffs2reader
...
mtd_debug
mtdinfo
...
mkfs.jffs2
mkfs.ubifs
...
ubiformat
ubimkvol
...
ubirsvol
ubiupdatevol

制作jffs2镜像：
--pad 具体含义是什么？

MTD分区低4M做romfs，高4M 放置 u-boot  vmlinux  sample.mem db及系统参数，空间安排：sample.mem 1.9M压缩后600多k 内核3M多，压缩后1.5M

文件系统选择：
M3 yaffs2：
/dev/block/mtdblock3 /system yaffs2 ro,relatime 0 0
/dev/block/mtdblock5 /data yaffs2 rw,nosuid,nodev,relatime 0 0
/dev/block/mtdblock4 /cache yaffs rw,relatime 0 0

MX,A20: ext4 over mlc
BCM: UBIFS
rockchip？

A20:
/dev 下没有mtd设备，只有/dev/block 有若干block设备。
kernel配置中：
 Memory Technology Device (MTD) support  关闭(那mlc怎么用起来的？)

MTD(Memory Technology Device)用于访问ROM/flash等Memory设备的子系统。
主设备号90

sdcard emmc 属于块设备，他们的分区不属于mtd分区，比如sdcard运行android分多个分区

M3平台显示为c字符设备
crw-----mtd0
crw-----mtd0ro
image 是单个分区作，还是整个flash。

kernel里面的分区，制作image的时候的分区信息从哪里读出来？

emmc flash    mlc 模拟成block设备。

image烧写。

#cat /proc/mtd
dev:    size   erasesize  name
mtd0: 00000000 00001000 "DUMMY"
mtd1: 00a00000 00100000 "kernel"
mtd2: 12c00000 00100000 "system"
mtd3: 01000000 00010000 "spi0.0"

#cat /proc/partitions

/*
* mtd0 is normally the rootfs partition.  If it is missing,
* create a dummy partition so that any person or script
* trying to mount or erase mtd0 does not corrupt the
* whole flash device.
*/

add_mtd_device(mtd);  增加一个mtd分区

./drivers/mtd/mtdpart.c 中打印：
printk("Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

Creating 5 MTD partitions on "brcmnand.0":
0x000000000000-0x000000a00000 : "kernel"
0x000000a00000-0x000001400000 : "recovery"
0x000001400000-0x000001a00000 : "splash"
0x000001a00000-0x000001e00000 : "misc"
0x000001e00000-0x000080000000 : "ubi_fs"

brcmstb_nand.c里面 brcmstb_nand_probe函数
/*从命令行中解析到mtdpart就add partition 否则就添加mtd设备.跟硬盘一样，只有1个分区跟没有分区的mtd设备是不同的*/
if (nr_parts)
	add_mtd_partitions(mtd, parts, nr_parts);
else
	add_mtd_device(mtd);
return 0;


int add_mtd_partitions(struct mtd_info *master, const struct mtd_partition *parts, int nbparts)
{
  for (i = 0; i < nbparts; i++) {
  	add_mtd_device(&slave->mtd);
  }
}


struct mtd_info

/* Our partition node structure */
struct mtd_part {
	struct mtd_info mtd;  /*包含一个mtd_info 实体*/
	struct mtd_info *master; /*指向父的指针*/
	uint64_t offset;
	struct list_head list;
};


static LIST_HEAD(mtd_partitions);

/*描述每个分区*/
struct mtd_partition {
	char *name;			/* identifier string */
	uint64_t size;			/* partition size */
	uint64_t offset;		/* offset within the master MTD space */
	uint32_t mask_flags;		/* master MTD flags to mask out for this partition */
	struct nand_ecclayout *ecclayout;	/* out of band layout for this partition (NAND only) */
};

分区：
struct mtd_partition

/*
 * Partition definition structure:
 * An array of struct partition is passed along with a MTD object to
 * add_mtd_partitions() to create them.
 *
 * For each partition, these fields are available:
 * name: string that will be used to label the partition's MTD device.
 * size: the partition size; if defined as MTDPART_SIZ_FULL, the partition
 *  will extend to the end of the master MTD device.
 * offset: absolute starting position within the master MTD device; if
 *  defined as MTDPART_OFS_APPEND, the partition will start where the
 *  previous one ended; if MTDPART_OFS_NXTBLK, at the next erase block.
 * mask_flags: contains flags that have to be masked (removed) from the
 *  master MTD flag set for the corresponding MTD partition.
 *  For example, to force a read-only partition, simply adding
 *  MTD_WRITEABLE to the mask_flags.
 *
 * Note: writeable partitions require their size and offset be
 * erasesize aligned (e.g. use MTDPART_OFS_NEXTBLK).
 */

partition说明
./include/linux/mtd/partitions.h中
arch/mips/emma3sv/et61300/platform.c 定义partition


mtdparts= 由 cmdlinepart.c 解析

Read flash partition table from command line:

mtdparts=<mtddef>[;<mtddef]
<mtddef> := <mtd-id>:<partdef>[,<partdef>]
<partdef> := <size>[@offset][<name>][ro][lk] // lk??
<mtd-id>  := unique name used in mapping driver/device (mtd->name) (cat /proc/mtd)
<size>    := standard linux memsize OR "-" to denote all remaining space
<name>    := '(' NAME ')'

例：
1. 1个NOR 1分区:
	test_nor:-
2. 1个NOR 2分区，1个只读, 1个NAND 1分区
	nor:256k(ARMboot)ro,-(root);nand:-(home)
3. 1个spi 3分区，1个nand  3分区
	spi:1M(cfe),64K(macadr),-(others);bcmnand:10M(kernel),20M(recovery),30M(ubi_data)
	sfc:1536k@0k(boot),-(sfc-extra);nxp:5m@0k(kernel),100m@5m(rootfs),-(extra)
4. 1个nand 4分区
	hinand:1M(base),3M(logo),7M(kernel),180M(system)

raspberry pi 如何使用spi flash 运行jffs2

—boot—
nfs rootfs： File systems -> Network File Systems -> Root file system on NFS

General setup -> Initial RAM filesystem and RAM disk (initramfs/initrd) support
配置选项 CONFIG_BLK_DEV_INITRD （字面意思没有包含ramfs呀，只有ram disk） 疑问：那用ramdisk 还是ramfs/tmpfs呢？！
   Initramfs source file(s) 选项 CONFIG_INITRAMFS_SOURCE (rootfs编译到kernel)
此配置项在 ./usr/Kconfig中，仅在 ./usr/Makefile中使用，见图Image.png

M3 recovery rootfs: CONFIG_INITRAMFS_SOURCE="../out/target/product/f16ref/recovery/root"

因setting.apk写入默认IP地址导致nfs断开，可删除此apk，手动设置网关和DNS

bcm7231 nfs启动(这也不是uboot标准的setenv啊！)
setenv -p STARTUP "boot -z -elf flash0.kernel: 'root=/dev/nfs nfsroot=192.168.1.87:/home/Rootfs rw init=/init bmem=192M@64M bmem=256M@512M'"
flash启动：
setenv -p STARTUP "boot -z -elf flash0.kernel: 'ubiroot, bmem=192M@64M bmem=256M@512M,rw, nolock init=/init'"

setenv -p STARTUP "boot -z -elf  nandflash0.kernel: 'ubi.mtd=rootfs rootfstype=ubifs root=ubi0:rootfs bmem=192M@64M bmem=256M@512M,rw, nolock init=/init'"

./arch/mips/brcmstb/memory.c:early_param("bmem", bmem_setup); bmem=参数是博通的而非标准
BMEM (reserved A/V buffer memory) support


nfsroot=192.168.0.151:/home/nfsroot rw root=/dev/nfs ethaddr=00:00:4c:80:92:a7
root=/dev/nfs rw nfsroot=ip:/home/nfs rootdelay=2

root=/dev/nfs nfsroot=192.168.1.201:/home/gaojie/nfsroot/ rw

//看这种写法
setenv nandargs 'setenv bootargs rootfstype=ext3 mem=1024m mac=xx hdmi=${mode}'

hisi:
recoverybootargs=

bootargs=root=/dev/nfs nfsroot=ip:/home/nfsroot init=/init vmalloc=600M netmask=255.255.0.0  
解决多网段问题使用nfs指定ip地址两种方法：

记得trident没这么复杂:
bootargs=root=/dev/nfs nfsroot=192.168.1.52:/home/nfs init=/init

NFS启动：root=/dev/nfs nfsroot=192.168.1.52:/home/nfsroot rw     menuconfig支持nfs root

bootargs=root=/dev/nfs nfsroot=192.168.10.55:/home/gu/android_fs 

ip= 由 net\ipv4\ipconfig.c 解析：
ip=ip:ser_ip:gateway:netmask:ccdt-stb:eth0:on
ip=ip:ser_ip:gateway:netmask::which netcard:on
ip=192.168.10.229:192.168.10.1::255.255.255.0::eth0:off
ip=ip1:gatway:server:mask::eth0:on
ip=ip:serverip:gateway:netmask:ccdt-stb:eth0:on
ip=dhcp

./init/do_mounts.c:	printk("Waiting for root device %s...\
./init/main.c:	    printk("Kernel command line: %s\n", boot_command_line);

A20:
/proc/cmdline
root=/dev/system init=/init loglevel=4 partitions=bootloader@nanda:env@nandb:boot@nandc:system@nandd:recovery@nande:databk@nandf:data@nandi:cache@nandj:UDISK@nandk mac_addr=x
根本没有/dev/system这个节点!

5 内核参数传递:
Kernel hacking->Default kernel command string.:
On some platforms,there is currently no way for the boot loader to pass arguments to the kernel. For these platforms, you can supply some command-line options at build time by entering them here.
如果u-boot传递参数给内核，这里就不用设置了。如果参数配置到内核里面就不需要传递参数了。

pivot_root() 用于启动过程中改变 rootfs 

parse_cmdline(...)
=======
MDEV Primer

=== permission ===
整个u盘没有写权限（有时会遇到）
磁盘插入，整个挂在点是root.root权限

exec.c检测mode = inode->i_mode;

cred.h:
uid_t	uid;	/* real UID of the task */
gid_t	gid;	/* real GID of the task */
uid_t	suid;	/* saved UID of the task */
gid_t	sgid;	/* saved GID of the task */
uid_t	euid;	/* effective UID of the task */
gid_t	egid;	/* effective GID of the task */

三个ID：real user ID，effective user ID，saved set user ID

ps怎么显示 uid的int形式？

android_filesystem_config.h中定义android_ids：
{ "media",     AID_MEDIA, },
#define AID_MEDIA         1013  /* mediaserver process */
media 用户的uid 是 1013

这里只是一个定义，那么是怎么让系统中就有了这个uid的呢？

#define AID_APP          10000 /* first app user */  应用程序从10000开始

最终在bionic里面的stubs.c中处理
app_id_to_passwd
android_id_to_passwd
两个函数，向系统中注册了uid

1 用nfs看system/lib 文件用户名组名都为 default 因为在pc上文件属于 gaojie.gaojie uid gid 都为1000 而在平台上
etc/passwd group 两个文件中有：
default:x:1000:1000:Default non-root user:/home/default:/bin/sh
default:x:1000: 所以就成 default 了
uid gid 都为0 的就是root权限
那么 system/下面应该都是root权限的 将 password  group 删除 此时 ls -al  则不能显示用户名组名 只能显示 uid gid了
用户名靠android_filesystem_config.h定义,相当于原来 passwd  group 文件
比如/bin/cp 的权限为：
-rwxr-xr-x 1 root root 96140 2010-03-05 11:29 cp  
首先这个文件所属的用户和组为 root （uid gid 为 0 ）
只有root用户可以 rwx 其他用户都只是rx。即所有用户都可以执行cp 但是只有root用户可以删除这个命令。
那么这个规则是由谁来控制呢？ shell？！那么当前用户 是由库决定的还是由kernel决定的呢？
伪用户或假用户不具有登录系统的能力，但却是系统运行不可缺少的用户，如bin、daemon、adm、ftp

seteuid
setegid

#sudo chown 117.65534 xxx  
chmod u+s
chmod u+t   如果有x，就显示小写，没有x显示大写

s:sticker
===end permission ===




oprofile Linux的 评测和性能监控工具
arch/um(uml:user mode linux)
为研究内核用，整个系统是一个用户进程，可以像调试普通进程一样调试它，巧妙的用一个arch实现
Documentation/virtual/uml/UserModeLinux-HOWTO.txt
fs/hostfs 配合uml用

USB Device Driver
USB Gadget Driver

include/linux/major.h
#define FB_MAJOR     29   /* /dev/fb* framebuffers */

/proc/modules 模块加载地址

Note that device numbers 204 and 205 are used for "low density serial devices"

Show timing information on printks
Debugging Options -> Abort compilation on any warning

ttyAMA0: Embedded ARM AMBA PL011 ports(e.g. emulated by QEMU)

Linux/drivers/tty/serial/amba-pl011.c
// Driver for AMBA serial ports


1 phy驱动: drivers/net/phy
配置项：

ioremap
ioremap_nocache

drivers/net/gianfar_mii.c : Gianfar Ethernet Driver -- MIIM bus implementation Provides Bus interface for MIIM regs

#define DEVICE_NAME "%s: Gianfar Ethernet Controller Version 1.2, "

mdio_scan()
mdiobus_register()

mii_bus类型 bus->read 在哪里定义？

platform_driver 结构体的 probe 什么时候调用

需要搞定kernel调试技术

cpu_relax() 

==devicetree==
http://www.arm.linux.org.uk/developer/machines/
2011/3/17 Linus在ARM Linux的一封邮件“this whole ARM thing is a fucking pain in the ass”，建议用PowerPC等架构的Device Tree
Device tree 是描述硬件layout的数据结构，板级描述语言

查看dts设备节点
# ls -al /proc/device-tree
dts device tree source
dtb device tree blob

BLOB (binary large object)，二进制大对象
dtc Device Tree Compiler (scripts/dtc/)

fdt  flatened device tree
OF open firmware
u-boot支持设备树：
config加入 CONFIG_OF_LIBFDT
命令：
fdt addr
fdt resize
fdt print

Documentation 目录删除不行，make clean时候要找这个目录
在跟makefile中：
clean-dirs      := $(addprefix _clean_, . $(vmlinux-alldirs) Documentation)  #这里Documentation 去掉即可
mrproper-dirs      := $(addprefix _mrproper_,Documentation/DocBook scripts) #Documentation/DocBook 去掉
就可以正常执行 make clean  mrproper了
arch/um fs/hostfs 需同时删除
因 fs/hostfs/Makefile 又"include arch/um/scripts/Makefile.rules"

不过distclean时提示：
scripts/Makefile.clean:17: fs/hostfs/Makefile: No such file or directory
因为：fs/Makefile 中有 obj-$(CONFIG_HOSTFS)		+= hostfs/
CONFIG_HOSTFS 并没有配置，但clean的时候却回去检查，可见，distclean时并不检查.config 
也就是说，即使我同时配置了多个情况，比如有的编译了某fs，有的没有，distclean时一并清除。这个思想是对的！
在driver下删除某个目录，要在Makefile中把相应条目删除
driver 目录还有很多过时的驱动可以删除

----driver---
I2C(Inter-IC) I-squared-C/I-two-C/I-I-C
Two-wire Serial Interface :I2C 子集
SMBus(System Management Bus),Intel定义，I2C子集，定义更严格，与i2c相似，互相借鉴。

www.nxp.com/documents/user_manual/UM10204.pdf

dev/i2c-0  
dev/i2c-1

gpio内部上拉可驱动iic

kernel:
i2c_transfer()
i2c_master_send()

user:
open/ioctl

i2c-tools 里面的 i2cdetect工具


I2S:
SDATA: 数据
SCLK: 数据同步用时钟
LRCLK: 左右声道切换时钟
MCLK: 芯片工作的主时钟



Bus Hound(猎犬) perisoft公司用于PC总线数据包监视

帧:数据流里面检测一个处理单元的起止位置


-----sd-----
http://www.jedec.org  gaojiexxx:gaojie123 (gaojie@cyclecentury.com)
https://www.sdcard.org/

High-Capacity (SDHC), the eXtended-Capacity (SDXC)

SDXC: Secure Digital eXtended Capacity
SD: Secure Digital
SDIO: Secure Digital I/O 多用于Wi-Fi/Bluetooth模组，现在多用usb替代

MiniSD
TF(Trans-flash)即Micro SD，SanDisk发明，15x11mm
SanDisk 128GB卡，打破最高64G卡的限制

SD与MicroSD引脚不同：
SD 9脚排序: 9 1 2 3 4 5 6 7 8 (2个地)
MicroSD 8脚排序: 1 2 3 4 5 6 7 8
SD引脚      9 D2  1 D3 2 cmd 3 vss 4 vdd   5 clk  6 vss  7 D0  8 D1
TF卡SD模式  1 D2  2 D3 3 cmd 4 vdd 5 clk  6 vss   7 D0 8 D1 (4,6脚较长) 
TF卡SPI模式 1 保留   2 cs    3 di  4 vdd 5 sclk 6 vss  7 do     8 保留   
TF卡座第9脚检查插入拔出

25MHz/50MHz 时钟在clk引脚上
SDIO信号：

Speed class rating
class 4   4M/s  称为C4
class 10  10M/s 称为C10

eMMC : embedded MMC 官方写法 e.MMC 将flash memory + controller) 放入BGA IC封装，不支持 SPI-bus协议
ScanDisk  C10 microSDHC  I(这个I标示UHS I？)
MMC:Multimedia Card
SD基于MMC发展而来，保留MMC的7针外，在两边加了2针作为数据线，长宽和MMC一样，兼容MMC。



gu:
rockchip 芯片otg usb device 模拟网卡，NCM协议， 开始在freescal平台调试ok，移植到rockchip，枚举基本ok，mac地址获取不到，数据丢失几个字节
原因：网络数据要求对齐，而otg驱动数据没有对齐（不明白）


----
buildroot.org   黄色安全帽
Buildroot is a simple, efficient and easy-to-use tool to generate embedded Linux systems through cross-compilation
