STM32F300W (以g为目标，要求不高)

printf 重定向 fputc

接线标准：黄-clk

CANopen
cmx.com

板子：
NUCLEO-F401RE    (F401RE 84MHz 512+96 M4 DSP+FPU)
STM32F407G-DISC1 (F407VG 168MHz 1M+192k)
F303-Discovery   (F303VC 72MHz 256+40 M4 DSP+FPU)
F429-Discovery   (F429ZI lcd u-boot)

M0/M0+/M3/M4/M7
F030F4P6   M0 16K+4K Value-line

NUCLEO-F401RE:
OFF:
SB 4/6/8/10/11/18/20/24/29/30/32/36/39/44/46/47/48/49/52/55/59/61/62/63
ON:
SB 3/5/7/9/12/13/14/15

F401的PA2/3连到F103的PA2/3 UART2


F401 PWM:
PA0 可以是TIM2_CH1/TIM5_CH1
PA5 只能是TIM2_CH1，即选中TIM5_CH1时，TIM2_CH1 只能在PA5

F407G-Disc1:
LD3 : PD13
LD4 : PD12
LD5 : PD14
LD6 : PD15


独立ST-Link，拔掉CN2跳线，CN4: 2-CLK,3-GND,4-DIO

看一下，有些信息
http://www.wolinlabs.com/blog/linux.stm32.discovery.gcc.html
http://regalis.com.pl/en/arm-cortex-stm32-gnulinux/

F429I-DIS: u-boot 运行成功
st-flash write u-boot.bin 0x8000000
debian下，st-link模拟串口是ttyACM0, mac下不认此串口

sw4stm32的编译器(plugin/.../xx.tar.bz2)：
arm-none-eabi-gcc --version
5.4.1 20160919 (release) [ARM/embedded-5-branch revision 240496]

arm官网下载：
arm-none-eabi-gcc --version
6.3.1 20170215 (release) [ARM/embedded-6-branch revision 245512]

arm-none-eabi-gcc -mcpu=cortex-m3 -mthumb -O0



STSW-LINK009 : ST-LinkV2 驱动

GPIOA/B/C/D/E/F/G 时钟单独开启 16-GPIO/组 上电为GPIO模式

F103 内存
0x00000000 - 0x0007ffff 512K
0x08000000 - 0x0807ffff 512K Flash
0x1ffff000 - 0x1ffff7ff 2k   System Memory

源地F103
R-A9
T-A10(A9左下)

HSE 外部晶振
HSI 内部RC晶振

f103c8 64+20
f103rb 128+20
f103rc 256+48
f103ve 512+64

C-48/R-64/V-100/Z-144
6-32K/8-64K/B-128K/C-256K/D-384K/E-512K
T6:LQFP-工业

Ld/Md/Hd

HAL_CRC_Calculate. 硬crc

-------------
Switcher
f103c8t6 64+20

------
VCP: Virtual COM Port

好资料
https://www.keil.com/pack/doc/mw/USB/html/dev_cdc_tutorial.html

基于 usb CDC 设备类驱动
CDC: Communication Device Class

串口： CDC(ACM) Abstract Control Model 

cubeF1 中的cdc驱动，注释实现了 CDC1.2 / PSTN1.2 (Public Switched Telephone Network)
也实现了 Abstract Control Model （在PSTN1.2中描述）

Emulation of a Virtual COM-port using the ACM (Abstract Control Model) subclass of CDC.

USBD_VCP  USB Device VCP example

-----
cubemx中设置外部时钟：
RCC: Reset and clock control
 
bypass clock source (指的是 使用有源晶体)
crystal/ceramic resonator (无源晶体)

识别出来是：
Bus 001 Device 016: ID 0483:5740 STMicroelectronics STM32F407
重申：后面的字符串没有写在程序里，2个字符串与网站登记信息完全匹配

驱动虽然只有win7/win8 2个目录，但是在xp上安装win7目录下的32bit驱动成功了，
在设备管理器中，成功看到了 STMicro Virtual COM Port(COM5) 设备
现在就是继续看看，如何 通过这个com5 发送数据过去，stm32怎么接收数据

-----
typedef struct _USBD_CDC_Itf {
  int8_t (* Init)          (void);
  int8_t (* DeInit)        (void);
  int8_t (* Control)       (uint8_t, uint8_t * , uint16_t);   
  int8_t (* Receive)       (uint8_t *, uint32_t *);  
} USBD_CDC_ItfTypeDef;

只有 USBD_CDC_DataOut 调用了 Receive 方法

static USBD_CDC_DataIn()  (啥也没干)
static USBD_CDC_DataOut()

----------------------
USBD_CDC_SetTxBuffer()  //参数有 Len
USBD_CDC_SetRxBuffer()  //参数无 Len why? 

APP_RX_DATA_SIZE  要根据实际情况确定大小，暂时确定为32字节吧，一个AT命令够用了
现在看，超出可能会导致死机，此时可以控制包大小，现在是64字节，如果设置包大小为16字节，则发送32字节需要2次，
中间有超时时间控制，
echo hello world > /dev/ttyACM0  会发现没有收完的话，会卡住，ok 到此，都通了
把环境迁移到 mac电脑，剩下的回家去调试

CDC_Transmit_FS("Hello World CDC\r\n", 16);

在接收回调里，调用printf 会卡死, fputc 调用Trans 一直返回busy，调用CDC_Transmit_FS，第一次能打印，第二次调用没有打印，返回 USBD_BUSY


STM32 using callbacks to retrive data from USB CDC VCP

HAL_PCD_DataOutStageCallback()
HAL_PCD_DataInStageCallback()

在HAL_PCD_IRQHandler 中被调用

__weak: 以重载函数

MX_USB_DEVICE_Init() 调用了：

USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC);
USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS);
USBD_Start(&hUsbDeviceFS);

ttyUSB0 ttyACM0 怎么区分的？为啥这个程序linux就认 ACM0？

接收参考：
Cube_FW_F4_V1.15.0/Projects/STM324xG_EVAL/Applications/USB_Device/CDC_Standalone

-----
github: vcp 例子
mfauzi/STM32F4


有三种复位的方法：系统复位、电源复位、RTC domain复位



调用栈：
HAL_GetTick
HAL_PCD_IRQHandler
PCD_EP_ISR_Handler
USBD_LL_DataOutStage
USBD_CDC_DataOut
CDC_Receive_FS //Buf参数就是 UserRxBufferFS[4]
USBD_CDC_ReceivePacket (merely called)
USBD_LL_PrepareReceive() //prepare OUT Endpoint for reception


CDC_Receive_FS()
{
  //如果不调用这2函数，回调进入一次，就不再进入（F4 demo，在uart dma回调里调用这个函数）
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
}

每次执行完
CDC_Transmit_FS("Start...\n\r", 10);
会进入：
HAL_GetTick
HAL_PCD_IRQHandler
PCD_EP_ISR_Handler
USBD_LL_DataInStage
USBD_CDC_DataIn (这个函数基本啥也没干)


每次中断只接收到1个字符？还是说我按键测试速度太慢了
现在：怎么获取收到的数据呢?


keil4.7 编译器对局部变量做了优化，debug看不到局部变量的值，调试的时候，把O2改为O0


使用了外部晶体，SOC_IN/OUT 是PD0/1， 代码中 __HAL_RCC_GPIOD_CLK_ENABLE(); （不加这个晶体会不工作吗？需验证）

Nucleo-F401 ST-Link使用：
拔掉晶体旁边的2个跳线，CN4 3:GND，2:SWCLK, 4:SWDIO


PB3/4默认配置为JTAG，需要释放IO
__HAL_AFIO_REMAP_SWJ_NOJTAG();  // HAL_MspInit 里cube生成

USwitcher 就采用 中断+循环模式，无OS

PB3/4 与JTAG冲突

这个地方，从shell里面提取，不要自己写了

###
DAC
在产品中选择 data converters, 多数是 2个通道


---yj---
STM32L051K8U6
Ultra-low-power M0+ 64 Kbytes Flash 32 MHz

红色标志为VCC，同面另一边为GND，中间CLK，对面中间DIO


--
USART1  怎么弄？


SWD模式  J-link OB(on board)   st-link V2
isp模式  uart


http://www.vcc-gnd.com/gongjuyuruanjian/ide/

---stm32f4discovery---
STSW-STM32068: STM32F4DISCOVERY board firmware package, including 22 examples
已经集成到cube中

mdk下载的 STM32F4xx_DFP 1.5G 跟 STM32F4Cube，内容相似但结构调整过，不一样，基本上就是Cube



----100W!----
ADC测试



-----
cube:
Driver/CMSIS/Documentation  不错的文档




STM32F4-Disc MEMS Microphone 录制PDM格式音频，用PDM Filter 转换为PCM数据。
PDM的录音频率有PLLI2S提供，我尝试着将PLLI2S的时钟调整为48KHz需要的频率86000000，
PDM_Filter 的低通设置为20000Hz，高通设置为20Hz，采样率设置为48000Hz

PDM麦克风

PDM: 脉冲密度调制
PCM: 脉冲编码调制
PWM: 脉冲宽度调制


----
DSP
gcc的库 3M+ little
mdk的库 13M+  little and big

DSP_Lib 全部是用C实现的，那怎么体现dsp呢？特殊编译参数？
cmsis/DSP_Lib/Source/下的文件生成lib/gcc下的2个.a

并没有文档中说的  DSP_Lib/Source/ARM/arm_cortexM_math.uvprojx， 所以无法自己编译库


----
没有卖
cortex-m7
stm32F722RE
stm32F732RE (with HW crypto-Tiny AES)
