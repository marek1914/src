STM32F100W   不要懒惰

openstm32.org gaojie:200w200w
st.com 13xx@q.com:89..2*G

看一下，有些信息
http://www.wolinlabs.com/blog/linux.stm32.discovery.gcc.html
http://regalis.com.pl/en/arm-cortex-stm32-gnulinux/

F429I-DIS: u-boot 运行成功
st-flash write u-boot.bin 0x8000000
debian下，st-link模拟串口是ttyACM0, mac下不认此串口

下载器：
1 OpenOCD : open on chip debugger
2 github.com/texane/stlink


sw4stm32的编译器(plugin/.../xx.tar.bz2)：
arm-none-eabi-gcc --version
5.4.1 20160919 (release) [ARM/embedded-5-branch revision 240496]

arm官网下载：
arm-none-eabi-gcc --version
6.3.1 20170215 (release) [ARM/embedded-6-branch revision 245512]

arm-none-eabi-gcc -mcpu=cortex-m3 -mthumb -O0

cmsis/DSP_Lib/Source/下的文件生成lib/gcc下的2个.a

board：
NUCLEO-F401RE(F401RET6 84MHz 512+96)
STM32F407G-DISC1 (F407VGT6 168MHz 1M+192k)
F303-Discovery
F429-Discovery (F429ZIT6 lcd u-boot)

STM32F3/F4: with DSP and FPU instructions

j-link /segger
http://gnuarmeclipse.github.io/debug/jlink/install/#gnulinux

STSW-LINK009 : ST-LinkV2 驱动

GPIOA/B/C/D/E/F/G 时钟单独开启 16-GPIO/组 上电为GPIO模式

F103 内存
0x00000000 - 0x0007ffff 512K
0x08000000 - 0x0807ffff 512K Flash
0x1ffff000 - 0x1ffff7ff 2k   System Memory

源地F103
R-A9
T-A10(A9左下)

HSE 外部晶振
HSI 内部RC晶振

f103c8 64+20
f103rb 128+20
f103rc 256+48
f103ve 512+64

C-48/R-64/V-100/Z-144
6-32K/8-64K/B-128K/C-256K/D-384K/E-512K
T6:LQFP-工业

Ld/Md/Hd

HAL_CRC_Calculate. 硬crc

j-link: 左到右：白灰黑
J-Link-OB

写不进flash，用segger: j-link stm32 unlock 工具解锁
安装最新驱动，mdk不能用了，把keil/arm/segger目录替换回老版本

-------------
Switcher
f103c8t6 64+20

------
VCP: Virtual COM Port

好资料
https://www.keil.com/pack/doc/mw/USB/html/dev_cdc_tutorial.html

基于 usb CDC 设备类驱动
CDC: Communication Device Class

串口： CDC(ACM) Abstract Control Model 

cubeF1 中的cdc驱动，注释实现了 CDC1.2 / PSTN1.2 (Public Switched Telephone Network)
也实现了 Abstract Control Model （在PSTN1.2中描述）

Emulation of a Virtual COM-port using the ACM (Abstract Control Model) subclass of CDC.

USBD_VCP  USB Device VCP example

-----
cubemx中设置外部时钟：
RCC: Reset and clock control
 
bypass clock source (指的是 使用有源晶体)
crystal/ceramic resonator (无源晶体)

识别出来是：
Bus 001 Device 016: ID 0483:5740 STMicroelectronics STM32F407
重申：后面的字符串没有写在程序里，2个字符串与网站登记信息完全匹配

驱动虽然只有win7/win8 2个目录，但是在xp上安装win7目录下的32bit驱动成功了，
在设备管理器中，成功看到了 STMicro Virtual COM Port(COM5) 设备
现在就是继续看看，如何 通过这个com5 发送数据过去，stm32怎么接收数据

-----
typedef struct _USBD_CDC_Itf {
  int8_t (* Init)          (void);
  int8_t (* DeInit)        (void);
  int8_t (* Control)       (uint8_t, uint8_t * , uint16_t);   
  int8_t (* Receive)       (uint8_t *, uint32_t *);  
} USBD_CDC_ItfTypeDef;

只有 USBD_CDC_DataOut 调用了 Receive 方法

static USBD_CDC_DataIn()  (啥也没干)
static USBD_CDC_DataOut()

----------------------
USBD_CDC_SetTxBuffer()  //参数有 Len
USBD_CDC_SetRxBuffer()  //参数无 Len why? 

APP_RX_DATA_SIZE  要根据实际情况确定大小，暂时确定为32字节吧，一个AT命令够用了
现在看，超出可能会导致死机，此时可以控制包大小，现在是64字节，如果设置包大小为16字节，则发送32字节需要2次，
中间有超时时间控制，
echo hello world > /dev/ttyACM0  会发现没有收完的话，会卡住，ok 到此，都通了
把环境迁移到 mac电脑，剩下的回家去调试

CDC_Transmit_FS("Hello World CDC\r\n", 16);

在接收回调里，调用printf 会卡死, fputc 调用Trans 一直返回busy，调用CDC_Transmit_FS，第一次能打印，第二次调用没有打印，返回 USBD_BUSY


STM32 using callbacks to retrive data from USB CDC VCP

HAL_PCD_DataOutStageCallback()
HAL_PCD_DataInStageCallback()

在HAL_PCD_IRQHandler 中被调用

__weak: 以重载函数

MX_USB_DEVICE_Init() 调用了：

USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC);
USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS);
USBD_Start(&hUsbDeviceFS);

ttyUSB0 ttyACM0 怎么区分的？为啥这个程序linux就认 ACM0？

接收参考：
Cube_FW_F4_V1.15.0/Projects/STM324xG_EVAL/Applications/USB_Device/CDC_Standalone

-----
github: vcp 例子
mfauzi/STM32F4


有三种复位的方法：系统复位、电源复位、RTC domain复位



调用栈：
HAL_GetTick
HAL_PCD_IRQHandler
PCD_EP_ISR_Handler
USBD_LL_DataOutStage
USBD_CDC_DataOut
CDC_Receive_FS //Buf参数就是 UserRxBufferFS[4]
USBD_CDC_ReceivePacket (merely called)
USBD_LL_PrepareReceive() //prepare OUT Endpoint for reception


CDC_Receive_FS()
{
  //如果不调用这2函数，回调进入一次，就不再进入（F4 demo，在uart dma回调里调用这个函数）
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
}

每次执行完
CDC_Transmit_FS("Start...\n\r", 10);
会进入：
HAL_GetTick
HAL_PCD_IRQHandler
PCD_EP_ISR_Handler
USBD_LL_DataInStage
USBD_CDC_DataIn (这个函数基本啥也没干)


每次中断只接收到1个字符？还是说我按键测试速度太慢了
现在：怎么获取收到的数据呢?


keil4.7 编译器对局部变量做了优化，debug看不到局部变量的值，调试的时候，把O2改为O0


使用了外部晶体，SOC_IN/OUT 是PD0/1， 代码中 __HAL_RCC_GPIOD_CLK_ENABLE(); （不加这个晶体会不工作吗？需验证）

Nucleo-F401 ST-Link使用：
拔掉晶体旁边的2个跳线，CN4 3:GND，2:SWCLK, 4:SWDIO


调试发现 PB3 PB4 设置io无效，因为复位后，PB3/4默认配置为JTAG，需要释放IO
__HAL_AFIO_REMAP_SWJ_NOJTAG();  // HAL_MspInit 里面
都是cube生成的，现在体现到cube的强大了

———————
printf 重定向fputc
MDK，Target -> Code Generation 勾选 Use MicroLIB
———————

USwitcher 就采用 中断+循环模式，无OS

PB3/4 与JTAG冲突


KEY_UP    \033[A
KEY_DOWN  \033[B
KEY_RIGHT \033[C  27(ESC) 91 67
KEY_LEFT  \033[D  27 91 68



这个地方，从shell里面提取，不要自己写了
