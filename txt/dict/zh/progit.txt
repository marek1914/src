一个不太容易理解的技巧是这句，它的返回真值如果路径以开头——这是为了确保并不是只在允许的路径之一，而是所有准许全选的目录都在该目录之下。
一个到那些不匹配第一条规则，掉到第二条，因此被拒绝。
一个单独的对象包含一条或多条记录，每一条记录含有一个指向或子对象的指针，并附有该对象的权限模式、类型和文件名信息。
一个存放代码仓库的中心服务器，可以接受所有开发者提交的代码。
一个小陷阱在于它假设在本地运行的账户和推送到远程服务端的相同。
一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。
一个这个配置文件语法的重要功能是，所有的仓库的规则不需要在同一个位置。
一个非常有用的选项就是，当一些特定文件发生冲突，会尝试合并他们，而使用你这边的合并。
一些发行版可以通过或安装一个叫做的软件包，不妨首先尝试一下。
一些文件看起来像是文本文件，但其实是作为二进制数据被对待。
一些更加复杂的实例可以在源码的目录里找到；其中较为出众的是前面提过的脚本。
一些维护者更喜欢衍合或者挑拣贡献者的代码，而不是简单的合并，因为这样能够保持线性的提交历史。
一些设置可以通过编辑文件来简单地改变，但是如果这个不够，有关于定制的文档供参考。
一些设置项也能被运用于特定的路径中，这样，以对一个特定的子目录或子文件集运用那些设置项。
一份好的提交指南可以帮助协作者更轻松更有效地配合。
一切都准备停当，无需更多。
一切都设定好了。
一旦主干在特性分支创建之后有所修改，那么通过命令来比较的，是最新主干上的提交快照。
一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行变基操作。
一旦发现某个提交可以从远程索引里衍变过来，它就放弃衍合操作：
一旦特性分支准备停当，接下来的问题就是如何集成到更靠近主线的分支中。
一次性的抓取动作自然不会把该仓库地址加为远程仓库。
一般上面列出的安装选项已经够用，要是你想用连接的代码仓库，还可以加上选项，具体将在第八章作介绍。
一般以单个空格紧跟短划线或者星号作为每项条目的起始符。
一般在新的系统上，我们都需要先配置下自己的工作环境。
一般情况下，如果到了这一步，使用公共密钥可能是更简单的方案；不过也存在一些特殊情况，这时通过使用带签名的证书或者其他基于的只读连接授权方式是更好的解决方案。
一般我们会先看下，特性分支上都有哪些新增的提交。
一般我们总会有些文件无需纳入的管理，也不希望它们总出现在未跟踪文件列表。
一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。
一般最简单的情形，是在分支中维护稳定代码，然后在特性分支上开发新功能，或是审核测试别人贡献的代码，接着将它并入主干，最后删除这个特性分支，如此反复。
一般来说，列表中没有的分支通常都可以用来删掉。
一般来说，如果该补丁是基于某个公开的提交制作而成的话，你总是可以通过同步来获取这个共同祖先，所以用三方合并选项可以解决很多麻烦：
一般来说，提交说明最好限制在一行以内，个字符以下，简明扼要地描述更新内容，空开一行后，再展开详细注解。
一般的做法是，同时提供接口，让几个开发者拥有推送写权限，其他人通过拥有只读权限。
一般的协作流程如图所示：
一般的开发者在自己的特性分支上工作，并不定期地根据主干分支上的衍合。
一般超大型的项目才会用到这样的工作方式，像是拥有数百协作开发者的内核项目就是如此。
一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。
上例在一个分支导入了次提交数据，包含了个对象。
上半个窗口显示的是历次提交的分支祖先图谱，下半个窗口显示当前点选的提交对应的具体差异。
上将此脚本复制到目录中，上则复制到目录中。
上节例子中多处显示了，比如的输出以及。
上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。
上面的例子中，我们就使用了这个选项。
上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。
上面的例子非常简单，而随着使用的深入，给出的信息可能会像这样：
上面的选项允许检查是否有对文件重命名的提交。
上面说的是私有项目协作，但要给公开项目作贡献，情况就有些不同了。
下一个值得注意的部分是错误信息。
下一个在运行期间调用是挂钩。
下一步，客户端会发送一个所有那些服务端所没有的对象的一个打包文件。
下一步是寻找引用，这样你就知道了在完成后，什么应该被检出到工作目录：
下一章将介绍内部的原始数据格式，从而是使你能亲手锻造其中的每一个字节，如果必要的话。
下一章我们就会详细讨论分支和引用。
下一行以起始，表示有字节长，所以需要读剩下的字节。
下例中，我们指定几个管理员，几个对目录具有权限的文档作者，以及一个对和目录具有权限的开发人员，相应的文件如下：
下次签出文件时，入了的值：
下节我还会再举些例子，看看各式工作流中的每个角色具体应该如何操作。
下载更新后需要合并，但此时变基产生的提交对象'的校验值和之前完全不同，所以会把它们当作新的提交对象处理，而实际上此刻你的提交历史中早已经包含了的修改内容，于是合并操作会把和'合并为见图
下载的源代码，进入目录，会看到一个文件。
下面一节将介绍一些针对各个协议典型的设置以及如何在服务器上实施。
下面会介绍两种方法，第一种使用托管服务商提供的仓库复制功能，一般称作，比如和都支持这样的操作，而且许多项目管理员都希望大家使用这样的方式。
下面假设尝试连接的用户储存在环境变量里，我们的脚本首先搜集一切需要的信息：
下面分别介绍一下哪些情形应该使用或避免使用这些协议。
下面展示了一个实例，我把此书的第一章纳入管理，在一个段落中加入了一些文本后保存，之后运行命令，得到结果如下：
下面，我们将会展示，如何使用转化工具进行二进制文件的比较。
下面我们用一个实际例子来说明为什么公开的变基会带来问题。
下面是一个检查这个问题的脚本的例子。
下面是一个简单的例子：
下面是新增远程服务器的例子：
下面是来自的原创的提交说明格式模版，供参考：
下面演示一下如何编写一个简单的导入脚本。
下面用脚本来实现：
下面的例子中省略了常规提示，用代替以节约版面。
下面的几节中，你会了解如何扩展到更复杂的设定。
下面的命令列出所有最近两周内的提交：
下面的命令有相同的效果：
下面的操作可以允许通过对仓库进行读取：
下面的示例，我已经把终端中显示为红色的白字符用替换掉：
下面的示例演示了对仓库主分支进行到一个老版本的的操作，然后恢复丢失的。
下面要搞定如何从所有的提交内容中提取出提交信息。
下面这个方法生成一个关联数组，它的主键是用户名，值是一个该用户有写权限的所有目录组成的数组：
下面这些命令能实现的这些功能。
不仅作者一项干净了不少，也就此消失了。
不像其他的系统，并不跟踪文件移动操作。
不匹配的访问会被拒绝。
不同之处在于它会为推送者更新的每一个分支运行一次。
不同的就只有这两点——除此之外，该脚本完全相同。
不妨把它看成一个跛脚的，然而，你还是有可能在转换过程中碰到一些困惑你和合作者们的迷题。
不存在所谓某个项目的官方版本，所以假如第一作者放弃了某个项目，它可以无缝转移到其它用户的名下。
不幸的是，我们没有什么好办法来避免该情况——无法储存这个信息，所以在使用它作为服务器的时候你将永远为这个缺陷所困。
不时地运行一下可以确保你的代码没有过时。
不用怕，的一些配置选项会帮助你解决这些问题。
不用担心，查看文件状态的时候就提示了该如何撤消，所以不需要死记硬背。
不用说，这是十分罕见的情况。
不管代码合并是不是会有问题，至少我们知道该分支的历史分叉点，所以默认会从共同祖先开始自动进行三方合并，无需选项，也不用像打补丁那样祈祷存在共同的基准点。
不管你是从前面的章节直接跳到了本章，还是读完了其余各章一直到这，你都将在本章见识的内部工作原理和实现方式。
不管哪种方式，在连接之后，都会以这种形式返回：
不能完全替代随自带的大量文档。
不能用命令来删除一个特定文件，而是必须用来删除它──即从索引而不是磁盘删除它。
不要单独建立和使用一个服务器来搞合作。
不过不用担心，这会交给来实现。
不过且慢，再运行看看：
不过，仍然需要提取每一个版本，每次一个，再逐个提交。
不过以及运行时往添加的一些中仍有对它的引用，因此需要将这些引用删除并对仓库进行操作。
不过任何其他语言也一样适用。
不过只要你不和服务器通讯，你的指针仍然保持原位不会移动见图。
不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止为你切换分支。
不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。
不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项强制执行，就像上面提示信息中给出的那样。
不过如果有人在某个时刻往项目中添加了一个非常大的文件，那们即便他在后来的提交中将此文件删掉了，所有的签出都会下载这个大文件。
不过实践中我们是不太用这个选项的，在输出所有提交时会自动调用分页程序，要看更早的更新只需翻到下页即可。
不过当你需要在书籍、论文这种很大的文本文件上进行对比的时候，这个功能就显出用武之地了。
不过最好提供一条描述提交的信息通过，否则这次合并的记录是，而不是任何有用的东西。
不过有时候我们希望运行某个外部命令，而非的子命令，这个好办，只需要在命令前加上就行。
不过现在，你已经得到了一个实际维护着若干文件的仓库。
不过现在的例子中，我们确实想要跟踪管理这个文件。
不过，用创建和提交不同的分支仍是可行的。
不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。
不过虽然几乎可以是任意内容，和的数据却是有固定格式的。
不过，要是你觉得还不够，可以到服务器上的或频道寻求他人帮助。
不过要是存在太多松散对象,不在中的对象或，会进行调用命令。
不过要说清楚整个协作过程真的很难，如此灵活，人们的协作方式便可以各式各样，没有固定不变的范式可循，而每个项目的具体情况又多少会有些不同，比如说参与者的规模，所选择的工作流程，每个人的提交权限，以及以外贡献等等，都会影响到具体操作的细节。
不过请还是按照我之前讲的做，别学我这里偷懒的方式。
不过，运行该命令时需要确保工作目录的整洁。
不过这是什么意思呢？
不过这次不用在服务器上一个一个手工添加到文件末端，而只需管理目录中的公钥文件。
不过这里按自己项目的约定，可以略作变化。
不过非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。
不这么做的话会重写所有历史记录，花费不必要的更多时间。
不难想象，可以使用任何兼容的网页服务来运行；如果偏向使用其他服务器，配置也不会很麻烦。
不需要创建自己可写的公共仓库，也不用将自己的更新推送到自己的服务器，你只需将每次提交的差异内容以电子邮件的方式依次发送到邮件列表中即可。
与其他系统
与此同时，他们还有一个名为或的平行分支，专门用于后续的开发，或仅用于稳定性测试—当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到里。
专门用来配置或读取相应的工作环境变量。
世界不是完美的。
两次提交后，仓库历史会变成图的样子：
个人分支
个目录返回一个整型值。
中所有桥接命令的基础是。
中的分支，其实本质上仅仅是个指向对象的可变指针。
临时的特性分支可以让你随意尝试，进退自如。
为了上传数据至远端，使用和进程。
为了不出现这种问题，在把本地分支本例中的并入以后应该立即将其删除。
为了便于项目中的所有开发者分享代码，我们准备好了一台服务器存放远程仓库。
为了导入到一个目录，我们首先回顾一下储存数据的方式。
为了展示功能，先要一个具有写权限的仓库。
为了添加一个名为的用户，获取她的公钥，命名为，然后放到在你工作站上的克隆的目录。
为了演示拥有多个远程分支在不同的远程服务器上的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器。
为了演示这点，往仓库中加入一个大文件，然后在下次提交时将它删除，接着找到并将这个文件从仓库中永久删除。
为了演示，需要一个小脚本，接受文件名参数，得到项目的最新提交日期，最后把日期写入该文件。
为了理解分支的实现方式，我们需要回顾一下是如何储存数据的。
为了移除对一个大文件的引用，从最早包含该引用的对象开始之后的所有对象都会被重写。
为了绕开这个问题来满足，你需要让用取代：
为了给另一个用户添加项目的写权限，点击链接，出现一个用于输入用户名的表单。
为了解决该问题，可以运行，它会拉取服务器上所有最新的改变，在此基础上衍合你的修改：
为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异见图。
为了让所有的分支和标签都得到上传，我们使用这条命令：
为了设定客户端，我们要把环境变量到仓库：
为了达到这个目的，你可以增加挂钩。
为了退出脚本和拒绝此次推送，返回一个非零值。
为了避免麻烦，试着遵守如下守则：
为实现某个新的需求，创建一个分支。
为提供该文件可以让它更精确的映射作者数据。
为提高性能，若文件没有变化，不会再次保存，而只对上次保存的快照作一链接。
为此我们要建立一个名为的新段落，在其中罗列手机开发团队的开发者，以及他们拥有写权限的项目。
为直观起见，我们假设在工作目录中有三个文件，准备将它们暂存后提交。
为简单起见，在接下来的例子及本书随后的所有演示中，我都不会用这种格式，而使用选项提交。
为这次紧急修补建立一个新分支，并在其中修复问题。
为项目作贡献
主机上必须装有和工具该导入才能正常进行。
主目录即变量指定的目录，一般都是。
主要区别在于，合并操作发生在客户端而非服务器上。
举个例子，如果要浏览项目的历史更新摘要，不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看。
举例来说，你在你的项目上运行了,并且被定义为一个使用协议的。
举例说，如果你在更新分支，并且增加分支，这个将会是像这样：
之前介绍过，最容易的整合分支的方法是命令，它会把两个分支最新的快照和以及二者最新的共同祖先进行三方合并，合并的结果是产生一个新的提交对象。
之前我们已经合并了，所以在这里会看到它。
之前我们已经看到过了，它只显示最近的两条提交，实际上，这是选项的写法，其中的可以是任何自然数，表示仅显示最近的若干条提交。
之前我提到当存储数据内容时，同时会有一个文件头被存储起来。
之前的例子使用的是协议，不过你也可以用或者表示的传输协议。
之后，从下面的官方站点下载最新版本源代码：
之后创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象项目根目录的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。
之后评估一下有没有问题，最后再决定是不是真的要并入主干。
也具有简单的访问控制功能。
也可以为系统上所有用户都设置默认使用此脚本。
也可以加上选项译注：此为的简写，取首字母，显示对应的克隆地址：
也可以用来完成相同的操作。
也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：
也可以直接添加文件。
也可以运行来实现相同的效果，它的意思是“上传我本地的分支到远程仓库中去，仍旧称它为分支”。
也可能仅仅是因为你喜欢用挑拣，讨厌衍合。
也尝试推送自己的工作上去：
也就是说，你可以同时拥有多个开放的分支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。
也就是说，在其他人忍受古董的同时，你可以在本地享受分支合并，使暂存区域，衍合以及单项挑拣等等。
也就是说，如果我在上托管一个名为的项目的话，它的地址不会是，而是按在用户底下译注：本书作者在上的用户名是。
也就是说，如果现在提交更新，分支将随着开发进度前移。
也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。
也支持一个叫”个人分支“的功能或者叫,”个人分支命名空间“在合作环境里非常有用。
也是唯一一个同时支持读写操作的网络协议。
习惯了的人可能想以的风格显示历史，运行可以让提交历史显示为格式：
习惯了的工作流程以后，你可能会创建一些特性分支，完成相关的开发工作，然后合并他们。
事分两面，有好有坏。
事实上可以那样做。
事实上，本书就是放在上合作编著的。
于是，不得不先把的更新拉下来：
于是分布式版本控制系统，简称面世了。
于是创建了新的分支，继而编写代码：
于是，当你暂存文件时，程序会被触发，在把它们签出之前，程序会被触发。
于是，的分布式协作便可以衍生出种种不同的工作流程，我会在接下来的章节介绍几种常见的应用方式，并分别讨论各自的优缺点。
于是的本地仓库历史多出了的两次提交和，如图所示：
于是，的进度应用到的基础上，如图所示：
于是运行下载最新数据：
人们可以复制亦即克隆某个项目到自己的列表中，成为自己的公共仓库。
人们可以用这个校验你签名的所有标签。
人们在发布某个软件版本比如等等的时候，经常这么做。
什么是版本控制？我为什么要关心它呢？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。
什么是过滤器呢？其实就是使用程序，把文档转换成可读的文本文件，之后再进行比较：
仅仅忽略项目根目录下的文件，不包括
仅允许特定用户修改项目中的特定子目录
仅在提交信息后显示已修改的文件清单。
仅显示指定作者相关的提交。
仅显示指定提交者相关的提交。
仅显示指定时间之前的提交。
仅显示指定时间之后的提交。
仅显示最近的条提交
仅显示的前几个字符，而非所有的个字符。
仍保留着的几个对象是未被任何引用的──在此例中是你之前创建的,?和这两个示例。
仍需改进的特性可以先并入分支。
从你写的第一个开始：
从你的工作站拷贝你的公钥也就是你用默认生成的文件，重命名为我们这里使用作为例子。
从值可以看出大文件对象还在松散对象中，其实并没有消失，不过这没有关系，重要的是在再进行推送或复制，这个对象不会再传送出去。
从导入项目
从底层了解的工作原理可以帮助你更好地理解为何实现了目前的这些功能，也使你能够针对你的工作流写出自己的工具和脚本。
从技术上来说，能够读取格式的文件。
从概念上来讲，保存的数据如图所示。
从源代码安装
从现在开始，你会了解到一些类似以上但更为有趣的设置选项来自定义。
从现有仓库克隆
从这里开始，只要脚本存在并且可执行，我们的仓库永远都不会遭到回转或者包含不符合要求信息的提交内容，并且用户都被锁在了沙箱里面。
从远程仓库抓取数据
从远程分支出来的本地分支，称为跟踪分支。
从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。
他们只需要复制文件的内容然后发邮件给管理员。
他们对新的系统制订了若干目标：
他可以用来为你的项目环境设置合适的工作目录。
他可以用来在无法跟踪的工作树中恢复数据，诸如权限数据。
代码大致这样：
以一种类似文件系统但更简单的方式来存储内容。
以上介绍的是常见的分布式系统可以应用的工作流程，当然不止于。
以上只是简单介绍了一些命令支持的选项。
以上就是最简单的协作方式之一：先在自己的特性分支中工作一段时间，完成后合并到自己的分支；然后下载合并上的更新如果有的话，再推回远程服务器。
以上工作流程的时序如图所示：
以上的大部分内容应该都比较容易理解。
以上阐述的三层配置从一般到特殊层层推进，如果定义的值有冲突，以后面层中定义的为准，例如：在和的较量中，取得了胜利。
以下所列是目前为止样例中的所有对象，每个对象后面的注释里标明了它们保存的内容：
以图的历史为例，我们为了给服务器端代码添加一些功能而创建了特性分支，然后提交和。
以守护进程的形式运行该进程的方法有很多，但主要还得看用的是什么操作系统。
以对象类型为起始内容构造一个文件头，本例中是一个。
以项目为例，最新的可能是这个样子：
任何包含未解决冲突的文件都会以未合并的状态列出。
任何或非到参考或者其他或者不会被前两条规则匹配，即被第三条规则允许。
任何时候，你都有可能需要撤消刚才所做的某些操作。
任何时间运行命令可以查看当前的状态：
会不定时地自动运行称为的命令。
会使用作为分支的默认名字。
会使用进程，它会启动一个基于的连接到服务器。
会在有冲突的文件里加入冲突解决标记，这同合并或衍合操作一样。
会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。
会在服务器端自动合并提交上来的更新，而则必须先在本地合并后才能推送。
会将这些文件挪到文件中去以提高效率，该文件是这个样子的：
会忽略但不包括
会按照你需要自动为大部分的输出加上颜色，你能明确地规定哪些需要着色以及怎样着色，设置为来打开所有的默认终端着色。
会正确的记录每一个快照：
会递归删除当前目录及其子目录中所有结尾的文件。
传入参数可以让该命令输出数据内容的类型：
但不管哪种情形，协议的配置设定都很简单。
但不管哪种方式，起先我们总需要克隆原始仓库，而后创建特性分支开展工作。
但你不用事先到服务器上手工创建该项目的裸仓库—会在第一次遇到推送时自动创建：
但前提是要求贡献者有自己的服务器，而我们也需要为每个人建一个远程分支。
但在配置文件中有若干小改动，不过对用户来讲，使用方式都一样，不会有什么影响。
但多数项目都允许通过开发者邮件列表接受补丁，现在我们来看具体例子。
但如果你的语言设置不是英文，此处的文件夹字样会变为对应的语言。
但如果当这些文档包含编码，或者其他代码页，也可能无补于事。
但如果提交代码时有冲突，根本就不会让用户覆盖他人代码，它直接驳回第二个人的提交操作。
但如果用的话，差不多所有操作都需要连接网络。
但实际上手工修改文件权限可以绕过这个限制，只是完成后还是无法提交更新。
但无论如何，你可以使用命名空间来达到这个目的。
但无论是管理代码仓库，还是帮忙审核收到的补丁，都需要同贡献者约定某种长期可持续的工作方式。
但是你不能设置成以外的形式：
但是你可以先检查它的索引文件以确认。
但是，大部分的二进制文件不能表示为可读的文本，例如语音文件就很难转化为文本文件。
但是，我们怎么把二进制文件转化为文本呢？最好的解决方法是找到一个转换工具帮助我们进行转化。
但是还允许另外一种许可：，代表”拒绝“。
但是这里不能使用部分通配符，像这样就是不合法的：
但是通过挂钩的实现可以在旧版本的上工作，并且通过一定的修改它它可以做到只针对某些用户执行，或者更多以后可能用的到的规则。
但最有意思的是，可以定制要显示的记录格式，这样的输出便于后期编程提取分析，像这样：
但用的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到远程仓库。
但程序在这里没什么实际作用。
但若是用脚本程序来管理，或直接使用代码仓库托管服务，就可以简化此过程。
但若维护者合并或了你的工作，最后总还可以从他们的更新中同步这些代码。
但这么做很麻烦，所以提供了便捷的语法。
但这样做没有一点实际意义，因为运行命令后，你只能得到如下的结果：
但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。
但除外
但额外增加的工作量却微乎其微。
何谓分支
作为一个额外的防范措施，你可以用自带的工具限制用户的活动范围。
作为一套的文件系统，是一个非常强大的工具，而不仅仅只是一个供人使用。
作为最流行的开源版本控制系统，已经存在了接近十年的时间。
作为演示，假定每一条信息必须包含一条形似这样的字符串，因为我们需要把每一次提交和项目的问题追踪系统。
作为演示，我们可以设置用启动：
作了合并，但没有提交，它会停下来等你解决冲突。
作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针译注：即下图中的对象。
作者信息取自邮件头和，提交消息则取自以及正文中补丁之前的内容。
作者修订日期可以用选项定制格式
作者修订日期，按多久以前的方式显示
作者的名字
作者的电子邮件地址
你一定奇怪作者和提交者之间究竟有何差别，其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。
你不能直接比较两个不同版本的文件，除非进行手动扫描，不是吗？属性能很好地解决此问题，把下面的行加到文件：
你不需要访问，假设，，和一个兼容的服务器已经装好了。
你也可以使用来删除远程的引用，是通过运行这样的命令：
你也可以在命令行上指定多个像这样可以一次获取远程的多个分支：
你也可以在配置文件中指定多个如你想在每次获取时都获取和分支，就添加两行：
你也可以手动编辑这个文件，但是同样有一个更安全的方法可以这样做：。
你也可以扩展这个概念，先将所有新代码合并到临时特性分支，等到该分支稳定下来并通过测试后，再并入分支。
你也可以把这个字符串作为或者命令的目标，因为他们最终都依赖于一个简短的值，当然如果这个值失效他们也跟着失效。
你也可以用类似的方法建立一个压缩包，在加上选项：
你也可以设置的值：
你也可以通过提供只读的仓库，这意味着你可以加密传输内容；你甚至可以要求客户端使用特定签名的证书。
你也没有关于谁、何时以及为何保存了这些快照的信息。
你仍然可以得到带来的其他好处：离线提交，快速分支与合并等等，但工作流程还是差不多的。
你从没将他们添加至任何，所以认为它们是悬空的，不会将它们打包进。
你会发现，在它成功执行完毕以后，会给出一堆有关已完成工作的数据。
你会发现文件的尺寸大小发生了改变。
你会很少用到，在大多数情况下，如果你想在被重定向的输出中插入颜色码，你能传递标志给命令来迫使它这么做，应该是你的首选。
你会看到它被干净地应用到本地分支，并自动创建了新的提交对象。
你再一次简单跟随规则从上至下知道你找到一个匹配你的访问模式的，或者拒绝。
你刚刚已经重温过了的三个主要对象类型，现在这是第四种。
你刚刚通过使用低级操作而不是那些普通命令创建了一个历史。
你创建的本地分支不会因为你的写入操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。
你只需把一份裸仓库的副本放在大家都能访问的地方，然后像对其他共享目录一样设置读写权限就可以了。
你只需要在这个特殊仓库内做好相应的设定，然后推送到服务器上，就会随之改变运行策略，听起来就很酷，对吧？
你可以使用与相同的透过管道的方式，也可以通过后台来启动这个进程，它默认监听在号端口上。
你可以使用属性来有效地比较两个二进制文件，译注：指非文本文件。
你可以使用这个挂钩来禁止衍合已经推送的提交对象，挂钩样本就是这么做的。
你可以允许推送操作；然而由于没有授权机制，一旦允许该操作，网络上任何一个知道项目的人将都有推送权限。
你可以删除上次发布的版本并重新打标签，也可以像第二章所说的那样建立一个新的标签。
你可以告诉
你可以在之前使用一个号来重载这种行为。
你可以在目录下面找到这些包含值的文件。
你可以定义确切的人或一组人只能特定的或者或者而不是其他人。
你可以就此删除它，并在问题追踪系统里关闭该问题。
你可以建立一个空目录然后运行作为开头，然后运行该脚本：
你可以执行像这样的命令来查看完整的历史，但是这样你就要记得是你最后一次提交，这样才能在提交历史中找到这些对象。
你可以把作出的改变保持在特性分支中几分钟，几天甚至几个月，等它们成熟以后再合并，而不用在乎它们建立的顺序或者进度。
你可以把它的分享给每位对此项目感兴趣的人。
你可以控制许可在”“级别。
你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。
你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。
你可以用下面这条命令读取的值：
你可以用他来通知一个小组或获取的补丁的作者，但无法阻止打补丁的过程。
你可以用任何其他熟悉的语言来重写这个例子——它仅需要把必要的信息打印到标准输出而已。
你可以用属性让其知道哪些是二进制文件以防没有识别出来，以及指示怎样处理这些文件，这点很酷。
你可以用类似下面这样的命令建立一个：
你可以用自己的公钥执行命令，要是公钥不在服务器上，先临时复制一份：
你可以用这招维护不同层次的稳定性。
你可以用这条命令创建一个指向第二次提交的分支：
你可以用邮件客户端软件发送这些补丁文件，也可以直接在命令行发送。
你可以给出各种时间格式，比如说具体的某一天“”，或者是多久以前“”。
你可以给用户或者仓库分组。
你可以运行该脚本并把它的输出管道连接到。
你可以这样创建一个参数表明这是一个：
你可以选择其中的一种，或者结合起来，应用到你自己的项目中。
你可以随意地使用这些挂钩，下面会讲解其中一些。
你可用通过更改这个仓库以及推送到服务器上来管理你的配置。
你可能会想起之前我们使用后就运行了命令，开始跟踪当前目录下的文件。
你可能已经意识到了，这条命令有些危险，所有对文件的修改都没有了，因为我们刚刚把之前版本的文件复制过来重写了此文件。
你可能想到用将所有更新先变作单个提交，又或者想重新安排提交之间的差异补丁，以方便项目维护者审阅有关交互式衍合操作的细节见第六章。
你可能还记得，本质上是一个对象的链表，每一个对象指向一个内容的快照。
你学会了如何使用为项目做贡献，也学会了如何使用维护你的项目。
你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。
你将了解到的下一个被导入的系统是发行的时候同时也附带了一个导入脚本，不过它是包含在源码的部分——而不像那样默认可用。
你将会看到的第四种是远程引用，译者注。
你将在本章的第一部分学习使用，为附带的双向桥接工具。
你将在这部分了解到能在自己的项目中使用的属性，以及一些实例。
你将学习到如何从专业重量级的版本控制系统中导入数据——和——因为据我所知这二者的用户是向转换的主要群体，而且为此二者附带了高质量的转换工具。
你将看到如何通过脚本语言存储一个对象这里以字符串,?为例。
你就可以运行：
你已经见识过绝大多数通过自定义客户端和服务端来来适应自己工作流程和项目内容的方式了。
你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。
你时不时的需要进行一些清理工作──如减小一个仓库的大小，清理导入的库，或是恢复丢失的数据。
你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。
你正在工作的代码，可能会因为合并进来其他人的更新而变得过时，甚至受创无法运行。
你现在有三个对象，它们指向了你要跟踪的项目的不同快照，可是先前的问题依然存在：必须记往三个值以获得这些快照。
你甚至可以在后期对早先的某次提交加注标签。
你的磁盘上有了两个几乎完全相同的的对象。
你看到第行以开始，这在十六进制中表示，意味着第行有字节长。
你能报所有普通的东西放在一起，就像上面的对所有的规则那样，然后建一个特殊的规则对后面的特殊案例，就像：
你能用此脚本运行测试，检查工作树。
你能设置的颜色值如，正如以上例子设置的粗体属性，想要设置字体属性的话，可以选择如：、、、、。
你还可以在或者后面添加来阻止包含那些的附加信息。
你还能用这个方法比较图像文件。
你还需要一点`导入后`清理工作。
你需要一个文件来用一个简单的名字来记录这些值，这样你就可以用这些指针而不是原来的值去检索了。
你需要一个服务器上的账户；许多变种和都已经试过了。
你需要将本地更新推送到这个仓库。
使用一系列的配置文件来存储你定义的偏好，它首先会查找文件，该文件含有对系统上所有用户及他们所拥有的仓库都生效的配置值译注：是全局配置文件，如果传递选项给命令，会读写这个文件。
使用其他格式显示历史提交信息。
使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。
使用前缀的主要原因是当你需要一个不包含无关引用或对象的干净仓库副本的时候—一般指从其他版本控制系统导入的，或类似情形参见第章的维护任务。
使用协议的好处是易于架设。
使用另一个叫做的工具可以获得原始的提交数据。
使用命令可以方便快捷的制作一份修改日志，告诉大家上次发布之后又增加了哪些特性和修复了哪些。
使用命令应用补丁
使用命令开始跟踪一个新文件。
使用命令进入交互式模式：
使用图形化工具查阅提交历史
使用属性，你可以对个别文件或目录定义不同的合并策略，让知道怎样比较非文本文件，在你提交或签出前让过滤内容。
使用或的开发人员经常要求关键字扩展。
使用智能协议是传送数据的更常用的方法。
使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。
使用特性分支进行工作
使用的传输协议中最常见的可能就是了。
使用的好处有很多。
使用的标签有两种类型：轻量级的和含附注的。
使用的选项在第二章里简单的提过我们可以轻而易举的找出一次提交里修改的文件：
使用的选项执行删除操作：
使用算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个哈希值，作为指纹字符串。
使用衍合的原因是只有一个线性的历史而不像那样处理合并，所以在把快照转换为的时只能包含第一个祖先。
使用较短的相对时间显示比如，“”。
使用返回的结构来一一核对每一次提交修改的文件列表，就能找出该用户是否有权限推送所有的提交内容
使用这种技术还可以创造出新的命令，比方说取消暂存文件时的输入比较繁琐，可以自己设置一下：
使用远程分支的另外一个好处是能够得到提交历史。
例如，一些文本文件是由机器产生的，而且无法比较，而一些二进制文件可以比较—你将会了解到怎样让识别这些文件。
例如：你创建了一个模板文件，它看起来像这样：
例如，你可以添加一个叫做的然后把你的分支推送上去：
例如，你有一个数据库设置文件，在个分支中他们是不同的，你想合并一个分支到另一个，而不弄乱该数据库文件，可以设置属性如下：
例如，你要从公共代码仓库译注：，官方提供的代码寄存服务导入工程。
例如，在上的项目含有一个以结尾的文件，它是由记录设置项的写到磁盘的数据集纯文本数据类型。
例如，在子目录中有一些测试文件，在项目的压缩包中包含他们是没有意义的。
例如，在的源代码里，管理者添加了一个公钥这是一个对象对它做了一个标签。
例如，如果想在项目中包含一个叫作的文件，当运行时，最后提交日期自动地注入进该文件，可以这样设置：
例如：放入大的二进制文件、自动产生的文档或其他一切你不想纳入版本控制的文件。
例如，让输出的改变信息以粗体、蓝色前景和黑色背景的形式显示：
保存配置文件后，就能用命令把补丁作为邮件依次发送到指定的服务器上的文件夹中译注：这里就是的文件夹。
保持一个不包含由生成的的线性提交历史。
修改完之后，提交里的改动，并推送到服务器使其生效：
修改最后一次提交
值得一提的是可以自己裁决哪个共同祖先才是最佳合并基础；这和或以后的版本不同，它们需要开发者手工指定合并基础。
值得注意的是之前分支的修改内容尚未包含到中来。
值得注意的是，在操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。
值得注意的是它没有检出和转换到那个分支；如果现在进行提交，将提交到服务器上的，而非。
值得注意的是，每次添加一个新项目都需要通过登入主机并创建一个裸仓库目录。
值得注意的是，的使用流程也因此改变了——你可以在离线状态下进行多次提交然后一次性的推送到的服务器上。
值得注意的是，该工具分配命名空间时和远程引用的方式不尽相同。
值得注意的是这个对象指向你所标记的对象的值。
值得注意的是，这的的确确是架设一个少数人具有连接权的服务的全部—只要在服务器上加入可以用登录的帐号，然后把裸仓库放在大家都有读写权限的地方。
值得注意的是，除了协议外，其他所有协议都要求在服务器端安装并运行。
值得警戒的是，在使用的时候，你实际是在与交互，比它要高级复杂的多。
假如你和你的同事在一个项目中合作，他们想让你检出一些东西的时候，运行类似通常会比他们推送到服务器，而你再从服务器获取简单得多。
假如你正在上写程序，又或者你正在和其他人合作，他们在上编程，而你却在其他系统上，在这些情况下，你可能会遇到行尾结束符问题。
假如克隆了一个包含了属性的仓库，就有必要建立对应的文件来防止意外提交一些不应该提交的文件。
假如再次修改文件后暂存，然后编辑文件后先别暂存，运行命令将会看到：
假如前面这个方法更适用于你的数据，参考的帮助页面来了解如何以这种方式提供数据。
假如推送者同时向多个分支推送内容，只运行一次，相比之下则会为每一个更新的分支运行一次。
假如有人向一个文件推送了一些修改，这时你要向另一个文件推送一些修改，那么将正常工作：
假如有防火墙，则需要为该主机的端口设置为允许通信。
假如没有这些文件，或者干脆连目录都没有，可以用来创建。
假如编辑了一个文件并进行提交，那么这次提交仅存在于本地的而非服务器上。
假如这些工具都不适用，或者使用的工具很少见，抑或你需要导入过程具有更多可制定性，则应该使用。
假设一个域名为的服务器已经架设好，并可以通过访问，我们打算把所有仓库储存在目录下。
假设仓库中包含以下分支和标签：
假设仓库处于目录，主机上运行着服务。
假设你从一个中央服务器克隆然后在它的基础上搞了一些开发，提交历史类似图所示：
假设你们团队有个地址为的服务器。
假设你像这样添加了一项远程仓库：
假设你在进行一项工作，并且按时通过把工作目录复制为以时间戳命名的目录来进行备份，现在你需要把它们导入。
假设你并不知道这一点，要如何找出哪个些文件占用了这么多的空间？
假设你有一个类似图的工程。
假设你通过电邮收到了几个公钥并存到了临时文件里。
假设你需要添加一个使用访问权限控制列表的机制来指定哪些用户对项目的哪些部分有推送权限。
假设分支历史如下：创建一个分支，进行两次提交，然后合并到。
假设和一起负责开发某项特性，而同时和一起负责开发另一项功能。
假设在接下来的一次软件发布中，我们决定先把客户端的修改并到主线中，而暂缓并入服务端软件的修改因为还需要进一步测试。
假设此时，你想要在里再加条注释，重新编辑存盘后，准备好提交。
假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理：
假设补丁文件存在，可以这样运行：
假设项目管理员接纳了许多别人提交的补丁后，准备要采纳你提交的第一个分支，却发现因为代码基准不一致，合并工作无法正确干净地完成。
做法直截了当，克隆时用选项即可。
像上面的例子，对于打过的补丁我又再打一遍，自然会产生冲突，但因为加上了选项，所以它很聪明地告诉我，无需更新，原有的补丁已经应用。
像之前说的，暂存后再编辑，运行会看到暂存前后的两个版本：
像是怎么处理别人用生成的补丁，或是集成远端仓库上某个分支上的变化等等。
像这样的组可以随意创建，多少不限，每个都可以包含若干不同的用户和项目。
像这样随时保持自己的分支和官方同步，并将自己的工作限制在特性分支上的做法，既方便又灵活，采纳和丢弃都轻而易举。
允许你安排一个新许可模式允许用户创建仓库基于通配符，自动分配拥有权对特定用户创建者，允许他交出和许可给其他合作用户等等。
允许你定义带通配符的仓库其实还是正则式,比如随便整个例子的话。
允许你定义访问许可而不只作用于仓库，而同样于仓库中的每个和。
先打开的配置文件，添加以下四行：
先过一遍第一章中提到的配置细节。
克隆仓库的命令格式为。
克隆或者下载仓库内容可能会花费更多时间，而且传输的体积和网络开销比其他任何一个协议都大。
克隆普通的仓库时，可以以的形式获取远程服务器上所有可用的分支——分配到远程服务的名称下。
克隆生成本地仓库后，她打算先着手开发特性。
克隆的时候只需要将远程仓库的路径作为使用，比如下面这样：
全在这了。
公司使用典型的集成管理员式工作流，每个组都有一名管理员负责集成本组代码，及更新项目主仓库的分支。
公开的大型项目
公开的小型项目
公钥的样子大致如下：
公钥默认储存在账户的主目录下的目录。
关于在多个操作系统上设立相同公钥的教程，可以查阅上有关公钥的向导：。
关于就先介绍这么多，能够快速达成这些事情非常重要译注：门槛的降低和完成基本任务的简单高效，对于推动开源项目的协作发展有着举足轻重的意义。
关于，有两点需要注意。
关于版本控制
关键在于找出最新的的──你不大可能记住了这个，是吧？
关键是看有没有用和来命名的一对文件，这个通常就是或。
关闭服务时，只需在原来的命令后面加上选项就可以了：
其中最流行的一种叫做，现今许多计算机系统上都还看得到它的踪影。
其他功能
其他可用的模式有：表示可执行文件，表示符号链接。
其他客户端挂钩
其他用户访问该项目页面时只能看到之前那个公共的，看不到这个私有的。
其他的参数还有和，意味着不为输出着色，而则表明在任何情况下都要着色，即使命令被重定向到文件或管道。
其命令格式如同推送分支，运行即可：
其实操作基本上相当于加，所以这里出现的其实是的输出，先由它建立一个空目录，而之后传输数据对象的操作并无任何输出，只是悄悄在幕后执行。
其实，运行就相当于运行了下面三条命令：
其实，还有另外一个选择：你可以把在里产生的变化补丁在的基础上重新打一遍。
其次，它仅仅显示已经提交到服务器上的。
其次，架设相对比较简单—守护进程很常见，很多网络管理员都有一些使用经验，而且很多操作系统都自带了它或者相关的管理工具。
其输出如下：
其间的空行是必要的，以区分两者当然没有正文另当别论。
内容寻址文件系统层相当酷，在本章中我会先讲解这部分。
内核开源项目有着为数众广的参与者。
内部原理
再下一行是开始，表示服务器已完成了引用列表过程。
再将文件恢复到第一个版本：
再根据的第二个版本以及一个新文件创建一个新对象：
再次强调，这个命令一般什么都不干。
再次说明下，使用多个长期分支的做法并非必需，不过一般来说，对于特大型项目或特复杂的项目，这么做确实更容易管理。
再次，通过进行访问是安全的—所有数据传输都是加密和授权的。
再考虑另一种情形：管理员看过第二个分支后觉得思路新颖，但想请你改下具体实现。
再运行一次来确认所有冲突都已解决：
写得好可以让大家协作起来更轻松。
决断代码取舍
几乎每一种版本控制系统都以某种形式支持分支。
几条必要的命令就可以让全世界读取到仓库的内容。
几秒钟之后，你将进入新建的项目页面，会显示该项目派生自哪一个项目见图：
出乎意料的是，现在已经有了真实的历史了，所以如果运行命令并指定最后那个对象的便可以查看历史：
出于安全考虑，强烈建议用一个对仓库只有读取权限的用户身份来运行该进程—只需要简单地新建一个名为的用户译注：新建用户默认对仓库文件不具备写权限，但这取决于仓库目录的权限设定。
分布式工作流程
分布式版本控制系统
分支的新建与切换
分支的新建与合并
分组名就像一些宏；定义的时候，无所谓他们是工程还是用户；区别在于你使用“宏”的时候
切换分支的时候最好保持一个清洁的工作区域。
切换到之前实现新需求的分支，继续工作。
切换当前分支
列举新文件内容或者指明带有新内容的已修改文件的格式如下：
列出现有标签的命令非常简单，直接运行即可：
列显已有的标签
刚好在其中一家公司工作，所以接下来我们将会介绍如何在上建立新账户并启动项目。
刚才我们已经看到了这样的一个例子：`分支名远程名分支名`。
创建一个包装脚本，名字叫作，让它带参数调用二进制文件：
创建一个含附注类型的标签非常简单，用译注：取的首字母指定标签名字即可：
创建一个文件你也可以放到其他目录下，写入下面内容：
创建写该对象将暂存区域或状态写入到一个对象，然后瞧瞧它的样子：
创建新的分支
创建的分支可以用相关的主题关键字命名，比如或者其它类似的描述性词语，以帮助将来回忆。
初始化了目录，同时在该目录下创建了和子目录，但是该目录下没有其他常规文件。
初始化后，在当前目录下会出现一个名为的目录，所有需要的数据和资源都存放在这个目录中。
初始设定
初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。
初次运行前的配置
删除远程分支
利用分支进行开发的工作流程
利用此挂钩脚本可以实现类似保证最新的索引中不包含非类型的这类效果；抑或检查执行推送操作的用户拥有创建，删除或者推送的权限或者他是否对将要修改的每一个文件都有访问权限。
利用这种方式，项目总负责人即司令官可以把大量分散的集成工作委托给不同的小组负责人分别处理，最后再统筹起来，如此各人的职责清晰明确，也不易出错译注：此乃分而治之。
别人访问你的项目时看到的就是这个页面。
别看这个操作只花掉几分钟，要是你想把源仓库复制到另一个远程仓库，而不是本地仓库，那将花掉接近一个小时，尽管项目中只有不到次的提交。
整个项目组开始启用分布式版本控制系统来管理和维护代码。
到目前为止，你已经学会了如何创建、合并和删除分支。
到目前为止，你已经学会了最基本的本地操作：创建和克隆仓库，做出修改，暂存并提交这些修改，以及查看所有历史修改记录。
到目前为止，你应该已经学会了使用来完成日常工作。
到目前为止，你的过滤器已经设置完毕，可以开始测试了。
到目前为止，我阐述了基本的运作机制和使用方式，介绍了提供的许多工具来帮助你简单且有效地使用它。
到第二章的时候，我们会进一步了解其中细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。
到第章，我们会介绍如何手工导入复杂工程的具体方法。
到那个感兴趣的项目主页上，点击页面上方的按钮，就会为你复制一份该项目的副本到你的仓库中，这样你就可以向自己的这个副本推送数据了。
前面提过，使用作为换行字符而只接受。
剩下的文件是新创建的以及一个索引。
剩下的最后一项任务是指定只接受的推送。
副官将普通开发者的特性分支合并到自己的分支中。
加入以下内容：
加入你的目录里有前面使用过的文件，那么以下的脚本将把里面的规定执行起来：
务必确认对仓库只能读不能写。
包装脚本首先确定传递过来个参数，随后把其中个传递给包装脚本，默认情况下，传递以下参数给：
匹配模式最后跟反斜杠说明要忽略的是目录。
匿名的读取权限该怎么实现呢？也许除了内部私有的项目之外，你还需要托管一些开源项目。
协议不会占用过多服务器资源。
协议可能也是最难架设的协议。
协议是现存最快的传输协议。
协议消极的一面是缺少授权机制。
协议的消极面在于，相对来说客户端效率更低。
协议远比协议高效，因而访问速度也快，所以它能节省很多用户的时间。
即使仅为读取数据，人们也必须在能通过访问主机的前提下才能访问仓库，这使得不利于开源的项目。
即使内部创建并运行着自己的服务器，同时为开源项目提供一个公共托管站点还是有好处的—让开源社区更方便地找到该项目，并给予帮助。
即使还没打算进行提交，你也应该用这个命令从服务器拉取最新修改。
即便在已经删除的分支中的提交，或者用重新改写的提交，都可以被恢复关于数据恢复的内容见第九章。
即便如此，还是经常会有一些陈腔滥调提到早期的复杂又难学。
原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。
原来的看上去是这样：
参数指示命令存储数据对象，若不指定这个参数该命令仅仅返回键值。
又或者某人想修改一个自己不具备权限的文件然后推送了一个包含它的提交，他将看到类似的提示。
及更高版本还允许使用，效果是相同的，但更好记些。
反复运行并给所有人设定临时密码可不是好玩的。
发邮件给让他上来看看分支上的进展。
取得项目的仓库
取消对文件的修改
取消已经暂存的文件
变基也可以放到其他分支进行，并不一定非得根据分化之前的分支。
变基是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。
变基的风险
另一个例子是类似的关键字扩展。
另一个办法是让服务器通过某个服务，或者其他已经设定好的集中授权机制，来进行授权。
另一个引入代码的方法是挑拣。
另一个很重要的问题是该方法不一定就是最快的，尤其是对于共享挂载的文件系统。
另一个提供非授权访问的简单方法是开启一个守护进程，不过这将要求该进程作为后台进程常驻—接下来的这一节就要讨论这方面的细节。
另一个真正实用的选项是路径，如果只关心某些文件或者目录的历史提交，可以在选项的最后指定它们的路径。
另一个重要区别是获取被修改文件列表的方式。
另一种方法是通过电子邮件寄送文件补丁。
另一种是通过安装。
另外一种情况是，我们想把文件从仓库中删除亦即从暂存区域移除，但仍然希望保留在当前工作目录中。
另外两个网络协议和通常都是只读的，所以虽然二者对大多数人都可用，但执行写操作时还是需要。
另外也可以用参数后跟提交说明的方式，在一行命令中提交更新：
另外，你也一定希望合作者们即使在自己不开机的时候也能从仓库获取数据—拥有一个更稳定的公共仓库十分有用。
另外，你也可以在标签信息里写入一个操作向导，用户只需要运行查看标签信息，然后按照你的向导就能完成校验。
另外可以用查看尚未合并的工作：
另外，在源代码中有个文件，可以仔细读读，看看其它邮件程序的相关导引。
另外，如果你希望立即转到分支上去工作，可以用：
另外，我们还经常设置命令：
另外，提交说明应该用祈使现在式语态，比如，不要说成“”或“”而应该用“”。
另外请注意，是一个事务性操作的命令，也就是说，要么所有补丁都打上去，要么全部放弃。
另外还列出了所有处于跟踪状态中的远端分支。
另外，还提供了许多摘要选项可以用，比如，仅显示简要的增改行数统计：
另外还有，和可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。
另外还有四个重要的文件或目录：及文件，及目录。
另外还有按照时间作限制的选项，比如和。
另外，需要把目录的用户组设定为，这样服务才可以读取仓库内容，因为运行脚本的实例进程默认就是以该用户的身份起来的：
另起空行后，再进一步补充其他说明。
只允许特定用户修改项目重特定子目录的内容
只允许类型的推送
只允许纯推送
只显示中最后的行数修改添加移除统计。
只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。
只能保存单一的线性提交历史，一不小心就会被搞糊涂。
只要在打标签的时候跟上对应提交对象的校验和或前几位字符即可：
只要在“”这行下面的，就说明是已暂存状态。
只要把它们逐个追加到文件尾部即可：
只要把它设为用户登入的，那么该用户就无法使用普通的或者什么的程序。
只要把裸仓库复制过去：
只要每个人都能获得主机的访问权，任何可用的授权机制都能达到相同效果。
，只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。
只需要配置好一台中心服务器，并给每个人推送数据的权限，就可以开展工作了。
可以为了加速新开发者的克隆进程建立一个，但是不要向它提供任何不包含条目的内容。
可以以两种主要的方式跨越两个仓库传输数据：基于协议之上，和,,和等智能传输协议。
可以使用命令为一个单独文件──文件的第一个版本──　创建一个　。
可以使用命令查看相应标签的版本信息，并连同显示打标签时的提交对象。
可以使用四种主要的协议来传输数据：本地传输，协议，协议和协议。
可以使用标准的模式匹配。
可以使用系统的命令来实现该效果：
可以使用解压缩它，去除其头部，查看它的内容：
可以使用译注：取的首字母的方式验证已经签署的标签。
可以使用这个脚本确认提交信息是否被正确格式化，或让脚本编辑信息以达到标准化。
可以使用这样的条目列举式。
可以和提交模板配合使用，以编程的方式插入信息。
可以在中使用语句导入库，然后调用方法计算字符串的值：
可以在你提交时自动地把行结束符转换成，而在签出代码时把转换成。
可以在所有主流平台上运行，现在开始大胆尝试吧。
可以在服务器端实施策略来拒绝不符合某些策略的推送，但这完全取决于开发者在客户端使用这些脚本的情况。
可以在目录下看到一个文件。
可以将用来包含这些内容的数据想象成如图所示的样子。
可以往中添加更多内容并取回了。
可以手工运行命令：
可以把合并工具设置为：、、、、、、、。
可以查看一下，观察它是如何节省空间的。
可以理解，和等合并工具的输出信息。
可以用命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。
可以用命令将对象读到暂存区域中去。
可以用探测命令来查看所有引用的全名。
可以用第二章中提到的命令把它加为当前项目的远程分支之一。
可以直接用等网站提供的“”按钮自动发送请求通知；或手工把命令输出结果电邮给项目管理员。
可以看出，实际上只是简单地在命令中替换了你设置的别名。
可以看到我们已经补上了标签：
可以看到我们签出的两个，但没有更多的相关信息。
可以看到此文件包含类似下面这样的部分：
可以看到，该文件已经恢复到修改前的版本。
可以看到隔开的上半部分，是即分支，在运行命令时所切换到的分支中的内容，下半部分是在分支中的内容。
可以看到，默认的提交消息包含最后一次运行的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。
可以运行以查看使用了多少空间：
可以运行来同步远程服务器上的数据到本地。
可以这样查看的文件名：
可以这样验证这确实是一个对象：
可以通过底层命令来示范这点，传一些数据给该命令，它会将数据保存在目录并返回表示这些数据的键值。
可以通过来批量删除这些标识符：
可以通过运行以下命令来克隆代码：
可以随意散播这个，比如发布到个人网站之类的地方等等。
可用的选项包括，和后跟指定格式。
可能会花上一段时间。
可能你在以前的版本控制系统里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。
可能有点乱，我们不妨举例说明。
可能通过修改配置中的和来调整这两个阈值。
可要是在大公司里，或者大项目中，参与者可以多到上千，每天都会有十几个上百个补丁提交上来。
可选的号告诉在即使不能快速演进的情况下，也去强制更新它。
司令官与副官工作流
司令官将所有副官的分支并入自己的分支。
司令官将集成后的分支推送到共享仓库中，以便所有其他开发者以此为基础进行衍合。
司令官维护的仓库用于提供所有协作者拉取最新集成的项目代码。
各个集成管理员分别负责集成项目中的特定部分，所以称为副官。
合作团队中同时有人用和，一定要确保所有人都使用服务来协作——这会让生活轻松很多。
合并很顺利，但另外有个小问题：她要推送自己的分支到服务器上的分支上去。
同他人协作开发某个项目时，需要管理这些远程仓库，以便推送或拉取数据，分享各自的工作进展。
同传统的集中式版本控制系统不同，开发者之间的协作方式因着的分布式特性而变得更为灵活多样。
同大多数一样，也可以对某一时间点上的版本打上标签。
同时一并检查下分支，将足够稳定的特性也并入。
同时也是一个向使用私有仓库的用户收取费用的商业公司，但任何人都可以方便快捷地申请到一个免费账户，并在上面托管数量不限的开源项目。
同时也是一个验证授权的网络协议；而因为其普遍性，一般架设和使用都很容易。
同时，因为每次提交时都记录了祖先信息译注：即对象，将来要合并分支时，寻找恰当的合并基础译注：即共同祖先的工作其实已经自然而然地摆在那里了，所以实现起来非常容易。
同时，如果你在使用，这意味着你要特别留意不要在换行的时候引入回车符译注：，换行时加入的符号，通常说的——对仅使用换行符而非的回车符要求非常严格。
同时我们自己也不会希望建上百来个分支，却只从每个分支取一两个补丁。
同时指定了文件模式，值和文件名：
同时需要注意的是它并不是必须要指向一个对象；你可以标记任何对象。
同样，你可能猜到了，字头是一个便捷句法如果参考正则没有用开头。
同样，在回家的路上，不用连接你也可以继续工作。
同样，在这些分支里运行会获取所有远程索引，并把它们的数据都合并到本地分支中来。
同样，它不显示本地的提交以及上后来更新的内容。
同生活中的许多伟大事件一样，诞生于一个极富纷争大举创新的年代。
后仓库的大小减小到了，远小于之前的。
后台进程会检查这个命令是否可以运行，以及那个仓库是否存在，以及是否具有公开权限。
后面一种情况并不安全，因为所有代码仓库实例都储存在同一台电脑里，增加了灾难性数据损失的可能性。
后面可以列出文件或者目录的名字，也可以使用模式。
向服务器推送的命令是：
否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。
否则，满足任意一个条件的提交都会被匹配出来
含附注的标签
启动文本编辑器后，会看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才失误的提交。
告诉你哪个你访问过，那个访问可能是什么。
告诉该仓库遵循了基本的分支和标签命名法则。
命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单：
命令也可以更新，这是在本章前面的部分我们使用该命令而不是手工将值写入文件的理由。
命令依次创建补丁文件，并输出文件名。
命令只适用于有标注的标签通过或者选项创建的标签，所以发行版的标签都应该是带有标注的，以保证能够正确的执行。
命令可以显示出你所拥有的：
命令接受两个参数，第一个是本地特性分支开始前的原始分支，第二个是请求对方来抓取的仓库译注：即下面所指的，自己可写的公共仓库。
命令用于显示已打包的内容：
命令的选项也可以用这种方式自动完成，其实这种情况更实用些。
命令行居然没有发现命令的输出，其实，调用了刚刚设置的，它看起来像图这样：
命令输出内容的第三列显示的是对象大小，可以看到占用了空间，而仅为字节。
和上面一样，你可以通过命令单独设置每个参数，也可以在你的文件中的节点手动添加它们。
和其他版本控制系统一样，当某些重要事件发生时，以调用自定义脚本。
和其他版本控制系统的主要差别在于，只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。
和原来的不同，现在要用
和大多数的代码托管站点在处理项目命名空间的方式上略有不同。
和许多其他版本控制系统不同，鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。
咚！服务器上的分支没了。
唯一剩下的就是每一个快照的内容了。
唯一的差别就是，现在新建的目录成了，其他的都和上边的一样。
唯一需要的仅仅是切换回分支。
喔，你并不想往项目中加进一个这么大的包。
因为一旦暂存，就表示冲突已经解决。
因为不会为每次提交自动附加类似的递增序列，所以如果你想要得到一个便于理解的提交号可以运行命令。
因为仅仅是更新当前的文件，所以此命令不会自动生成提交对象，你得手工缓存相应文件的更新状态并执行提交命令。
因为任何一种不可逆的操作，比如删除数据，都会使回退或重现历史版本变得困难重重。
因为你没有直接更新主仓库分支的权限，得寻求其它方式把工作成果交给项目维护人。
因为你的起点是在文件中所提到的对象，你的开始操作就是获取它：
因为历史记录中引用了这个文件，它会一直存在着。
因为在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。
因为它一般只用到静态的服务提供所有数据，普通的服务器平均每秒能支撑数千个文件的并发访问—哪怕让一个小型服务器超载都很难。
因为它没有按需供应的能力—传输过程中没有服务端的动态计算—因而协议经常会被称为傻瓜协议。
因为扬抑符在命令行中表示续行译注：即下一行为这一行命令的继续。
因为数据是保存在目录下的，这样就没有了。
因为是放在最后位置上的选项，所以用两个短划线隔开之前的选项和后面限定的路径名。
因为每一次的提取操作，实际上都是一次对代码仓库的完整备份见图。
因为的格式是,通过把部分留空的方式，这个意思是是把远程的分支变成空，也就是删除它。
因为该仓库只是一个合作媒介，所以不需要从硬盘上取出最新版本的快照；仓库里存放的仅仅是的数据。
因为这些补丁中除了文件内容差异外，还包含了作者信息和提交消息。
因为这次你的开发历史是从更早的地方开始分叉的。
因此，你能写自己的过滤器，在提交文件到暂存区或签出文件时替换关键字。
因此，你能运行以下条配置命令：
因此，可以增加下面这行到属性文件中：
因此，可以有机会在提交作者看到默认信息前进行编辑。
因此，在方法中要做的第一件事就是根据目录名生成一个标记：
因此如果在目录下找不到一个引用，该引用可能存到文件中去了。
因此，更好的合作方式是建立一个大家都可以访问的共享仓库，从那里推送和拉取数据。
因此要创建一个对象的话首先要通过将一些文件暂存从而创建一个。
图一个简短的提交历史
图一次克隆会建立你自己的本地分支和远程分支，并且将它们都指向上的分支。
图上各个项目的概要信息
图上的项目主页
图不同流向的分支历史
图为分支合并自动识别出最佳的同源合并点。
图为项目添加协作者
图之后的提交历史
图从一个特性分支里再分出一个特性分支的历史。
图以后的提交历史
图你在本地有了一个指向服务器上分支的索引。
图你把相同的内容又合并了一遍，生成一个新的提交。
图保存每次更新时的文件快照
图克隆一个仓库，在其基础上工作一番。
图其他系统在每个版本中记录着各个文件的具体差异
图分布式版本控制系统
图分支其实就是从某个提交对象往回看的历史
图分支可以不受影响继续推进。
图分支是从分支所在点分化出来的
图分支的快进。
图分支随工作进展向前推进
图创建了一个新分支的指针
图包含分支引用的目录对象
图单个提交对象在仓库中的数据结构
图司令官与副官工作流
图合并之后，分支和分支指向同一位置。
图合并了和后的分支历史。
图合并后的仓库历史
图合并特性分支之后
图合并特性分支后的提交历史
图合并的更新后的提交历史
图命令会更新索引。
图团队间协作工作流程基本时序
图在一次之后移动到了另一个分支
图在上建立新仓库
图在你转换分支时指向新的分支
图在分支上变基分支。
图在本地工作的同时有人向远程仓库推送内容会让提交历史开始分流。
图在特性分支中提交更新后的提交历史
图多个分支指向提交数据的历史
图多个提交对象之间的链接关系
图多个特性分支
图多用户共享仓库协作方式的一般工作流程时序
图安装工具
图对象模型的简化版
图导入界面
图将特性分支上的另一个特性分支变基到其他分支。
图将特性并入长期分支
图展示了提交后的结果。
图工作目录，暂存区域，以及本地仓库
图当前数据的内容结构
图快进分支，使之包含分支的变化。
图想象成流水线可能会容易点。
图把另一个服务器加为远程仓库
图把里产生的改变到上重演一遍。
图抓取他人提交，并入自己主干。
图拥有多个特性分支的提交历史。
图指向当前所在的分支
图挑拣之前的历史
图挑拣之后的历史
图推送后的仓库历史
图推送数据后的提交历史
图提交到暂存区时，过滤器被触发。
图文件的状态变化周期
图新仓库指南
图显示了结果。
图最初分叉的提交历史。
图最终的提交历史
图有人推送了变基后得到的'，丢弃了你作为开发基础的和。
图服务简介页面
图本地版本控制系统
图每次提交后随着分支一起向前移动
图派生后得到的项目副本
图点击按钮获得任意项目的可写副本
图特性分支发布后
图特性分支合并前
图特性分支合并后
图用户注册表单
图用红框标出了用于合并的三个提交对象：
图的仓库历史
图的图形界面
图的提交历史
图的更新历史
图的用户面板
图的项目管理页面
图目录下的所有对象
图示意该命令的执行结果。
图稳定分支总是比较老旧。
图签出时，过滤器被触发。
图管理复杂的并行贡献
图自动创建了一个包含了合并结果的提交对象。
图获取的更新之后的提交历史
图通过合并一个分支来整合分叉了的历史。
图重新衍合后的提交历史
图集中化的版本控制系统
图集中式工作流
图集成管理员工作流
图项目协作者名单
图项目摘要中的公共和私有
在一个包含了合并历史的分支上使用可以成功运行，不过在项目的历史中，它没有重写你在分支中的两个——另一方面，这些改变却出现在了版本中同一个合并中。
在上安装
在上安装同样轻松，有个叫做的项目提供了安装包，可以到的页面上下载安装文件并运行：
在上安装有两种方式。
在上面这个例子中，运行：
在下一章你将学到更强大的工具来处理更加复杂的问题，之后你会变成一位大师。
在下面的例子里，实习生可以”“分支。
在下面的例子里，我们会用账户在进行。
在世界里许多代码交换通过”“请求发生。
在中，你无法在一个文件被提交后修改它，因为会先对该文件计算校验和。
在中，如果子目录不存在可以用函数创建它。
在中，它是一个指向你正在工作中的本地分支的指针译注：将想象为当前分支的别名。
在中的绝大多数操作都只需要访问本地文件和资源，不用连网。
在中这么用也决无问题，这就好比是在用或其他一样，可以很好地工作。
在主机上，可以用脚本达成。
在之后的表达式是正则表达式对应着后面的用的参考名字。
在任何规模的项目中都可以使用特性分支。
在你本地计算机上
在使用的过程中，有时会不小心丢失信息。
在保存到之前，所有数据都要进行内容的校验和计算，并将此结果作为数据的唯一标识和索引。
在保存和处理各种信息的时候，虽然操作起来的命令形式非常相近，但它与其他版本控制系统的做法颇为不同。
在克隆仓库时，通常会自动创建一个名为的分支来跟踪。
在克隆完某个项目后，至少可以看到一个名为的远程库，默认使用这个名字来标识你所克隆的原始仓库：
在列表完成时，再发送通知进程开始发送所需对象的打包文件。
在别人克隆该项目的时候，只能看到这个合并包含了所有发生过的修改；他们无法获知修改的作者和时间等提交信息。
在别的中，若还未提交更新，就有可能丢失或者混淆一些修改的内容，但在里，一旦提交快照之后就完全不用担心丢失数据，特别是养成定期推送到其他仓库的习惯的话。
在及之后的版本中，可以用一个宏代替：
在同一个服务器上，如果二者同时允许访问本地硬盘，通过访问仓库通常会比慢。
在后面可以指明要跟踪的文件或目录路径。
在多个补丁要打的情况下，这是个非常好的办法，一方面可以预览下补丁内容，同时也可以有选择性的接纳或跳过某些补丁。
在大部分的和下都有安装。
在完成了特性分支开发，提交给项目维护者之前，先到原始项目的页面上点击“”按钮，创建一个自己可写的公共仓库译注：即下面的部分，参照后续的例子，应该是。
在官方上的页面有一个最新的托管服务列表：
在实际打补丁之前，可以先用查看补丁是否能够干净顺利地应用到当前分支中：
在实际的开发工作中，你可能会遇到各种为了满足特定需求而有所变化的工作方式。
在工作目录中修改某些文件。
在工作目录中初始化新仓库
在开始学习的时候，请不要尝试把各种概念和其他版本控制系统诸如和等相比拟，否则容易混淆每个操作的实际意义。
在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。
在成功运行后，挂钩会被调用。
在我们之前提到的项目仓库中可以看到：
在或者更新版本里，只需要设定和选项就可以了。
在指南的最后有一个指向导入页面的链接。
在推送或从导入项目之后，你会看到一个类似图的项目主页：
在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用命令查看。
在提交和推送完成后，运行中的守护进程就会响应来自端口对该项目的访问请求。
在提交并推送过之后，就会自动开始显示项目的细节和历史。
在文件中，你能对特定的路径设置一个过滤器，然后设置处理文件的脚本，这些脚本会在文件签出前，见图和提交到暂存区前，见图被调用。
在文件中设置过滤器过滤文件：
在文件末尾，你应该能找到类似这样的行：
在新工程里首次推送数据到服务器前，得先设定该服务器地址为远程仓库。
在新版中可以用命令修改某个远程仓库在本地的简称，比如想把改成，可以这么运行：
在日常工作中我们经常这么用，既快且好。
在更新的版本中从版本开始，把设置为：
在有的系统上比如或者有的系统上比如体系，可以用下面的命令安装：
在服务端的时候使用了查看提交纪录的方式，可是目前的提交都还没被记录下来呢，所以这个列表只能从暂存区域获取。
在本书所展示的例子中，我们仅对保存着软件源代码的文本文件作版本控制管理，但实际上，你可以对任何类型的文件进行版本控制。
在本例中，你知道是哪个文件。
在本例中，我们使用了设定中常用的路径，不过你可以使用任何静态服务—把裸仓库放在它的目录里就行。
在本例中，指定了文件模式为，表明这是一个普通文件。
在本地尚未的数据不会出现在这里；其他人向服务器新提交的数据也不会显示。
在本章我们会学习什么是变基，如何使用变基，为什么变基操作如此富有魅力，以及我们应该在什么情况下使用变基。
在本章，我将会介绍的一些重要的配置方法和钩子机制以满足自定义的要求。
在本节中，我们应用前面学到的知识建立这样一个工作流程：检查提交信息的格式，只接受纯内容的推送，并且指定用户只能修改项目中的特定子目录。
在此之前，请一定要确认还有什么修改过的或新建的文件还没有过，否则提交的时候不会记录这些还没暂存起来的变化。
在此类系统中，签出时不会下载整个仓库历史，所以这种情形不大会有不良后果。
每个提交者在都在主机上有一个用户名，记录在提交信息中。
在版本之前，这些样本名都是正确的，但这些样本不是可执行文件。
在版本之后，这些样本名都是以结尾，因此，你必须重新命名。
在状态报告中可以看到新建的文件出现在下面。
在程序代码中进行单词层面的对比常常是没什么用的。
在第九章我们会详细说明刚才创建的目录中究竟有哪些文件，以及都起些什么作用。
在第二个括号中，我们看到了抛弃文件修改的命令至少在以及更高版本中会这样提示，如果你还在用老版本，我们强烈建议你升级，以获取最佳的用户体验，让我们试试看：
在第章中已经可以看到，可以以形式的简码在任何文件中放入字符串。
在等待他的反馈之前，决定继续工作，和一起开发上的特性。
在管理员完成集成工作后，主分支上便多出一个新的合并提交，用命令更新到本地后，提交历史如图所示：
在系统上，会找寻用户主目录下的文件。
在结束本章之前，我还想和大家分享一些使用的技巧和窍门。
在编辑过某些文件之后，将这些文件标为已修改。
在网站上使用得最多的就是这种工作流。
在自身项目仓库中，有着超过个标签，如果你只对系列的版本感兴趣，可以运行下面的命令：
在若干次提交后，你其实已经有了一个指向最后一次提交对象的分支，它在每次提交的时候都会自动向前移动。
在解决了所有文件里的所有冲突后，运行将把它们标记为已解决状态译注：实际上就是来一次快照保存到暂存区域。
在设置完成后，不重启计算机就启动该守护进程，可以运行：
在跟踪分支里输入，会自行推断应该向哪个服务器的哪个分支推送数据。
在输入命令的时候可以敲两次跳格键，就会看到列出所有匹配的可用命令建议：
在输入的同时，它会自动跳出一个符合条件的候选名单。
在运行命令之后，标签就会公布给所有人。
在这个例子中，分支因为不是一个可以快速演进的引用而拉取操作被拒绝。
在这个分支上开展工作。
在这个实例中，提交没有成功。
在这个目录下，应该有一个叫做的可执行脚本。
在这个项目里，这个目录还没不包含任何文件，但是包含这样一个简单的结构：
在这些情况，你可以尝试使用工具来获取其中的文字。
在这完成之后，由于下载开始时已探明引用是指向分支，会将它检出到工作目录。
在这时，通过传一个参数给，将一个已有的对象作为一个子读到暂存区域中：
在这类体系的系统上，可以用安装：
在这类系统中，像，，以及等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。
在这里，进程检查它自己所拥有的对象和所有它需要的对象，通过发送和所需对象的值，发送和所有它已拥有的对象的值。
在进行前需要将所有对这些的引用去除：
在进行单词层面的对比的时候，你可能希望上下文行数从默认的行，减为行，那么可以使用选项。
在进行变基的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。
在远端仓库有不同的方式启动进程。
在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。
在里有两级访问控制。
在里的文件名比如上面的应该跟你的不一样—会自动从使用脚本导入的公钥尾部的描述中获取该名字。
在里这种情况形似：
在里，这种操作叫做变基。
在问题相关的工作完成之后，可以合并回分支。
在集中式系统上，每个开发者就像是连接在集线器上的节点，彼此的工作方式大体相像。
在项目工作目录中输入命令后，就会启动图所示的界面。
在风格的中，可以使用本书中提及的复杂多行的命令。
基于之上传输通常被称为哑协议，这是因为它在服务端不需要有针对特有的代码。
基于文件仓库的优点在于它的简单，同时保留了现存文件的权限和网络访问权限。
基于网页的用户界面
基本上中的一个分支其实就是一个指向某个工作版本一条记录的指针或引用。
基本上，只要以守护进程的形式运行该命令即可：
基本上，只需要把的裸仓库文件放在的根目录下，配置一个特定的挂钩就可以搞定挂钩的细节见第章。
基本上就算是好了。
基本工作流程如下：
基本的变基操作
基本的工作流程如下：
基本类似命令，但它默认只输出值而已，没有其他信息。
处理来自客户端的推送操作时最先执行的脚本就是。
外部的合并与比较工具
多年以来，这已成为版本控制系统的标准做法见图。
多数操作仅添加数据
大型企业级防火墙通常会封锁这个少见的端口。
大多数时候，将所有接触到的项目全部转向是不可能的。
大多数服务器都会选择使用公钥来进行授权。
大部分情况下该命令什么都不处理。
大项目的合并流程
奇妙的变基也并非完美无缺，要用它得遵守一条准则：
她创建了并提交了三次更新。
她参与开发两项特性，同时和不同小组的开发者一起协作。
她用下载的最新代码：
她还没有下载提交的合并结果，所以提交历史如图所示：
好了，现在可以初始化了。
好了，现在可以请管理员抓取上的最新代码了，如图所示：
好了，现在已经准备妥当，可以试着将别人贡献的代码合并进来了。
好吧，我们来试试取消暂存文件
好吧，现在先把分支整个推上去
现在你已经创建了第一个提交！可以看到，提交后它会告诉你，当前是在哪个分支提交的，本次提交的完整校验和是什么，以及在本次提交中，有多少文件修订过，多少行添改和删改过。
现在请注意，接下来要讲的概念非常重要。
如你所见，这里并没有平常看到的添加行或者删除行的信息。
如你有一个组，他们推送一系列分支，你想每次获取分支和组的所有分支，你可以使用这样的配置段落：
如果一不小心搞错了配置，失去了推送权限，也可以手工修改服务器上的文件—实际是从该文件读取信息的。
如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的分支或任何其他存放稳定代码的分支，可以用这个非常无厘头的语法来删除它：`远程名分支名`。
如果不想用默认的合并工具为我默认选择了，因为我在上运行了该命令，你可以在上方里找到可用的合并工具列表，输入你想用的工具名。
如果不想经历自己架设服务器的麻烦，网络上有几个专业的仓库托管服务可供选择。
如果不指明用户，会默认使用当前登录的用户名连接服务器。
如果不考虑，单单起了守护进程的话，就必须到每一个允许匿名只读访问的仓库目录内，创建一个特殊名称的空文件作为标志：
如果不能直接提交更新，那该如何贡献自己的代码呢？是不是该有个什么策略？你每次贡献代码会有多少量？提交频率呢？
如果两个开发者从中心仓库克隆代码下来，同时作了一些修订，那么只有第一个开发者可以顺利地把数据推送到共享服务器。
如果从刚写入的新对象创建一个工作目录，将得到位于工作目录顶级的两个文件和一个名为的子目录，该子目录包含了文件的第一个版本。
如果他们想让每次运行时都这样自动推送，他们可以在配置文件中添加值：
如果你下载并安装了程序，可以用它参照元数据把图像转换成文本。
如果你不想在归档中包含一个子目录或文件，但想他们纳入项目的版本管理中，你能对应地设置属性。
如果你不想用到的所有功能，只是想用它来合并，那么正符合你的要求，运行：
如果你仅仅在公司网络里使用，可能是你唯一需要使用的协议。
如果你从其他系统导入了一个仓库，或是发觉一个仓库的尺寸远超出预计，可以用下面的方法找到并移除大尺寸对象。
如果你从这里克隆，会自动为你将此远程仓库命名为，并下载其中所有的数据，建立一个指向它的分支的指针，在本地命名为，但你无法在本地更改其数据。
如果你使用一个共享的文件系统，就可以在一个本地文件系统中克隆仓库，推送和获取。
如果你使用该挂钩来阅读作为第一个参数传递给的提交注释信息，并且与规定的模式作对比，你就可以使在提交注释信息不符合条件的情况下，拒绝执行提交。
如果你决定以维护者的身份给发行版签名，应该这样做：
如果你创建一个，会创建一个对象，然后写入一个指向它而不是直接指向的。
如果你只给出路径，会尝试使用硬链接或直接复制它所需要的文件。
如果你和同伴一起修复某个问题，但他们先推送了一个分支到远程仓库，虽然你可能也有一个本地的分支，但指向服务器上最新更新的却应该是分支。
如果你在删除一个引用，你会看到相反的：就是右边是全。
如果你在提供一个有很大访问量的公共项目，或者一个不需要对读操作进行授权的庞大项目，架设一个守护进程来供应仓库是个不错的选择。
如果你在本地分支做了些改动，与此同时，其他人向推送了他们的更新，那么服务器上的分支就会向前推进，而与此同时，你在本地的提交历史正朝向不同方向发展。
如果你在解决问题的过程中修改了中修改的部分，将得到类似下面的结果：
如果你太放松给了别人许可和其他孩子弄没了，记录文件会救你的命，如果其他简单快速的找到都不管用。
如果你完成了一个特性的开发，并决定将它引入到主干代码中，你可以转到那个特性分支然后执行衍合命令，好在你的主干分支上也可能是分支之类的重新提交这些修改。
如果你对架设自己的服务器没兴趣，可以跳到本章最后一节去看看如何申请一个代码托管服务的账户然后继续下一章，我们会在那里讨论分布式源码控制环境的林林总总。
如果你希望拉取到你的主干分支，可以这样：
如果你想从家里的笔记本电脑上推送，就要先挂载远程硬盘，这和基于网络连接的访问相比更加困难和缓慢。
如果你想用一个有图形界面的工具来解决这些问题，不妨运行，它会调用一个可视化的合并工具并引导你解决所有冲突：
如果你想让每次只拉取远程的分支，而不是远程的所有分支，你可以把这一行修改成这样：
如果你想配置子选项的话，可以参考帮助页。
如果你执行，就会更新这个文件，看起来像这样：
如果你把设置成译注：启动自动修正，那么在只有一个命令被模糊匹配到的情况下，会自动运行该命令。
如果你按照以上描述进行了操作，可以得到如图所示的对象图。
如果你提交并推送这个修改，四个用户将同时具有该项目的读写权限。
如果你是一个团队里唯一的用户，而其他队友不喜欢项目包含，该方法是你的不二之选。
如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本这或许是你非常渴望拥有的功能。
如果你是程序员，且正在开发仅运行在上的项目，可以设置取消此功能，把回车符记录在库中：
如果你有个叫的分支需要和他人一起开发，可以运行`远程仓库名分支名`：
如果你有以上版本的，还可以用选项简化：
如果你有其他偏好，比如的话，可以重新设置：
如果你有特定的策略要运用在提交信息上，在系统上创建一个模板文件，设置默认使用它，这样当提交时，你的策略每次都会被运用。
如果你有自己的私钥，还可以用来签署标签，只需要把之前的改为译注：取的首字母即可：
如果你添加了一个然后推送代码过去，会把你最后一次推送到这个的每个分支的值都记录在目录下。
如果你熟悉其他的比如，你可能已经注意到这里使用的是而不是。
如果你用的是，可以试试看提供的自动补全脚本。
如果你的主干译注：，相当于非分布式版本控制里的分支，代表开发的主线，分支或者标签以不同的方式命名，则应做出相应改变。
如果你的团队不是很大，或者大家都已经习惯了使用集中式工作流程，完全可以采用这种简单的模式。
如果你的团队已经有一个全体共享的文件系统，建立仓库就十分容易了。
如果你的工作流很复杂，有组推送的分支、开发人员推送的分支、和集成人员推送的分支，并且他们在远程分支上协作，你可以采用这种方式为他们创建各自的命名空间。
如果你的提交说明都用这样的格式来书写，好多事情就可以变得十分简单。
如果你的是你自己下载源码然后编译安装的，你会发现命令的输出和这个字符串差不多。
如果你的服务器没有启用，就无需配置最后那两行，并且应该以开头而不再是有的。
如果你的邮件客户端能将多封电邮导出为格式的文件，就可以用一次性应用所有导出的补丁。
如果你看一下这个文件，通常你将会看到这样的内容：
如果你确实需要更新一个引用，提供了一个安全的命令：
如果你自己写了些处理仓库信息的脚本的话，就可以用这种技术包装起来。
如果你要创建经签署的含附注的标签正如第二章所述，那么把你的签署密钥设置为配置项会更好，设置密钥如下：
如果你要备份或复制一个库，基本上将这一目录拷贝至其他地方就可以了。
如果你还记得的话,这个是文件的第一个版本，这个引用了这个，即该文件的第二个版本。
如果你透过使用获取功能，会像这样运行：
如果你通过接收由产生的补丁，这些挂钩也许对你有用。
如果你遇到这些情况，比较简单的解决方法是从这些二进制文件中获取元数据。
如果你遵循这条金科玉律，就不会出差错。
如果使用了，会调用它平时通过网络来传输数据的工序，而这种方式的效率相对较低。
如果做出的修改无法兼容但没有产生冲突，则可能造成一些很难确诊的难题。
如果先前的系统不是或之一，先上网找一下有没有与之对应的导入脚本——导入，，，甚至存档目录的导入脚本已经存在。
如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。
如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行提交：
如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项译注：即的首字母，以防误删除文件后丢失修改的内容。
如果到该项目目录中运行命令，并加上选项，那么会自动修改该仓库目录的组权限为可写译注：实际上可以指定其他行为，只是默认为将组权限改为可写并执行，所以最后会得到。
如果匹配被找到了，就成功了。
如果变基那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。
如果只完整保存其中一个，并保存另一个对象的差异内容，岂不更好？
如果只是临时合作，只需用命令抓取远程仓库上的数据，合并到本地临时分支就可以了。
如果只是想回退版本，同时保留刚才的修改以便将来继续工作，可以用下章介绍的和分支来处理，应该会更好些。
如果只是简单地从工作目录中手工删除文件，运行时就会在“”部分也就是未暂存清单看到：
如果合并到另一个分支，文件不会有合并冲突，显示如下：
如果，和都在注册了账户，要赋予他们对该仓库的推送权限，可以把他们加为项目协作者。
如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。
如果在一个刚刚打完标签的提交上运行命令，只会得到这次标定的版本号，而没有后面两项信息。
如果在一个或多个文件上设置了此字段，当下次你签出分支的时候，用的值替换那个字段。
如果在上安装了，默认使用的就已经配好了这个自动补全脚本，可以直接使用。
如果在不同的分支中都修改了同一个文件的同一部分，就无法干净地把两者合到一起译注：逻辑上说，这种问题只能由人来裁决。
如果在中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。
如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。
如果在克隆仓库之后立即执行此命令，会看到类似这样的输出：
如果在其他版本控制系统中保存了某项目的代码而后决定转而使用，那么该项目必须经历某种形式的迁移。
如果在刚导入一个仓库并在其他人在此基础上开始工作之前这么做，那没有什么问题──否则你不得不通知所有协作者贡献者去衍合你新修改的。
如果在开头明确使用，那么会以一种略微不同的方式运行。
如果在本地做了修改，则必须在运行之前或暂存工作，或暂时提交内容——否则，该命令会发现衍合的结果包含着冲突因而终止。
如果在网络内部运行该主机，并在中设定指向该主机，那么以下这些命令都是可用的：
如果在项目中替换了一个图像文件，运行命令的结果如下：
如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。
如果对已经被推送的提交历史做衍合，继而再推送，又或者以其它方式推送一个提交历史至远程分支，且该提交历史没在这个远程分支中，这样的推送会被拒绝。
如果对推送协议感兴趣，不妨打开这个地址看一下操作方法：。
如果已经有了一个所有开发成员都可以用访问的服务器，架设第一个服务器将变得异常简单，几乎什么都不用做正如上节中介绍的那样。
如果已经装好了，用下面的命令安装：
如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：
如果并在一起，这样的工具就可能会迷惑。
如果建在防火墙之外的服务器上，那么它所提供的服务应该只是那些公开的只读项目。
如果当前分支未包含该补丁的基础代码或其祖先，那么三方合并就会失败，所以该选项默认为关闭状态。
如果当前目录下有几个文件想要纳入版本控制，需要先用命令告诉开始对这些文件进行跟踪，然后提交：
如果必要，此处展开详尽阐述。
如果想允许对项目的匿名只读访问，那么除了为自己推送而架设协议之外，还需要支持其他协议以便他人访问读取。
如果想在服务器上删除分支，运行下面的命令：
如果想对某个开源项目出一份力，可以先把该项目的仓库复制一份出来，这就需要用到命令。
如果想尝试这个范例，你必须复制一份其中的测试仓库。
如果想把某个公共项目导入，可以帮忙。
如果想看当前分支同其他分支合并时的完整内容差异，有个小窍门：
如果想看看自己项目的效果，不妨用自带的一个命令，可以使用类似或这样轻量级的服务器启动一个临时进程。
如果想给将来看这次合并的人一些方便，可以修改该信息，提供更多合并细节。
如果想要一份自己的来开发，可以在远程分支的基础上分化出一个新的分支来：
如果想要创建一个新的引用帮助你记住最后一次提交，技术上你可以这样做：
如果想要看当前版本的文件和一个月前的版本之间有何差异，会取出一个月前的快照和当前文件作一次差异运算，而不用请求远程服务器来做这件事，或是把老版本的文件拉到本地来作比较。
如果想要集成新的代码进来，最好局限在特性分支上做。
如果想让只有读权限，可以这样做：
如果想让更智能地处理冲突，可以用选项进行三方合并。
如果想让这条信息更好的映射到作者数据里，则需要从用户名到作者的一个映射关系。
如果所有检查都通过了，它会启动这个进程并将客户端的请求移交给它。
如果把变基当成一种在推送之前清理提交历史的手段，而且仅仅变基那些尚未公开的提交对象，就没问题。
如果把此项指定为你系统上的一个文件，当你提交的时候，会默认使用该文件定义的内容。
如果指定选项，该命令显示所有未被其他对象引用指向的所有对象：
如果推送是通过进行的，还可以获取发出此次操作的用户。
如果提交了有空白问题的文件但还没推送到上游，你可以运行带有选项的来让在重写补丁时自动修正它们。
如果收到一个通过电邮发来的补丁，你应该先把它应用到特性分支上进行评估。
如果收到的补丁文件是用或由其它的命令生成，就该用命令来应用补丁。
如果方便，现在就可以提供你的公钥。
如果既要向远程服务器推送内容，又要推送到远程服务器，则必须先向推送，因为该操作会改变所提交的数据内容。
如果是从其他版本控制系统导入，则必须以变量的形式指明时区。
如果是克隆了一个仓库，此命令会自动将远程仓库归于名下。
如果是在主机上，通常都预装了，可以到项目目录中键入来启动。
如果是在防火墙之内的服务器上，可用于支撑大量参与人员或自动系统用于持续集成或编译的主机只读访问的项目，这样可以省去逐一配置公钥的麻烦。
如果是或，虽然可以编辑文件，但无法提交更新，因为数据库在网络上。
如果是格式描述的补丁，此命令还会相应地添加，删除，重命名文件。
如果是目录的话，就说明要递归跟踪该目录下的所有文件。
如果暂存该文件，之后再签出，你会发现关键字被替换了：
如果有,个左右的松散对象或是个以上的，才会真正调用命令。
如果有些什么遗漏，或测试没通过，脚本会以非零退出，放弃此次的运行，补丁不会被提交。
如果有人想要校验标签，他可以使用如下命令导入你的：
如果有人用给你发了一个补丁，你可以将此邮件下载到本地，然后运行命令来应用这个补丁。
如果有几个小组分头负责若干特性的开发和集成，那他们之间的协作过程是怎样的。
如果有多个远程仓库，此命令将全部列出。
如果有问题，除了报告错误信息之外，该命令还会返回一个非零的状态，所以在脚本里可用于检测状态。
如果有额外信息需要补充，但又不想放在提交消息中说明，可以编辑这些补丁文件，在第一个行之前添加说明，但不要修改下面的补丁正文，比如例子中的部分。
如果某个特性分支上有多个，但你只想引入其中之一就可以使用这种方法。
如果某个用户对目录有写权限，那他就有推送权限。
如果查看一下生成的，可以看到文件的对象的值：
如果正准备运用的补丁有特别的空白问题，你可以让发警告：
如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。
如果每个仓库都设有各自的段落，可以分别指定是否允许进程开放给用户匿名读取。
如果没有任何输出，表示我们可以顺利采纳该补丁。
如果没有给出该选项，会启动文本编辑软件供你输入标签说明。
如果没有，那这是一次纯的推送；如果有，那我们拒绝此次推送：
如果现在运行——修改包含以上内容文件的权限，然后尝试推送一个包含非类型的索引，会得到一下提示：
如果用了选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。
如果用的是，预装了，所以应该是最好的选择。
如果直接托管，虽然能免去这部分工作，但有时出于安全或版权的考虑，有些公司禁止将商业代码托管到第三方服务商。
如果真的要完全把这个对象删除，可以运行命令。
如果组成员想把他们的分支推送到远程的分支上，可以这样运行：
如果脚本以退出时返回非零值，只有相应的那一个索引会被拒绝；其余的依然会得到更新。
如果要一次推送所有本地新增的标签上去，可以使用选项：
如果要与其他开发者协作，总有那么一天你推送完毕之后，其他人发现他们推送自己修改的时候与你推送的内容产生冲突。
如果要为一个自己没有推送权限的项目贡献代码，鼓励使用派生。
如果要取消某人的访问权，点击即可取消他的推送权限。
如果要在上安装预编译好的二进制安装包，可以直接用系统提供的包管理工具。
如果要在某个特定的项目中使用其他名字或者电邮，只要去掉选项重新配置即可，新的设定保存在当前项目的文件里。
如果要把本地的分支推送到服务器上再次说明下，克隆操作会自动使用默认的和名字，可以运行下面的命令：
如果要把该远程分支的内容合并到当前分支，可以运行。
如果要用以外的程序来启动，可以通过选项指定：
如果要用向推送内容，那么最好是每次用衍合来并入一个单一分支，而不是直接合并。
如果视察一个变基过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。
如果觉得刚才对的修改完全没有必要，该如何取消修改，回到之前的状态也就是修改之前的版本呢？同样提示了具体的撤消方法，接着上面的例子，现在未暂存区域看起来像这样：
如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用来完成这次合并提交。
如果觉得这还不够，可以用选项将修改差异的每一行都包含到注释中来。
如果设备较少或者你只想在小型开发团队里尝试，那么一切都很简单。
如果设定所有操作都通过公匙授权的单一帐号比如＂＂进行，就有必要通过一个包装依据公匙来判断用户的身份，并且设定环境变量来表示该用户的身份。
如果设定过程没出什么差错，现在可以试一下用初始化的公钥的拥有者身份登录服务器，应该会看到类似下面这样：
如果设置了某个分支用于跟踪某个远端仓库的分支参见下节及第三章的内容，可以使用命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。
如果该挂钩脚本以非零退出，放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。
如果该脚本非零退出，放弃此补丁。
如果贡献者也用，且擅于制作补丁，那你的合并工作将会非常轻松。
如果贡献者将生成的补丁文件上传到类似一样的任务处理系统，那么可以先下载到本地，继而使用应用该补丁：
如果贡献者有自己的仓库，并将修改推送到此仓库中，那么当你拿到仓库的访问地址和对应分支的名称后，就可以加为远程分支，然后在本地进行合并。
如果运行了以上命令，没有设置和文件，会用做合并，让通常内设的比较工具来做比较。
如果这个脚本放在这个位置并且是可执行的,并且你的提交注释信息不是符合要求的，你会看到：
如果这二者不一样，则需要手动设置一下变量。
如果这些代码工作得很好，你就可以快进分支，得到一个线性的提交历史。
如果这真的发生了，有什么办法把丢失的找回来呢？
如果这返回了几个替代仓库列表，那么它会去那些地方检查松散格式对象和文件－这是一种在软件分叉之间共享对象以节省磁盘的好方法。
如果进入这个新建的目录，你会看到项目中的所有文件已经在里边了，准备好后续的开发和使用。
如果遇到意外问题，试试看把加到的段落译注：把日志设置为调试级别，记录更详细的运行信息。
如果遵循这些守则，在上工作还可以接受。
如果针对两个问题改动的是同一个文件，可以试试看的方式将部分内容置入暂存区域我们会在第六章再详细介绍。
如果需要为团队或者某个开源项目长期运行，那么脚本就要由正常的网页服务来运行。
如果需要仓库对特定的用户可读，而给另一部分用户读写权限，那么访问和许可的安排就比较困难。
如果需要同时在多个分支上提交，可以通过导入上某个其他分支的来建立以该分支为目的地的本地分支。
如果需要团队里的每个人都对仓库有写权限，又不能给每个人在服务器上建立账户，那么提供连接就是唯一的选择了。
如果需要对仓库进行更复杂的访问控制，只要使用服务器操作系统的本地文件访问许可机制就行了。
如果需要纳入此次修补，可以用把分支合并到；或者等完成之后，再将分支中的更新并入。
如果项目包含的仅仅是源代码的话这并没有什么坏处，毕竟可以非常高效地压缩此类数据。
如果项目很大，采用非标准结构，或者是私有的，那就无法借助该工具实现导入。
如果项目是开源的，整个庞大的开发者社区都可以立即访问它，提供各式各样的帮助和贡献。
如果项目的一个分支有歧义或比较特别，但你想从该分支合并，而且需要忽略其中某些文件，这样的合并策略是有用的。
如此一番后，有了两个提交要发到邮件列表。
如此分开操作，也会意识到这是一次改名，所以不管何种方式都一样。
如第一章所言，用配置，要做的第一件事就是设置名字和邮箱地址：
委托：真正的大安装，你可以把责任委托给一组仓库给不同的人然后让他们独立管理那些部分。
它不会从标准输入读取内容，而是接受三个参数：索引的名字分支，推送前索引指向的内容的值，以及用户试图推送内容的值。
它与和的相同点在于离线运行以及只更新到最后一次与服务器通信的状态。
它也是以字节指定后续字节长度的方式开始，然后是要运行的命令，和一个空字节，然后是服务端的主机名，再跟随一个最后的空字节。
它仅取出仓库的必要原始数据，存放在该目录中，而不会另外创建工作目录。
它从标准输入获取被推送引用的列表；如果它退出时的返回值不是，所有推送内容都不会被接受。
它们全是等价的，因为把它们都扩展成
它们全部都在这个你已经下载到的打包文件里面，所以你不用继续向服务端请求更多下载了。
它们既没有上次更新时的快照，也不在当前的暂存区域。
它们是一些无法移动的本地分支；只有在进行网络交互时才会更新。
它会恰如预期般正常工作。
它会显示还未合并进来的分支。
它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。
它使用与协议相同的数据传输机制，但省去了加密和授权的开销。
它做的第件事情就是获取文件。
它允许插入任意类型的内容，并会返回一个键值，通过该键值可以在任何时候再取出该内容。
它先要求你确认保存公钥的位置，然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。
它友善地告诉你如果是在分支，就可以用命令抓取数据合并到本地。
它告诉我们，运行时缺省推送的分支是什么译注：最后两行。
它在你的文件中添加了一节，指定了远程的名称,远程仓库的地址，和用于获取操作的
它在得到推送数据时，会把新的存到该路径上。
它在许多方面与十分类似，后者是前者出现之前代码控制世界的霸主。
它完全颠覆了传统版本控制的套路，并对各个环节的实现方式作了新的设计。
它将输出格式的日志——你可以找到作者，建立一个单独的列表，然后从中抽取出需要的信息。
它尝试像这样透过在服务端运行命令：
它就像是一个分支引用，但是不会变化——永远指向同一个，仅仅是提供一个更加友好的名字。
它把指针移回到分支，并把工作目录中的文件换成了分支所指向的快照内容。
它接受与相同的标准输入数据。
它是用写成的，基本上相当于命令的可视化版本，凡是可以用的选项也都能用在上。
它是用来保存元数据和对象数据库的地方。
它显示用户—初始化公钥的拥有者—是唯一能管理项目的人。
它有若干导航标签，标签用于显示提交历史，最新的提交位于最上方，这和命令的输出类似。
它的主要作用是将分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。
它的原理是回到两个分支最近的共同祖先，根据当前分支也就是要进行变基的分支后续的历次提交对象这里只有一个，生成一系列文件补丁，然后以基底分支也就是主干分支最后一个提交对象为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象'，从而改写的提交历史，使它成为分支的直接下游，如图所示：
它的工作原理基本上就是保存并管理文件补丁。
它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统见第三章，可以应付各种复杂的项目开发需求。
它获取一个所有即将重写的提交内容的列表，然后检查它们是否在远程的索引里已经存在。
它要求有单独的守护进程，需要定制—我们将在本章的“”一节详细介绍它的架设—需要设定或类似的程序，而这些工作就没那么轻松了。
它还显示了有哪些远端分支还没有同步到本地译注：第六行的分支，哪些已同步到本地的远端分支在远端服务器上已被删除译注：下面的两个分支，以及运行时将自动合并哪些分支译注：前四行中列出的和分支。
它首先提取某次提交的补丁，然后试着应用在当前分支上。
安装结束后，你切换到仓库放在你的目录然后看看都有啥：
安装非常简单,你甚至不用读自带的那一大堆文档。
完成安装之后，就可以使用命令行的工具已经自带了客户端了，另外还有一个图形界面的项目管理工具。
完成签名之后，如何分发公钥是个问题。
实现基于用户的访问权限控制列表系统
实现该函数的方法是建立一个目录的数组序列并使用数组的索引值作为标记，因为标记必须是一个整数。
实现这个任务的命令很简单：。
实际上，即便服务器的磁盘发生故障，用任何一个克隆出来的客户端都可以重建服务器上的仓库，回到当初克隆时的状态虽然可能会丢失某些服务器端的挂钩设置，但所有版本的数据仍旧还在，有关细节请参考第四章。
实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：
实际上我们真正想要看的，是新加入到特性分支的代码，也就是合并时会并入主干的代码。
实际上，所有保存在数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。
实际上，更像是把变化的文件作快照后，记录在一个微型的文件系统中。
实际上的显示比较简单，仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用命令。
实际上这个命令能够统计给定范围内的所有提交;假如你上一次发布的版本是，下面的命令将给出自从上次发布之后的所有提交的简介：
实际上，默认情况下命令本质上就是自动创建了本地的分支用于跟踪远程仓库中的分支假设远程仓库确实有分支。
实际操作同前面合并分支差不多，只需回到分支，运行命令指定要合并进来的分支：
客户端启动进程，连接至远端的进程，以协商后续数据传输过程。
客户端基本配置
客户端挂钩用于客户端的操作，如提交和合并。
对于一个包含成百上千次提交的项目，花掉的时间则可能是几小时甚至数天。
对于一次应用多个补丁时所用的格式文件，可以用命令的交互模式选项，这样就会在打每个补丁前停住，询问该如何操作：
对于任何一个文件，在内都只有三种状态：已提交，已修改和已暂存。
对于传统的命令生成的补丁，则只能用处理。
对于制作的新式补丁，应当使用命令。
对于向你展示的例子，在和系统上，我会使用路径名，在上，应该被改为你环境中的可执行路径。
对于命令，可以把加在原始分支拥有共同祖先和当前分支之间：
对于大型项目，至少需要维护两个长期分支和。
对于将来的项目，你可以从现有项目复制协作者名单，或者直接借用协作者群组。
对于提供公共的，非授权的只读访问，我们可以抛弃协议，改用自己的协议，这主要是出于性能和速度的考虑。
对于来说，库或推送的文件越大，这个操作代价就相对越高，每次推送会消耗更多时间，如果想在每次推送时都检查一致性，设置为来强迫它这么做：
对于那些需要在命令行中使用的用户，必须注意：在参数中间有空格的时候，必须使用双引号将参数括起来在中是单引号；另外，如果扬抑符^作为参数的结尾，并且作为这一行的最后一个字符，则这个参数也需要用双引号括起来。
对仓库进行操作，并查看占用了空间：
对修改后的文件进行快照，然后保存到暂存区域。
对象与之前的已经不同了。
对象为你保存了这些基本信息。
对象的格式很简单：指明了该时间点项目快照的顶层树对象、作者提交者信息从设置的和中获得以及当前时间戳、一个空行，以及提交注释信息。
对象非常像一个对象——包含一个标签，一组数据，一个消息和一个指针。
对非线性开发模式的强力支持允许上千个并行开发的分支
导入的仓库仿佛是有一个带有不同分支的远程服务器。
将会帮我们管理用户公钥，所以先把当前控制文件改名备份，以便稍后重新添加，准备好让自动管理文件：
将会返回一个字符串，由三部分组成：最近一次标定的版本号，加上自那次标定之后的提交次数，再加上一段所描述的提交的值：
将你之前用到过的库中的文件加进去──这个源代码文件大小约为：
将在主线分支外进行的开发通通衍合回主线；避免直接合并。
将文件头与原始数据内容拼接起来，并计算拼接后的新内容的校验和。
将此文件复制到你自己的用户主目录中译注：按照下面的示例，还应改名加上点：，并把下面一行内容添加到你的文件中：
尝试普通登录的话，会看到下面这样的拒绝信息：
就在下面，括号中有提示，可以使用的方式取消暂存。
就它了——一个干净整洁的仓库。
就此例而言，会用两个分支的末端和以及它们的共同祖先进行一次简单的三方合并计算。
就算原始主干发生变化，我们也能重新衍合提供新的补丁。
就算是这样也请尽可能利用暂存区域，将之前的改动分解为每次修复一个问题，再分别提交和加注说明。
尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。
尽管可以在本地随意的进行分支和合并，最好还是通过衍合保持线性的提交历史，尽量避免类似与远程仓库动态交互这样的操作。
尽管技术上可以从个人的仓库里推送和拉取修改内容，但我们不鼓励这样做，因为一不留心就很容易弄混其他人的进度。
尽管有数不尽的选项，但我只阐述其中经常使用或者会对你的工作流产生巨大影响的选项，如果你想观察你当前的能识别的选项列表，请运行
属性在导出项目归档时也能发挥作用。
属性提供了种方式这么做。
工作流挂钩
工作流程看起来就像图所示：
工作的很完美！
工具集合了若干个与类似的功能，对应的命令可以简化向的转化过程。
工具集在当前不得不使用服务器或者开发环境要求使用服务器的时候格外有用。
工程师可以任何有开头的，还有下面用开头的后面跟数字的。
差异分析工具
已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。
已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。
希望借助于你新学到的内部原理的知识，你可以实现自己的有趣的应用，并以更高级便利的方式使用。
带'拒绝'的高级访问控制
常用的操作大多仅仅是把数据添加到数据库。
并不会推断你输入的几个字符将会是哪条命令，不过如果想偷懒，少敲几个命令的字符，可以用为命令设置别名。
并不保存这些前后变化的差异数据。
并且可能的话，适当地分解为多次小更新，以便每次小型提交都更易于理解。
并入后的特性分支，已经无需保留分支索引，放心删除好了。
并用它的身份来启动进程。
幸好我们还可以选择应用广泛的项目。
应用实例包括给某邮件列表发信，通知实时整合数据的服务器，或者更新软件项目的问题追踪系统——甚至可以通过分析提交信息来决定某个问题是否应该被开启，修改或者关闭。
底层命令和高层命令
建立一个叫做的文件，用如下格式表示映射关系：
建立新仓库
开始分析特定用例之前，先来了解下如何撰写提交说明。
开始，在你的服务器上创建一个名为的用户，然后以这个用户登录。
开始架设服务器前，需要先把现有仓库导出为裸仓库—即一个不包含当前工作目录的仓库。
引用和分支主要区别在于他们是不能被的。
强制策略实例
当产生一个归档时，可以设置不导出某些文件和目录。
当从该挂钩返回非零值时，放弃此次提交，但可以用来忽略。
当仓库中有太多的松散对象，或是手工调用命令，或推送至远程服务器时，都会这样做。
当你再执行命令，它就创建了一个对象，把这个对象的父级设置为指向的引用的值。
当你在一个仓库下工作时，会在你每次修改了时悄悄地将改动记录下来。
当你在一个新目录或已有目录内执行时，会创建一个目录，几乎所有存储和操作的内容都位于该目录下。
当你在下载数据时，和进程就起作用了。
当你在使用分支及合并的时候，一切都是在你自己的仓库中进行的—完全不涉及与服务器的交互。
当你在设计这些过滤器时要注意，即使它们无法正常工作，也要让整个项目运作下去。
当你将或仓库转换导入至时这会成为一个很严重的问题。
当你抓取并合并这些数据到你本地的开发分支中后，会得到合并结果，历史提交会变成图这样：
当你提交或修改分支时，就会更新。
当你要看比较结果时，如果文件扩展名是，调用过滤器。
当你设法合并两个分支，结果却有冲突时，运行，会调用让你通过图形界面来解决冲突。
当你运行命令且为输出着色时，探测到这些问题，因此你也许在提交前能修复它们，当你用打补丁时同样也会从中受益。
当使用新建一个提交对象前，会先计算每一个子目录本例中就是项目根目录的校验和，然后在仓库中将这些目录保存为树对象。
当前，大多数开发中的开源项目以及大量的商业项目都使用来管理源码。
当前项目的目录中的配置文件也就是工作目录中的文件：这里的配置仅仅针对当前项目有效。
当我们来解决这个问题。
当更新一个引用时，不会修改这个文件，而是在下写入一个新文件。
当查找一个引用的时，首先在目录下查找，如果未找到则到文件中去查找。
当比较时，对文件运用一个过滤器，它能提炼出信息—大部分图像格式使用的元数据。
当然也可以手工运行命令来这么做。
当然也可以按照第一章介绍的方式，使用命令设定你喜欢的编辑软件。
当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。
当然你也可以直接推送到另一个新的分支上去，比如称作。
当然，你可以随心所欲地设定为其它跟踪分支，比如上除了之外的其它分支。
当然，先创建此分支，分叉点以服务器上的为起点：
当然，她可以使用冒号格式指定目标分支：
当然，如果需要，你随时可以用相同的命令修改已有的配置。
当然，得先切回主分支才能集成所有数据：
当然，我们并不鼓励你直接修改这些引用文件。
当然，普通的命令是不会这么做的。
当然，直接用轻便得多，不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。
当然，选择何种方式取决于你和贡献者的喜好。
当然，项目名称是必不可少的，此外也可以适当描述一下项目的情况或者给出官方站点的地址。
当运行命令时，会调用他们，因此，如果你没有在工作流中用到此命令，可以跳过本节。
当进行代码审查，或者快速浏览某个搭档提交的的变化的时候，这个参数就非常有用了。
当遇到有二进制文件需要转换的时候，你可以试试这个工具。
往磁盘保存对象时默认使用的格式叫松散对象格式。
很不错。
很多人对文档又恨又爱，如果想对其进行版本控制，你可以把文件加入到库中，每次修改后提交即可。
很多使用的开发者可能根本就没用过这些技巧，我们也不是说在读过本书后非得用这些技巧不可，但至少应该有所了解吧。
很容易找出哪些修改了这个文件：
循环遍历所有目录
必须重写从开始的所有才能将文件从历史中完全移除。
忽略所有结尾的文件
忽略某些文件
忽略目录下所有扩展名为的文件
忽略目录下的所有文件
怎么回事？文件出现了两次！一次算未暂存，一次算已暂存，这怎么可能呢？好吧，实际上只不过暂存了你运行命令时的版本，如果现在提交，那么提交的是添加注释前的版本，而非当前工作目录中的版本。
总之，该挂钩是作为通知之类使用的。
恭喜！你已经成为一名高效的开发者。
您也可以通过服务器发送补丁。
想了解的各式工具该怎么用，可以阅读它们的使用帮助，方法有三：
想保留历史记录，所花的时间应该不过就是从服务器拉取数据的时间可能要等上好一会就是了。
想要先和服务器上的数据同步，所以先下载数据：
想要具体到哪些命令输出需要被着色以及怎样着色或者的版本很老，你就要用到和具体命令有关的颜色配置选项，它们都能被置为、或：
想要撤消刚才的提交操作，可以使用选项重新提交：
意思是当通过向服务器推送时，将运行这个命令来更新匿名访问获取数据时所需要的文件。
成功且简洁地显示出我增加的文本。
我个人发现学习这些内容对于理解的用处和强大是非常重要的，不过也有人认为这些内容对于初学者来说可能难以理解且过于复杂。
我们不妨以作为用户及项目仓库所在的主机名。
我们从命令开始，它会把整个仓库导入到一个本地的仓库中。
我们从最简单的情况开始，一个私有项目，与你一起协作的还有另外一到两位开发者。
我们会先了解一些版本控制工具的历史背景，然后试着让在你的系统上跑起来，直到最后配置好，可以正常开始开发工作。
我们会在第三章详细讨论关于分支的概念和操作。
我们会在第五章再详细介绍两者之间的细微差别。
我们会在第四章详细介绍所有这些协议在服务器端该如何配置使用，以及各种方式之间的利弊。
我们作些修改后再次提交：
我们假设用来共享仓库的服务器已经安装了服务，而且你通过它访问服务器。
我们再来看一下仓库。
我们再看一个文件的例子：
我们创建一个紧急修补分支来开展工作，直到搞定见图：
我们创建了和这两个特性分支，在提交了若干更新后，把它们合并到主干分支，然后删除。
我们只需以当前分支为基准，开始一个新的特性分支，然后把原来的的更新拿过来，解决冲突，按要求重新实现部分代码，然后将此特性分支推送上去：
我们可以先把她的仓库加为远程仓库，然后抓取数据，完了再将她所说的分支检出到本地来测试：
我们可以创建一个名为的文件，列出要忽略的文件模式。
我们可以将其添加到命令的后面，从而获取单词层面上的对比。
我们可以手工定位它们的共同祖先，然后与之比较：
我们可以用命令来生成格式的文件然后作为附件发送。
我们可以用特定的搜索模式列出符合条件的标签。
我们可以直接把分支变基到，而不用手工切换到分支后再执行变基操作—`主分支特性分支`命令会先取出特性分支，然后在主分支上重演：
我们可以看到在提交对象信息上面，列出了此标签的提交者和提交时间，以及相应的标签说明。
我们可以通过命令查看某个远程仓库的详细信息，比如要看所克隆的仓库，可以运行：
我们在上节的例子里已经见过这种用法了。
我们在前文的小型安装一节介绍过生成新公钥的方法。
我们在每一个目录里运行，它会取出上一个快照的索引和标记并返回本次快照的索引和标记；由此我们就可以正确的把二者连接起来。
我们在这里描述最简单的安装方法，对于其他方法，请参考其文档。
我们将为每一个被挂钩拒之门外的索引受到一条远程信息，解释它被拒绝是因为一个挂钩的原因。
我们将依次进入每一个子目录并打印所需的命令来导出它们。
我们将写一个客户端脚本来提示开发人员他们推送的内容是否会被拒绝，以及一个服务端脚本来实际执行这些策略。
我们将在下一节“在服务器上部署”中讨论如何导出一个裸仓库的副本。
我们将在第七章讨论怎样改变环境中的默认值。
我们将在第九章了解到这些工具的细节；现在暂时先看一下这条命令的输出：
我们将在第九章进一步介绍部分的细节，不过一般使用的时候都可以省略它。
我们将在第六章介绍一些重写提交历史，同暂存区域交互的技巧和工具，以便最终得到一个干净有意义，且易于理解的提交历史。
我们将快速介绍一下手动安装的流程。
我们将把这个仓库称为服务器；代理一个仓库只需要花费很少的资源，几乎从不需要整个服务器来支持它的运行。
我们将需要计算快照之间的差别并且仅仅给出这项数据，不过该做法要复杂很多——还不如直接把所有数据丢给让它自己搞清楚。
我们差不多可以开始为导入脚本输出提交数据了。
我们常用选项展开显示每次提交的内容差异，用则仅显示最近的两次更新：
我们往这个数据库里存储一些文本：
我们忘了在提交“”后为此项目打上版本号，没关系，现在也能做。
我们所用的测试项目仅仅包含次提交并且它的代码量不算大，所以只有几分钟而已。
我们把它命名为，以便代替完整的以方便使用见图。
我们来看看补丁文件的内容：
我们现在转换到新建的分支：
我们用一些其他功能的例子结束这段讨论，这些以及其他功能都在,,和其他文档里。
我们用于处理文档的方法同样适用于处理创建的文本文档。
我们用`远程仓库名分支名`这样的形式表示远程分支。
我们的方法大致是：
我们的第一项任务是指定每一条提交信息都必须遵循某种特殊的格式。
我们称此为。
我们花些时间来看看是如何存储对象的。
我们要逐一检查每一条推送上来的提交内容，看看提交信息是否包含这么一个字符串，然后，如果该提交里不包含这个字符串，以非零返回值退出从而拒绝此次推送。
我们讨论并介绍了一些建立远程仓库的方法，接下来你可以通过这些仓库同他人分享或合作。
我们让挂钩检阅这些规则，审视推送的提交内容中需要修改的所有文件，然后决定执行推送的用户是否对所有这些文件都有权限。
我们还会展示如何让忽略某些文件，或是名称符合特定模式的文件；如何既快且容易地撤消犯下的小错误；如何浏览项目的更新历史，查看某两次更新之间的差异；以及如何从远程仓库拉数据下来或者推数据上去。
我们还将假定使用类似这样的标准发行版。
我们这里仅仅使用普通路径，这样更快。
我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。
我们采取一次处理一个快照的策略，为每一个内容目录建立对应的，每一个与之前的建立链接。
我们重用了前面定义过的，因为这里和指明提交注释的格式如出一辙。
我们随时都可以浏览这些帮助信息而无需连网。
我们需要写一个脚本来提取其中纯文本格式的内容。
我们首先要创建这个列表。
我想现在你应该已经清楚，接下来自己需要用哪种方式开展工作了。
或协议的优美之处在于架设的简便性。
或恢复到第二个版本：
或系统使用作为行结束符，因此你不想在签出文件时进行自动的转换；当一个以为行结束符的文件不小心被引入时你肯定想进行修正，把设置成来告诉在提交时把转换成，签出时不转换：
或者不指明某个协议—这时会默认使用：
或者因为要用一些自动化的服务器来进行编译，或者有一些经常变化的服务器群组，而又不想整天生成新的密钥—总之，你需要简单的匿名读取权限。
或者对此位置有访问权限
或者把它们想象成工作流水线，或许更好理解一些，经过测试的提交对象集合被遴选到更稳定的流水线见图。
或者直接编辑文件如下：
或者让在打上补丁前自动修正此问题：
或许你还记得第一章的内容，保存的不是文件差异或者变化量，而只是一系列文件快照。
或许对小型的配置来说最简单的办法就是运行一个静态服务，把它的根目录设定为仓库所在的位置，然后开启本章第一节提到的挂钩。
或许现在你已经在考虑将先前的项目转向。
截取这些输出内容，循环遍历其中每一个值，找出与之对应的提交信息，然后用正则表达式来测试该信息包含的格式话的内容。
所以一般我们运行，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。
所以一般来说，始终是在快进，偶尔做下衍合，而则是频繁衍合，如图所示：
所以不会出现命令那样，一部分文件打上了补丁而另一部分却没有，这样一种不上不下的修订状态。
所以从这些脚本中能找到相当多的这两种语言的挂钩样例。
所以任何时候你都可以马上翻阅，无需等待。
所以，会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新或是上次以来别人提交的更新。
所以，你可能失去的数据，仅限于没有提交过的，对来说它们就像从未存在过一样。
所以你所需要的对象肯定在某个打包文件中。
所以使用时的文件状态变化周期如图所示。
所以克隆项目仓库后会得到这四个分支，通过检出不同分支可以了解各自进展，或是试用前沿特性，或是贡献代码。
所以，准确地讲，我们应该比较特性分支和它同分支的共同祖先之间的差异。
所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。
所以如果你手工编辑该文件的话，它会一直保持到下次向推送新版本的配置内容为止。
所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，都能立即察觉。
所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。
所以总的来说，要比严谨许多。
所以我们叫它”参考正则“！当然，一个可以比这里表现的更强大，所以如果你对的正则表达式不熟的话就不要改过头。
所以，我们可以从文件所处的位置来判断状态：如果是目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。
所以接下来，我们准备抛弃原来的分支实际上会丢弃和，直接在主干中并入另外两个分支。
所以有时候你一下子暂存了所有更新过的文件后，运行后却什么也没有，就是这个原因。
所以，根据每次修订后的补丁，可以通过不断打补丁，计算出各个版本的文件内容。
所以此特性让的合并操作比其他系统都要简单不少。
所以，每次准备提交前，先用看下，是不是都已暂存起来了，然后再运行提交命令：
所以现在先打开文件，把这行：
所以究竟采取哪种方案，并不是个难以取舍的问题，或者其一，或者相互配合，哪种合适就用哪种。
所以要获取由值表示的从一次提交到另一次提交之间的所有值，可以运行：
所以，要跟踪文件，运行：
所以请鼓励贡献者用生成补丁。
所以，运行了之后又作了修订的文件，需要重新运行把最新版本重新暂存起来：
所以，这些脚本对开发者是有用的，由他们自己设置和维护，而且在任何时候都可以覆盖或修改这些脚本。
所有从脚本输出的提示都会发送到客户端，这点很重要。
所有以上这些问题都会或多或少影响到最终采用的工作流。
所有内容以或对象存储，其中对象对应于中的目录，对象则大致对应于或文件内容。
所有在原数据基础上提交的会一一提交到，然后你本地的将被重写，加入一个特别标识。
所有开发都在代表小组的分支上进行。
所有服务端的工作都在挂钩目录的更新脚本中制定。
所有的分支和标签现在都应该整齐干净的躺在新的服务器里了。
所有的合并都非常干净。
所有的命令都从它开始。
所有的对象都以这种方式存储，惟一的区别是类型不同──除了字符串，文件头起始内容还可以是或。
所有的开发者都是普通的节点，作为中心集线器的消费者，平时的工作就是和中心仓库同步数据见图。
所有的样本都是脚本，其中一些还包含了的脚本，不过，任何正确命名的可执行脚本都可以正常使用—可以用或，或其他。
所有空行或者以注释符号`＃`开头的行都会被忽略。
所有自带的样例脚本都是用或写的。
所谓的暂存区域只不过是个简单的文件，一般都放在目录中。
所谓的模式是指所使用的简化了的正则表达式。
手工调用命令让将库中对象打包并看会发生些什么：
打印导入所需的信息
打完所有补丁后，如果测试下来新特性可以正常工作，那就可以安心地将当前特性分支合并到长期分支中去了。
打开一个文件，在文件中输入关键字，然后设置属性：
打标签
打算支持协议的仓库，需要先创建文件—它是协议进程提供仓库服务的必要条件—但除此之外该服务没有什么安全措施。
托管服务
找到正确用户名之后，点按钮，把该用户设为项目协作者见图：
技巧和窍门
把一个分支中的修改整合到另一个分支的办法有两种：和。
把一个分支合并到另一个分支以后，你没法像在中那样轻易的回到那个分支上继续工作。
把一个正确命名且可执行的文件放入目录下的子目录中，可以激活该挂钩脚本，因此，之后他一直会被调用。
把下面这行添加到文件：
把他们当作是标记了这些分支在服务器上最后状态的一种书签。
把和变量的值传给一个叫做的命令可以获取所有提交内容的值列表。
把所有用户的公钥保存在文件的做法，只能凑和一阵子，当用户数量达到几百人的规模时，管理起来就会十分痛苦。
把改为或者用查看它的实际安装路径。
把新生成的公钥复制粘贴到文本框中即可。
把裸仓库移到服务器上
把该脚本命名为，放到正确的路径中，之后需要在中设置一个过滤器，让它在签出文件时调用，在暂存文件时用清除之：
把这一段放在脚本里，所有包含不符合指定规则的提交都会遭到拒绝。
拉取最新进展
挂钩在提交信息编辑器显示之前，默认信息被创建之后运行。
挂钩在整个提交过程完成后运行，他不会接收任何参数，但可以运行来获得最后的提交信息。
挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。
挂钩在衍合前运行，脚本以非零退出可以中止衍合的过程。
挂钩在键入提交信息前运行，被用来检查即将提交的快照，例如，检查是否有东西被遗漏，确认测试是否运行，以及检查代码。
挂钩接收一个参数，此参数是包含最近提交信息的临时文件的路径。
挂钩是做什么的呢？其内容大致如下：
挂钩都被存储在目录下的子目录中，即大部分项目中的。
指垃圾收集，此命令会做很多工作：收集所有松散对象并将它们存入，合并这些进一个大的，然后将不被任何引用并且已存在一段时间数月的对象删除。
指定从标准输入设备来读取内容，若不指定这个参数则需指定一个要存储的文件的路径。
指定提交信息格式
指定特殊的提交信息格式
指定运行诸如、等所使用的分页器，你能设置成用或者任何你喜欢的分页器默认用的是，当然你也可以什么都不用，设置空字符串：
按格式显示差异。
按补丁格式显示每个更新之间的差异。
挑拣类似于针对某次特定提交的衍合。
换作其他版本控制系统，这么做几乎不可能，抑或非常麻烦。
换句话说，不可能在你修改了文件或目录之后，一无所知。
换句话说，仅是从跟踪清单中删除。
换句话说，在本例中，你不会有一个新的分支，有的只是一个你无法移动的指针。
换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进。
换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。
换句话说，所有已跟踪文件在上次提交后都未被更改过。
接下去你会添加一些大文件以演示的一个很有意思的功能。
接下去来看对象，对象可以存储文件名，同时也允许存储一组文件。
接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统，简称应运而生。
接下来，从项目主页克隆并安装：
接下来会查找每个用户的文件，你能传递选项让读写该文件。
接下来，会根据每个补丁依次输出类似下面的日志：
接下来，你得进行紧急修补。
接下来便可以用查看更新了些什么：
接下来便是项目所采用的工作流。
接下来，发邮件给告诉她，他看了之后作了些修改，已经推回服务器分支，请她过目下。
接下来，只要配置各个项目在中的参数，便能达成是否允许用户浏览该项目。
接下来，可以将作出的修改推送到上游。
接下来，在配置文件中添加一个条目，把文档根目录设为项目所在的根目录。
接下来，如果之前把用户的登录改为命令的话，先恢复用户的登录。
接下来，对这些文件作些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。
接下来就可以建立新仓库了。
接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支，并指向服务器上所指向的版本：
接下来，我们会介绍一些基本的撤消操作相关的命令。
接下来，我们将学习的必杀技特性：分支模型。
接下来，我们必须告诉哪些仓库允许通过协议进行匿名只读访问。
接下来我们快速介绍一下的基本使用。
接下来，我们来学习一下作为项目贡献者，会有哪些常见的工作模式。
接下来我们要保证没有修改到允许范围之外的文件。
接下来，我们要学习下如何利用来组织和完成分布式工作流程。
接下来我们要看看如何维护项目，并成为一个合格的项目管理员，或是集成经理。
接下来，我会在一系列由简入繁的具体用例中，逐一阐述。
接下来我会演示如何通过的服务器发送。
接下来，把下面剩下的索引变成本地分支：
接下来，把开发者的公钥添加到这个用户的文件中。
接下来的两个小节将演示如何取消暂存区域中的文件，以及如何取消工作目录中已修改的文件。
接下来的例子会用我专门用于演示的项目，运行下面的命令获取该项目源代码：
接下来看看，我们为什么应该频繁使用分支。
接下来要将该文件从历史记录的所有中移除。
接下来要设置的是默认使用的文本编辑器。
接下来让我们继续学习的基础知识。
接下来，请将每次提交限定于完成一次逻辑功能。
接下来，那个推送上来的人决定用变基取代之前的合并操作；继而又用覆盖了服务器上的历史，得到'。
接下来，需要手工对该仓库中的脚本加上可执行权限：
接着你开始尝试修复问题，在提交了若干次更新后，分支的指针也会随着向前推进，因为它就是当前分支换句话说，当前的指针正指向，见图：
接着，假设引起丢失的原因并没有记录在中──可以通过删除和来模拟这种情况。
接着再写入另外两个对象，每一个都指定其之前的那个对象：
接着将分支移回至中间的一个：
接着，建立一个属于你自己的本地分支，始于上分支相同的位置，你可以就此开始工作见图：
接着往该文件中写入一些新内容并再次保存：
接着用方法打开文件，并用方法将之前压缩的内容写入该文件：
推送到服务器前调用的挂钩可以在任何时候以非零退出，拒绝推送，返回错误消息给客户端，还可以如你所愿设置足够复杂的推送策略。
推送数据到远程仓库
推送本地分支
提交备注必须以特定格式给出：
提交对象的完整哈希字串
提交对象的简短哈希字串
提交工作流挂钩
提交工作流的客户端挂钩脚本可以在任何工作流中使用，他们经常被用来实施某些策略，但值得注意的是，这些脚本在期间不会被传送。
提交日期，按多久以前的方式显示
提交时运行的命令擦除了全部有关哪个分支被并入的信息，因而以后的合并基础计算将是不正确的——让的结果变得类似于。
提交附加信息里最后一项所需的是提交者数据，我们在一个全局变量中直接定义之：
提供了一个叫做的工具译注：实际是命令，只不过可以通过加一个名字来呼叫此命令。
提供了一个跳过使用暂存区域的方式，只要在提交的时候，给加上选项，就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过步骤：
提供了一个通过发送补丁文件的工具。
提供了选项。
提醒一下，这里导入的是一个货真价实的仓库，所以应该把下面的换成你所用的仓库的：
搞定了用户权限的数据，下面需要找出哪些位置将要被提交的内容修改，从而确保试图推送的用户对这些位置有全部的权限。
撤消操作
支持许多数据传输协议。
改过之后，大家仍然无法通过该帐号登录译注：因为文件已经没有了。
数据库中已经将文件的两个新版本连同一开始的内容保存下来了：
整个工作流程类似上面的情形：为每个补丁创建独立的特性分支，而不同之处在于如何提交这些补丁。
整个流程看起来如图所示：
整个脚本大致如下：
整个过程看起来就像这样：
整体上的效果大致相当于：
文件出现在“”这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。
文件包含了刚才从文件系统中移除的所有对象。
文件包含了项目特有的配置选项，目录保存了一份不希望在文件中管理的忽略模式的全局可执行文件。
文件是一个指向你当前所在分支的引用标识符。
文件是用来设置用户、仓库和权限的控制文件。
文件模式是从常规的文件模式中参考来的，但是没有那么灵活──上述三种模式仅对中的文件有效虽然也有其他模式用于目录和子模块。
文件：用户目录下的配置文件只适用于该用户。
文件的三种状态
文件的下一行将是：
文件的命名将决定在中对用户的标识。
文件的格式规范如下：
文件：系统中对所有用户都普遍适用的配置。
文件补丁是一种特定格式的文本文件，记录着对应文件修订前后的内容变化。
文档实际上是多个文件包括一个文件和表格、图片等文件的压缩包。
新代码图中的将首先并入分支图中的，经过一个阶段，确认中的代码已稳定到可发行时，再将分支快进到稳定点图中的。
新增加的单词被括起来，被删除的单词被括起来。
新版本的不再使用目录，文件仅供程序使用，所以不用关心这些内容。
无论你创造出了什么样的工作流程，都能用的顺手。
无论是五次小提交还是混杂在一起的大提交，最终分支末端的项目快照应该还是一样的，但分解开来之后，更便于其他开发者复阅。
无需参数──如果目标不存在，调用会自动根据状态创建一个对象。
既然之前的工作成果已经合并到了，那么也就没用了。
既然如此，当你看到的命令时一定会困惑不已。
既然已经读到这了，就让我们开始吧。
既然是相互协作，在贡献代码的同时，也免不了要维护管理自己的项目。
既然服务器将给出无法推送非内容的提示，而且上面的挂钩也能阻止强制的推送，唯一剩下的潜在问题就是衍合一次已经推送过的提交内容。
早期的主要是之前版本的用户界面要比现在复杂得多，这是因为它更侧重于成为文件系统而不是一套更精致的。
时不时地将这些对象打包至一个叫的二进制文件以节省空间并提高效率。
时刻保持数据完整性
时区处于简化目的使用硬编码。
星号匹配零个或多个任意字符；匹配任何一个列在方括号中的字符这个例子要么匹配一个，要么匹配一个，要么匹配一个；问号`?`只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配比如表示匹配所有到的数字。
是一个公开的，只读的，任何人都可以通过它克隆该项目。
是一个基于协议的可读可写，只有使用与上传的公钥对应的密钥来连接时，才能通过它进行读写操作。
是一套内容寻址文件系统。
是不同于“服务”的软件其通过访问,而且每个在服务器上的都是一个潜在的“主机”。
是不是有点复杂？不过它的结果如图所示，非常酷译注：虽然里的,在之后，但这仅表明时间上的先后，而非在修改的基础上进一步改动，因为和这两个分支对应的代码应该是两套文件，虽然这么说不是很严格，但应理解为在时间点之后，对另外的文件所做的，修改，放到主干重演。
是以千字节为单位表示的的大小，因此已经使用了。
是在之上的一个授权层，依托或者来进行认证。
是如何做到这点的？打包对象时，会查找命名及尺寸相近的文件，并只保存文件不同版本之间的差异内容。
是时候动手尝试下了，不过得先安装好它。
是时候通知邮件列表里的朋友们来检验你的成果了。
是目前为止最大的开源托管服务，并且还是少数同时提供公共代码和私有代码托管服务的站点之一，所以你可以在上面同时保存开源和商业代码。
是集中式的，每个开发者都具有等同的写权限？项目是否有专人负责检查所有补丁？是不是所有补丁都做过同行复阅再通过审核的？你是否参与审核过程？如果使用副官系统，那你是不是限定于只能向此副官提交？
显然，使用别名的方式看起来更清楚。
显然，这不是我们所要的。
显示图形表示的分支合并历史。
显示新增、修改、删除的文件清单。
显示每次更新的文件修改统计信息。
显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。
显而易见，本方法要求主机上安装了，和然后把输出重定向到文件，然后就可以在每一项的后面添加相应的用户数据。
暂存已修改文件
暂存操作会对每一个文件计算校验和即第一章中提到的哈希字串，然后把当前版本的文件快照保存到仓库中使用类型的对象存储这些快照，并将校验和加入暂存区域：
更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的。
更多协议和其他协议效率上的差异见第章。
更多有关于的讨论和使用方式会在第九章作详细阐述。
更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。
最为重要的特性之一是名为的双向桥接工具。
最主要的区别就是对象指向一个而不是一个。
最后一个命令在服务器上创建了一个名为的仓库。
最后一点：
最后一项任务是检查确认推送内容中不包含非类型的索引，不过这个需求比较少见。
最后一项工作就是把新建的服务器添加为远程服务器并且向它推送。
最后一项工作是返回当前的标记以便下次循环的使用。
最后会查找由用户定义的各个库中目录下的配置文件，该文件中的值只对属主库有效。
最后，又回到分支提交了。
最后，和及本地协议一样，也很高效，会在传输之前尽可能压缩数据。
最后，回到你的工作站，执行。
最后，因为你清楚问题是从哪个开始的，使用重写自这个开始的所有历史记录。
最后，在命令成功执行后，挂钩会被调用。
最后在运行期间调用的是挂钩。
最后，她将的工作合并到自己的分支中：
最后，如果你不介意在他人服务器上保存你的代码，又想免去自己架设和维护服务器的麻烦，倒可以试试我们介绍的几个仓库托管服务。
最后将用压缩后的内容写入磁盘。
最后提交的时候，该文件就不再纳入版本管理了。
最后，服务端以成功或者失败来响应
最后，该命令还显示了当前所在的分支是，这是默认的分支名称，实际是可以修改的，现在先不用考虑。
最后还是去掉它：
最后还有协议。
最后需要谨记的是提交说明的撰写。
最后面的路径告诉守护进程允许开放给用户访问的仓库目录。
最坏的情况是彻底丢失整个项目的所有历史更改记录，而被客户端偶然提取出来的保存在本地的某些快照数据就成了恢复数据的希望。
最基本的就是本地协议，所谓的远程仓库在该协议中的表示，就是硬盘上的另一个目录。
最妙的是可以随时进行重新打包。
最容易的当属使用图形化的安装工具，界面如图，下载地址在：
最底下那个就是那个大文件：。
最终它将被推送回无法包含多个祖先的服务器上；因而在推送之后，它将变成一个包含了所有在其他分支上做出的改变的单一。
最终我们的提交历史会变成图的样子：
最终，的提交历史变为图所示：
最终的提交历史将变成图这样：
最起码的，应该清理一下创建的那些怪异的索引结构。
最起码，这也是一种新手立即体验尝试的捷径。
最近内核为了保证值的唯一性，将位数由位扩展到位，这就导致扩展之前的输出完全失效了。
最近几年改进了从而使它跟其他任何系统一样清晰易用。
有一个不错且免费的工具可以被用来做比较和合并工作，它就是译注：图形化合并工具，我会展示它的安装过程。
有一点很重要，需要记住，命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。
有两个有益于改善该问题的命令。
有两种取得项目仓库的方法。
有两种应用补丁的方法：或者。
有两组挂钩：客户端和服务器端。
有个可用的客户端挂钩用于工作流。
有个挂钩被用来处理提交的过程。
有了可以写入的仓库以后，就可以尝试一下典型的工作流程了。
有了可以开展工作的本地仓库以后，你可以开始对该项目做出贡献并向上游仓库提交内容了，这时相当于一个客户端。
有了命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。
有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态。
有了，我们就不需要同时发布这个补丁和里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。
有了整数来代表每个，我们现在需要提交附加信息中的日期。
有了裸仓库的副本后，剩下的就是把它放到服务器上并设定相关协议。
有些所谓智能的邮件客户端软件会自作主张帮你调整格式，所以粘贴补丁到邮件正文时，有可能会丢失换行符和若干空格。
有些版本自带的安装包更新起来并不及时，所以除非你在用最新的或者，那么从源代码安装其实该算是最佳选择。
有些贡献者提交代码补丁并不是很频繁，所以通过邮件接收补丁效率会更高。
有人把的分支模型称为“必杀技特性”，而正是因为它，将从版本控制系统家族里区分出来。
有何特别之处呢？的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。
有关推送数据到远程仓库的详细内容见第三章。
有后缀的文件就是公钥，另一个文件则是密钥。
有好几个办法可以让团队的每个人都有访问权。
有必要作些测试，确保修补是成功的，然后回到分支并把它合并进来，然后发布到生产服务器。
有意思的是运行命令前磁盘上的对象大小约为，而这个新生成的仅为大小。
有或没有向主项目提交更新的权限，结果完全不同，直接决定最终采用怎样的工作流。
有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。
有时候会看到重复的变量名，那就说明它们来自不同的配置文件比如和，不过最终实际采用的是最后一个。
有时候合并操作并不会如此顺利。
有时候图形化工具更容易展示历史提交的变化，随一同发布的就是这样一种工具。
有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。
有时候裁决冲突的理由并不直接或明显，有必要略加注解。
有时我们不得不为某个项目使用其他的版本控制系统,，其中比较常见的是。
有时，我们也会遇到打不上补丁的情况。
有种方便记忆这条命令的方法：记住我们不久前见过的`远程名本地分支远程分支`语法，如果省略`本地分支`，那就等于是在说“在这里提取空白然后把它变成`远程分支`”。
有种检查此类问题的方法，在提交之前，先运行，会把可能的多余白字符修正列出来。
有种过滤器，和。
有能力高效管理类似内核一样的超大规模项目速度和数据量
有许多客户端挂钩，以下把他们分为：提交工作流挂钩、电子邮件工作流挂钩及其他客户端挂钩。
有许多种安装方式，主要分为两种，一种是通过编译源代码来安装；另一种是使用为特定平台预编译好的安装包。
有许多过人之处，不过有一个功能有时却会带来问题：会将包含每一个文件的所有历史版本的整个项目下载下来。
有许多选项可以帮助你搜寻感兴趣的提交，接下来我们介绍些最常用的。
有趣的变基
有趣的是，用来添加用户和设定权限的并非通过网页程序，而只是管理一个特殊的仓库。
服务器信息
服务器端挂钩
服务器端挂钩用于服务器端的操作，如接收被推送的提交。
服务器端的配置选项并不多，但仍有一些饶有生趣的选项值得你一看。
服务器端配置
服务端挂钩
未跟踪的文件意味着在之前的快照提交中没有这些文件；不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，因而不用担心把临时文件什么的也归入版本管理。
本书前八章主要专门讨论高层命令。
本书讲解了使用,,等共约个命令。
本例中，为保持简洁，我们暂时只实现的规则译注：也就是省略了部分。
本例中，可以从找到丢失了的。
本例将使用方法来给用户授权。
本例的是。
本地仓库只有在你对数据访问速度快的时候才快。
本地版本控制系统
本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。
本次更新的简要描述个字符以内
本章上一小节已经展示了使用该挂钩核对提交信息是否符合特定的模式。
本章介绍开始使用前的相关知识。
本章基本上都讨论该目录下的内容。
本章将主要讨论底层命令以理解的内部工作机制、演示如何及为何要以这种方式工作。
本章将介绍几个最基本的，也是最常用的命令，以后绝大多数时间里用到的也就是这几个命令。
本章的第二部分将介绍如何将项目迁移到：先介绍从的迁移，然后是，最后介绍如何使用自定义的脚本进行非标准的导入。
本章第一节将介绍可用的协议以及各自优缺点。
本章覆盖了许多命令──这些命令比较底层，且比你在本书其他部分学到的命令要来得简单。
本节主要介绍了常见项目协作的工作流程，还有一些帮助处理这些工作的命令和工具。
本节作为的一个快速指南，指导基本的安装和设置。
本节将介绍中包含的一些针对常见系统的导入脚本，并将展示编写自定义的导入脚本的方法。
本节将回顾一些之前学过的命令，以看清将要合并到主干的是哪些代码，从而理解它们到底做了些什么，是否真的要并入。
本节将描述这类使用场景。
本节我们一起来学习如何列出所有可用的标签，如何新建标签，以及各种不同类型标签之间的差别。
本节我们将详细讨论远程库的管理和使用。
本质上我们刚才谈论的，是随着提交对象不断右移的指针。
来查看源代码仓库中的公钥也有一个不是指向对象的——第一个是在导入源代码的时候创建的，它指向初始，译者注。
来点更有趣的，你将把第一个对象作为一个子目录加进该中。
来看一个实际的例子：
来看一个实际的例子，如果要查看仓库中，年月期间，提交的但未合并的测试脚本位于项目的目录下的文件，可以用下面的查询命令：
来看下面的例子，有两个修改过的文件，我们想要分开提交，但不小心用全加到了暂存区域。
来看具体实例，采纳之前展示的那个电邮补丁后，最新的提交对象为：
来看看下面的例子：
来看看实际的效果
来看示例，假设当前代码库中有两个分支，分别为和，如图所示。
架设一台服务器并不难。
架设服务器
架设服务最复杂的地方在于账户管理。
某些大项目还会有个建议或，建议更新分支，它包含着那些可能还没有成熟到进入或的内容。
某些情况下，第一行的简要描述将用作邮件标题，其余部分作为邮件正文。
某些时候，单词层面的对比，比行层面的对比，更加容易观察。
某些用户具有全部的访问权，其他人只对某些子目录或者特定的文件具有推送权限。
查看一下目录，会发现大部分对象都不在了，与此同时出现了两个新文件：
查看已暂存和未暂存的更新
查看当前的远程库
查看提交历史
查看这个生成的，可以看到一些有趣的东西：
查看远程仓库信息
查看配置信息
标签允许你上传项目的二进制文件，提供下载该项目各个版本的包。
标签包含了一些可视化的项目信息与数据。
标签展示所有派生了该项目并做出贡献的用户的关系图谱。
标签提供了一个用于撰写文档或其他项目相关信息的站点。
标记是中对标识符的叫法；在创建的同时，我们逐一赋予一个标记以便以后在把它连接到其他时使用。
树对象的完整哈希字串
树对象的简短哈希字串
格式化与空白
格式化与空白是许多开发人员在协作时，特别是在跨平台情况下，遇到的令人头疼的细小问题。
检出远程分支
检查当前文件状态
检查是否有人在向他没有权限的地方推送内容
检查这一项的逻辑是看看提交里是否包含从旧版本里能找到但在新版本里却找不到的内容。
检视以下最后一个，你会找到新添加的译注：即本段开头所说的特别标识：
概念上来说，仓库中的各个对象保存的数据和相互关系看起来如图所示：
概括：认证是确定用户是谁，授权是决定该用户是否被允许做他想做的事情。
正准备推送自己的进展上去，却收到的来信，说是她已经将自己的工作推到服务器上的分支了。
正因如此我把这部分内容放在最后一章，你在学习过程中可以先阅读这部分，也可以晚点阅读这部分，这完全取决于你自己。
正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：
正如在第七章执行策略一例一节中一样，我们将使用来编写这个脚本，因为它是我日常使用的语言而且阅读起来简单一些。
正如我们在第二章所讨论的，有两种类型：和。
正如所见，没有冲突发生，仅是一次简单快进。
正如第二章所述，你能在项目库的文件里头用模式来定义那些无需纳入管理的文件，这样它们不会出现在未跟踪列表，也不会在你运行后被暂存。
此为注释–将被忽略
此例中，键入然后连按两次键，会看到两个相关的建议命令和。
此刻，她需要分享目前的进展给，于是她将自己的分支提交到服务器。
此刻，的本地仓库如图所示：
此后在实践时，应该可以借鉴这里的例子，略作调整，以满足实际需要构建自己的工作流。
此后，每个能访问仓库所在服务器上服务的人都可以进行克隆操作。
此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。
此命令会调用来验证签名，所以你需要有签署者的公钥，存放在中，才能验证：
此命令删除所有目录下扩展名为的文件。
此命令将使用当前的暂存区域快照提交。
此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。
此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪的新文件，否则会在这里列出来。
此外，你可能还需要忽略，或者目录，以及自动生成的文档等等。
此外，还会尝试找寻文件，只不过看当初装在什么目录，就以此作为根目录来定位。
此外还要考虑维护项目的总体步骤是什么。
此外限制用户改变到哪条的，你也可以限制哪个文件他们可以碰的到。
此时再运行命令，会看到文件已被跟踪，并处于暂存状态：
此时，在特性分支上的工作已经完成，但她想在推送数据之前，先确认下要并进来的数据究竟是什么，于是运行查看：
此时工作目录中的内容和你在解决问题之前一模一样，你可以集中精力进行紧急修补。
段落宽度限定在个字符以内。
每一个对象都指向了你创建的树对象快照。
每一个级别的配置都会覆盖上层的相同配置，所以里的配置会覆盖中的同名变量。
每一个里都有一个标识符。
每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。
每一行以字节的十六进制开始，用于指定整行的长度。
每个提交都会封装为一个后缀的文件，但其中只包含一封邮件，邮件标题就是提交消息译注：额外有前缀，看例子，邮件内容包含补丁正文和版本号。
每个提交都列出了修改过的文件，以及其中添加和移除的行数，并在最后列出所有增减行数小计。
每个条目间用一空行隔开。
每个选项都可用命令分别设置，当然直接编辑文件添加以下内容更便捷：
每个项目都有一个目录译注：如果出来的话，就是其中的目录；如果的话，新建的目录本身就是目录。
每当你执行`分支名称`这样的命令，基本上就是执行命令，把你现在所在分支中最后一次提交的值，添加到你要创建的分支的引用。
每当有人复制这个仓库去取得这个小项目时，都不得不复制所有数据，而这仅仅因为你曾经不小心加了个大文件。
每次只复制一次修改，把它推送到另一个仓库里，然后周而复始——惊人的低效，但是我们别无选择。
每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。
每次改删用户都必须登录服务器不去说，这种做法还缺少必要的权限管理—每个人都对所有项目拥有完整的读写权限。
比如，一个文档作者尝试推送一个修改到目录的提交，他会看到
比如一些大型日志文件或者一堆编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在文件中补上，用选项即可：
比如你可以通过把这段内容替换为下面这样来解决：
比如你想拥有一个并行维护的分支，可以运行
比如你都作了哪些改动，以及这么做的原因。
比如允许通过协议访问，可以把下面两行加到文件的末尾：
比如，发来一封邮件，说在她代码库中的分支上已经实现了某个非常棒的新功能，希望我们能帮忙测试一下。
比如,可能或者其他哪些程序真的不能被任何人做任何改动，因为好多东西都靠着它呢，或者如果某些改变刚好不对就会崩溃。
比如在下面展示的提交历史中：
比如在我的项目中，可以看到：
比如在特性分支上打了两个补丁，仅查看这两个补丁的提交信息，可以用选项指定要屏蔽的分支，这样就会剔除重复的提交历史：
比如，如果不连到服务器，几乎什么都做不了译注：默认无法发出命令开始编辑文件，因为需要联网通知系统声明该文件正在被谁修订。
比如我们想看看上次同仓库通讯时分支的样子，就应该查看分支。
比如新建一个分支，可以使用命令：
比如现在准备要给发一个，她之前在自己的特性分支上提交了两次更新，并把分支整个推到了服务器上，所以运行该命令会看到：
比如现在要开始第二项特性的开发，不要在原来已推送的特性分支上继续，还是按原始开始：
比如用将每个提交放在一行显示，这在提交数很大时非常有用。
比如用查看哪些分支已被并入当前分支译注：也就是说哪些分支是当前分支的直接上游。
比如碰上无法正常工作的补丁，可以先搁在那边，直到有时间仔细核查修复为止。
比如，要克隆语言的代码仓库，可以用下面的命令：
比如，要学习命令可以怎么用，运行：
比如要改用的话：
比如，要让项目在里出现，把的设定改成下面的样子：
比如说，要抓取所有有的，但本地仓库没有的信息，可以运行：
比如运行的时候忘了相关选项的名字，可以输入开头的几个字母，然后敲键看看有哪些匹配的：
比方在分支中某个文件里添了一行，然后运行上面的命令，简单的比较最新快照所得到的结论只能是，特性分支中删除了这一行。
比方说：
比方说，可以在那个上创建一个名为的分支：
比方说可以对一个文件进行简单的版本控制。
比较二进制文件
比较的不同结果将会用文本向你展示：
比较简单的做法是使用一个名为的工具。
注意之前用命令时候的名稱有读写权限而且在仓库里有一个同名的公钥文件。
注意到星号之前的反斜杠，因为有它自己的文件模式扩展匹配方式，所以我们不用来帮忙展开译注：实际上不加反斜杠也可以运行，只不过按照扩展的话，仅仅删除指定目录下的文件而不会递归匹配。
注意：如果你在用，一定记得添加一项额外的步骤。
注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的分支现在成了。
注意本例中通过导入的远程引用，的标签是当作远程分支添加的，而不是真正的标签。
注意，此时推送分支必须使用选项译注：表示，不作检查强制重写替换远程已有的分支，因为新的并非原来的后续更新。
注意：由于很多系统把每次修订看作一个到另一个的变化量，也可以依据每次提交获取一个命令来指出哪些文件被添加，删除或者修改过，以及修改的内容。
注意看分支前的字符：它表示当前所在的分支。
注意看，原本以开头的校验值在提交完成以后变成了。
注意，这不是提交对象的校验和，而是本身的校验和：
注意这是从脚本开头输出到标准你输出的。
注意，通过指定变量告诉编译命令仓库的位置。
添加协作开发者
添加完协作者之后，就可以在区域看到他们的名单见图：
添加，提交，然后推送更改。
添加用户很简单。
添加远程仓库
点击它会看到一个表单，包含有关导入流程的信息以及一个用来粘贴公共项目连接的文本框见图：
点击，按钮完成用户注册，并转到该用户的页面见图
点击用户面板上仓库旁边的链接，显示的表单见图：
点击项目页面上方的按钮或者顶部的标签，进入该项目的管理页面见图：
然后你取回了这个对象－这在服务端是一个松散格式的对象，你使用的是静态的请求获取的。
然后你就完成了！现在已经安装在了服务器上，在你的工作站上，你也有一个名为的新仓库。
然后，你应该去你到草稿箱去更改你要发送的补丁的收件人信息，以及需要抄送的人，然后发送它。
然后使用将此分支合并到自己分支中：
然后，允许所有用户修改——简单的做法是添加一个总是以作为返回值的脚本：
然后先把合并进主干，再合并，最后的提交历史如图所示。
然后再运行记录此次移除文件的操作：
然后又从的地方再增加一个分支来对客户端代码进行一些相应修改，所以提交了和。
然后可以用命令查看这个对象有多大：
然后呢，用户们就能在提交问题变得更难修正之前解除隐患。
然后在文件中设置过滤器：
然后在此项目中运行，应该会看到下面的输出：
然后在这个本地仓库内把添加为远程仓库，并推送分支上来：
然后，如果要把分支并入本地的分支，可以使用普通的。
然后，导出的内容并经由管道符传递给，之后钥匙会以类型写入中，最后返回这个量的值：
然后将此仓库添加为本地的第二个远端仓库，姑且称为：
然后就可以像在网络上一样向这个远程仓库推送和获取数据了。
然后就可以快进主干分支了：
然后当你提交时，在编辑器中显示的提交信息如下：
然后执行下面的命令：
然后把他们都加进团队，让他们对具有读写权限：
然后把它设为可执行文件
然后查看这个文件，你就会发现中的分支就是你最后一次和服务器的通信。
然后添加一个空格，接着是数据内容的长度，最后是一个空字节：
然后点击按钮，新仓库就建立起来了见图：
然后用查看已经暂存起来的变化：
然后编译并安装：
然后要看最后一次的提交信息，就变得简单多了：
然后，让时间检验一切，如果这些代码确实可以正常工作相当长一段时间，那就有理由相信它已经足够稳定，可以放心并入主干分支发布。
然后，设置以方式运行该脚本，添加一个配置：
然后通知项目管理员，让他来抓取你的代码。
然后，通过以下配置，让知道过滤器在遇到和时分别该做什么：
然后，针对其中每一项，找出它试图修改的文件然后确保执行推送的用户对这些文件具有权限。
然而，你可以在签出时注入文本，在提交前删除它。
然而假定不存在多个远程服务器，所以把所有指向远程服务的引用不加区分的保存下来。
然而，只是和几个人在一个不公开的项目上合作的话，仅仅是一个服务器和裸仓库就足够了，记住这点就可以了。
然而在中，一天之内建立、使用、合并再删除多个分支是常见的事。
然而在合作环境里，委任制的访问是‘绝不’，一个开发者工作站不能认证，你必须到中心服务器并且叫其他人从那里。
然而，在这个例子中，没有替代仓库。
然而，如果你想用项目库之外的文件来定义那些需被忽略的文件的话，用通知该文件所处的位置，文件内容和类似。
然而如果你的提交注释信息是符合要求的，会允许你提交：
然而，如果想与他人合作，还需要一个远程的仓库。
然而，如果想删除这些标识符，现在正是时候——在开启新仓库之前。
然而，如果能迁徙到真正的服务器，则能为团队带来更多好处。
然而由于一开始被设计成供使用的工具集而不是一整套用户友好的，它还包含了许多底层命令，这些命令用于以风格使用或由脚本调用。
然而，这是个不错的练习而且理论上能帮助用户避免一次将来不得不折回来修改的衍合操作。
然而，这样的导入并不完美；而且还要花那么多时间，不如干脆一次把它做对！首当其冲的任务是作者信息。
然而，这样的显示结果没有多大的实际意义。
父对象的完整哈希字串
父对象的简短哈希字串
版本引进了此项配置，如果你拥有的版本更老，你必须对颜色有关选项各自进行详细地设置。
特别是，当作为项目贡献者时，我们该怎么做才能方便维护者采纳更新；或者作为项目维护者时，又该怎样有效管理大量贡献者的提交。
现在两个文件都已暂存，下次提交时就会一并记录到仓库。
现在，、两个特性分支各不相扰，如同竹筒里的两颗豆子，队列中的两个补丁，你随时都可以分别从头写过，或者衍合，或者修改，而不用担心特性代码的交叉混杂。
现在从当前主干分支为基础，新建临时分支：
现在，仓库中有五个对象：三个表示文件快照内容的对象；一个记录着目录树内容及其中各个文件对应对象索引的对象；以及一个包含指向对象根目录的索引和其他提交信息元数据的对象。
现在会使用来做比较、合并和解决冲突。
现在会在每次推送生效前检查库的完整性，确保有问题的客户端没有引入破坏性的数据。
现在，会尝试转换和修正回车换行问题，也不会当你在项目中运行或时，比较不同的内容。
现在你也有了这个对象，你可以继续在对象上漫游。
现在，你做出的修改都发生在服务器最新内容之后，所以可以顺利的运行：
现在，你决定要修补问题追踪系统上的问题。
现在，你可以删除这个特性分支并丢弃你不想引入的那些。
现在你可以用来获取小组服务器上你还没有的数据了。
现在你可以运行命令检查这个值：
现在，你就可以在命令中使用你刚才创建的引用而不是值：
现在你就接到了那个网站问题的紧急电话，需要马上修补。
现在你应该对可以作什么相当了解了，并且在一定程度上也知道了是如何实现的。
现在你有一个远端引用和值的列表。
现在你有了一个压缩包和一个压缩包，可以把他们上传到你网站上或者用发给别人。
现在，你有了一个有效的仓库，包含着导入的分支和标签：
现在你有了这个打包文件的索引，你可以看看你要的对象是否在里面－因为索引文件列出了这个打包文件所包含的所有对象的值，和该对象存在于打包文件中的偏移量，所以你只需要简单地获取整个打包文件：
现在你的历史看起来像图
现在你的已经包含了这个的内容了，可以通过不同的值指定不同的来创建标签。
现在，你的数据库应该看起来像图一样。
现在你的本地分支会自动将推送和抓取数据的位置定位到了。
现在你的用户没法推送带有不正确的提交信息的内容，也不能在准许他们访问范围之外的位置做出修改。
现在你能够签署标签，从而不必每次运行命令时定义密钥：
现在，假定两件事情：我们最终决定使用第二个解决方案，即中的办法；另外，我们把分支拿给同事们看了以后，发现它竟然是个天才之作。
现在，其他人克隆共享仓库或拉取数据同步后，也会看到这些标签。
现在再运行会看到对应的签名也附在其内：
现在历史记录中已经不包含对那个文件的引用了。
现在去目录运行一下，就能看到导入的成果：
现在可以克隆和获取更新，但不会允许他向项目推送任何内容。
现在可以发布一个新的版本了。
现在，可以将特性分支上的工作并到分支，然后再并入的工作到自己的分支，最后再推送回服务器。
现在可以快进分支了见图：
现在可以查看到已经存储了数据：
现在可以用命令将暂存区域的内容写到一个对象了。
现在可以用字符串指代对应的仓库地址了。
现在可以用选项运行来建立一个裸仓库，这会初始化一个不包含工作目录的仓库。
现在可以调用加目标仓库，再加源仓库的格式来把该项目同步到本地了：
现在可以运行来检视新的历史：
现在命令就可以显示文件的变更了。
现在和分支的变化都已经集成到主干分支来了，可以删掉它们了。
现在，，和通知集成管理员服务器上的及分支已经准备好，可以并入主线了。
现在回到之前未完成的问题修复分支上继续工作图：
现在回到分支，进行一次快进合并见图：
现在，在你的系统上应该已经装好了，设置了自己的名字和电邮。
现在如果在两个快照之间比较以结尾的文件，对这些文件运用过滤器，在比较前把文件转换成文本文件。
现在，如果要输入只需键入即可。
现在它知道了服务端的状态，你的进程会判断哪些是它所拥有但服务端没有的。
现在，将她的工作推送到服务器上：
现在已经可以在自己的分支中访问的最新改动了，所以她应该可以成功推送最后的合并结果到服务器上假设此时没再推送新数据上来：
现在已经可以开始在同一项目上密切合作了。
现在已经可以用命令了，用把项目仓库克隆到本地，以便日后随时更新：
现在，应该再测试一下代码是否仍然正常工作，然后将合并结果推送到服务器上：
现在开始合并的工作：
现在，当运行来创建项目的压缩包时，那个目录不会在归档中出现。
现在我们为，和添加公钥：
现在我们修改下之前已跟踪过的文件，然后再次运行命令，会看到这样的状态报告：
现在我们决定把分支的变化也包含进来。
现在我们回到分支看看：
现在我们已经学会了新建分支和合并分支，可以或应该用它来做点什么呢？在本节，我们会介绍一些利用分支进行开发的工作流程。
现在我们手上已经有了一个真实项目的仓库，并从这个仓库中取出了所有文件的工作拷贝。
现在我们来添加一个新项目。
现在我们来看一个实际的例子。
现在我们来看更大一点规模的私有团队协作。
现在我们的项目已经有了可读可写和只读的连接方式，不过如果能有一个简单的界面访问就更好了。
现在我们的项目提交历史产生了分叉如图所示，因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。
现在我们过一边服务器端架设访问的流程。
现在，所有做过这一步的用户都得把它们的公钥给你或者服务器的管理员假设服务被设定为使用公钥机制。
现在，所有对该服务器有访问权限，并可读取目录的用户都可以用下面的命令克隆该项目：
现在所有的旧分支都变成真正的分支，所有的旧标签也变成真正的标签。
现在把团队里的其他人也加进来。
现在文件又回到了之前已修改未暂存的状态。
现在无论你的环境变量被定义成什么，都会调用编辑信息。
现在是这样：
现在最新的修改已经在当前分支所指向的提交对象中了，可以部署到生产服务器上去了见图。
现在来谈分支。
现在来配置使用你自定义的比较和合并工具吧。
现在，某人在的基础上做了些改变，并合并他自己的分支得到结果，推送到中央服务器。
现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。
现在特性分支上已合并好了贡献者的代码，是时候决断取舍了。
现在用户只能用连接来推送和获取仓库，而不能直接使用主机。
现在，的主干分支已经完全可以在本地访问了，对应的名字是，你可以将它合并到自己的某个分支，或者切换到这个分支，看看有些什么有趣的更新。
现在的你应该掌握了在上使用以及把几乎任何现存仓库无损失的导入为仓库。
现在的'对应的快照，其实和普通的三方合并，即上个例子中的对应的快照内容一模一样了。
现在的提交历史如图所示：
现在的暂存区域已经准备妥当可以提交了。
现在的更新历史如图所示：
现在的问题是，当你执行`分支名称`这条命令的时候，怎么知道最后一次提交的值呢？答案就是文件。
现在目录下导入的应该比原来整洁多了。
现在目录中已经有了一份目录数据的副本。
现在看到的，就是实际将要引入的新代码。
现在要做的是找出最新的那个的，然后添加一个指向它的分支。
现在要怎样恢复呢？办法之一是使用工具，该工具会检查仓库的数据完整性。
现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程：
现在让我们用创建一个新文件，保存退出后运行会看到该文件出现在未跟踪文件列表中：
现在让我们运行将放到暂存区，然后再看看的输出：
现在该项目就托管在上了。
现在运行一下，你会发现这些的校验值都发生了改变，而那些字串则从提交信息里消失了：
现在运行查看此标签信息，就只有相应的提交对象摘要：
现在运行看暂存前后的变化：
现在运行该脚本，你将得到如下内容：
现在，通过就可以在线访问仓库了，在上还可以通过克隆和获取仓库的内容。
理解分支的概念并熟练运用后，你才会意识到为什么是一个如此强大而独特的工具，并从此真正改变你的开发方式。
理解这些差异将有助于你准确地使用提供的各种工具。
甚至可以添加一个挂钩来在每一个提交信息中查找并拒绝提交那些不包含它的。
甚至在流行的系统上安装了开发者工具包之后，也可以使用命令。
甚至还可以指定某个组为成员之一在组名前加上前缀，自动继承该组的成员：
生成公钥的过程在所有操作系统上都差不多。
生成内部版本号
用协议作为访问项目的唯一方法通常是不可取的。
用压缩文件内容，因此这些文件并没有占用太多空间，所有文件加起来总共仅用了字节。
用命令来进行合并：
用对数据内容进行压缩，在中可以用库来实现。
用或时结合选项，可以看到开头多出一些字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况。
用户名如果尝试过访问或，参考名被更新为已知。
用户拥有完全访问权限
用服务器架设起来最简单—以下例子中，我们使用装有系统的服务器。
用来打开此项功能，如果是在系统上，把它设置成，这样当签出代码时，会被转换成：
用的话，没有网络或者断开你就无法做任何事情。
用相同的方法就可以恢复它，即创建一个指向该的分支。
用这个方法可以很快捷地为少数几个开发者架设一个可读写的服务。
用选项显示指定作者的提交，用选项搜索提交说明中的关键字。
由于中的分支实际上仅是一个包含所指对象校验和个字符长度字串的文件，所以创建和销毁一个分支就变得非常廉价。
由于你仅仅需要和参数，用包装脚本来传递它们吧。
由于使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。
由于允许使用多个远程仓库，开发者便可以建立自己的公共仓库，往里面写数据并共享给他人，而同时又可以从别人的仓库中提取他们的更新过来。
由于尚未提交代码，点击项目地址后会显示一个简要的指南，告诉你如何新建一个项目并推送上来，如何从现有项目推送，以及如何从一个公共的仓库导入项目见图：
由于当前分支和都指向相同的提交对象，所以已经完成了历史使命，可以删掉了。
由于当前分支所在的提交对象是要并入的分支的直接上游，只需把分支指针直接右移。
由于当前分支所指向的提交对象并不是分支的直接祖先，不得不进行一些额外处理。
由于当前该服务器上的内容是你服务器上的子集，不会下载任何数据，而只是简单地创建一个名为的远程分支，指向服务器上分支所在的提交对象见图。
由于很少用到，本书将略过对该内容的讨论。
由于挂钩本身不跟随克隆的项目副本分发，所以必须通过其他途径把这些挂钩分发到用户的目录并设为可执行文件。
由于日期是用目录名表示的，我们就从中解析出来。
由于是系统中的唯一用户，我们把他设为唯一用户，并允许他读写名为的新项目：
由于本书无法全部一一介绍，而本人译注：指本书作者。
由于没有权限推送数据到主仓库的分支只有集成管理员有此权限，所以只能将此分支推上去同共享协作：
由于编辑器的不同或者程序员在跨平台项目中的文件行尾加入了回车换行符，一些细微的空格变化会不经意地进入大家合作的工作或提交的补丁中。
由于该文件原先并不在暂存区域中甚至就连暂存区域也还没被创建出来呢，必须传入参数;由于要添加的文件并不在当前目录下而是在数据库中，必须传入参数。
由于该法则的常见性，可以使用来代替整条命令，它意味着标准布局是的首字母，也就是前面选项的内容。
由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用删除该分支会提示错误，因为那样做会丢失数据：
由于随后指明文件内容的时候要用到相同的格式，我们写一个辅助方法，：
由此可见，根据现有的仓库创建一个裸仓库，然后把它放上你和同事都有访问权的服务器是多么容易。
由此我们看到管理项目时，文件流转的三个工作区域：的工作目录，暂存区域，以及本地仓库。
略之所略
的分支和中的不尽相同；避免过多的使用可能是最好方案。
的安装算不上傻瓜化，但也不算太难。
的工作依赖于某些工具，所以首先要安装的包，在上称为：
的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。
的工作方式就像图所示。
的工作需要调用，，，，等库的代码，所以需要先安装这些依赖工具。
的手册页译注：以命令的显示方式非常细致地罗列了所有可用的配置项。
的推送操作被驳回，因为已经推送了新的数据上去。
的数据是以最基本的静态文件的形式提供的关于如何提供文件的详情见第章。
的格式是一个可选的号，接着是的格式，这里是远端上的引用格式，是将要记录在本地的引用格式。
的每个版本都在不断尝试改进用户体验，所以能通过源代码自己编译安装最新版本就再好不过了。
的简化用法。
的设计更侧重于用户，而不是完全基于项目。
的选项指定当你试图删除的内容并不存在时不显示错误。
的限制在于你不能通过它实现仓库的匿名访问。
目前为止，有个对象──个，个，个以及一个：
目前，可供选择的托管服务数量繁多，各有利弊。
目前已经提交了所有的修改，所以接下来可以正常转换到分支：
目前，我们只看过了许可是,,或者这样子的。
目录保存了第七章详细介绍了的客户端或服务端钩子脚本。
目录则是保存所有具有访问权限用户公钥的地方—每人一个。
目录存储所有数据内容，目录存储指向数据分支的提交对象的指针，文件指向当前分支，文件保存了暂存区域信息。
目录结构如下：
直到它们完全稳定后再并入。
直接记录快照，而非差异比较
相关的命令数目不少，你将通过几个简单的工作流程了解到其中常见的一些。
看一下文件的内容，它应该只包含与刚刚克隆的相关的信息：
看一下节省了多少空间。
看上去好像这些都不是什么大问题，但实际体验过之后，你就会惊喜地发现，这其实是会带来很大不同的。
看到了吗？提交之前不再需要文件了。
看到了吗，每次更新都有一个校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。
看起来弄丢了的是底下那个，这样在那个上创建一个新分支就能把它恢复过来。
看起来这个对象在服务端并不以松散格式对象存在，所以得到了响应，代表在服务端没有找到该对象。
短短几分钟内，你就能创建一个新账户，添加一个项目并开始推送。
确认这两个脚本是可执行的：
碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行命令：
私有团队间协作
私有的小型团队
稍做一番修整后同步到服务器：
稍后会介绍几个绕过这种问题的办法分别叫做和。
稍后你会看到，用服务器端的接收钩子也能达到同样的目的。
稍后在第三章讨论分支管理的时候，我们会再看看这样的设计究竟会带来哪些好处。
稍后我们会详细介绍，不过现在，它已经能回答我们的两个问题了：当前做的哪些更新还没有暂存？有哪些更新已经暂存起来准备好了下次提交？会使用文件补丁的格式显示具体添加和删除的行。
稍后我们再学习如何验证已经签署的标签。
稍后我们再逐一解释每条命令的意思。
稍微修改一下些文件，看会发生些什么：
稳定分支的指针总是在提交历史中落后一大截，而前沿分支总是比较靠前见图。
稳定的特性可以并入分支，然后再推送到公共仓库，以供其他人试用。
第一个人，，克隆了仓库，作了些更新，在本地提交。
第一个办法是给每个人建立一个账户，直截了当但略过繁琐。
第一个是，它自动建立对应的文件，以便下次提交的时候可以包含它。
第一个要配置的是你个人的用户名称和电子邮件地址。
第一，文件的位置不同，因为这个脚本在当前工作目录运行，而非目录。
第一是在仓库级别；如果你已经读或者写访问过了任何在仓库里的参考，那么你已经读或者写访问仓库了。
第一步是选择与服务器通讯的协议。
第一种是在现存的目录下，通过导入所有文件来创建新的仓库。
第一行告诉忽略所有以或结尾的文件。
第一行是我们的脚本输出的，在往下是在告诉我们脚本退出时返回了非零值因而推送遭到了拒绝。
第一项信息指明我们定义的是一个对象以及它所在的分支，随后是我们生成的标记，提交者信息以及提交备注，然后是前一个的索引，如果有的话。
第二个办法是在主机上建立一个账户，让每个需要写权限的人发送一个公钥，然后将其加入账户的文件。
第二个命令是，它把需要放进文件中的内容打印到标准输出，方便我们把输出重定向到项目的黑名单文件：
第二个开发者，，一样这么做：克隆仓库，提交更新：
第二个开发者在提交他的修订之前，必须先下载合并服务器上的数据，解决冲突之后才能推送数据到共享服务器上。
第二种是从已有的仓库克隆出一个新的镜像仓库来。
第二级，应用只能写访问，通过在仓库里的或者。
第二行告诉忽略所有以波浪符结尾的文件，许多文本编辑软件比如都用这样的文件名保存副本。
第行还会包含有客户端的能力。
等于说是显示了最近已知服务器上的状态。
签署标签
简单地说，就是一套用来管理文件和实现简单连接限制的脚本。
简单地说，裸仓库就是你工作目录中子目录内的内容。
简单的设计
管理远程仓库的工作，包括添加远程库，移除废弃的远程库，管理各式远程库分支，定义是否跟踪这些分支，等等。
籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。
类似对的模拟，的等效命令是`文件名`。
类似的比如：
系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。
索引文件包含了的偏移信息，这样就可以快速定位任意一个指定对象。
经过前面几章的学习，我们已经学会了一些基本的本地工作流程中所需用到的命令。
给发行版签名
给用户的敬告：你应该在提供的风格的来运行。
绝大多数人都熟悉和了解这种模式的工作方式，所以使用也非常广泛。
绝大多数的内核维护工作都花在了提交补丁和保存归档的繁琐事务上－年间。
继而输入会自动完成命令的输入。
维护及数据恢复
维护者可以按照之前介绍的方法，将贡献者的代码引入为不同的特性分支如图所示，然后测试评估，看哪些特性能稳定工作，哪些还需改进。
维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库，合并更新并做测试。
维护者在自己的本地也有个克隆仓库，他可以将你的公共仓库作为远程仓库添加进来，经过测试无误后合并到主干分支，然后再推送到官方仓库。
维护者将合并后的更新推送到主仓库。
编辑器会显示类似下面的文本信息本例选用的屏显方式展示：
编辑该文件：
缺省情况下会被命令所自动生成，会获取远端上下面的所有引用，并将它写入到本地的所以，如果远端上有一个分支，你在本地可以通过下面这种方式来访问它的历史记录：
而且，假若项目维护者未采纳你的贡献的话不管是直接合并还是，都不用回退自己的分支。
而且可能会随时改变本节内容，因此你也许想看看最新的版本。
而且，如果那个字符串没有包含在任何的提交里，我们将看到前面脚本里输出的错误信息：
而且它还会指出引用，让客户端可以检查是否是一份克隆。
而且管理员可以随便更改包括对任何参考名。
而之后当你再从服务器上下载最新提交后，会得到：
而你和其他开发者则都具有推送数据到仓库的权限。
而则定义为
而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用来签署或验证。
而在之后，你的提交历史里就会同时包含和'，两者有着不同的校验值，如果用查看历史，会看到两个提交拥有相同的作者日期与说明，令人费解。
而在其他操作系统上，可以用，或者系统的脚本，或者其他类似的脚本—只要能让那个命令变为守护进程并可监控。
而在这次提交之前仅用了左右──显然在这次提交时删除文件并没有真正将其从历史记录中删除。
而在这段时间，已经开始在另一个特性分支工作了。
而在项目页面的摘要部分，你会发现有两个地址见图：
而如果你只想做一次该操作，也可以在命令行上指定这个如可以这样拉取远程的分支到本地的分支：
而已经提交上去的更新，也可能在等着审核合并的过程中变得过时。
而平时这两个分支都会被推送到公开的代码库。
而所有其他文件都属于未跟踪文件。
而所有这些工作，仅仅需要和这两条命令就可以完成。
而所有这些集成管理员头上还有一位负责统筹的总集成管理员，称为司令官。
而普通的仓库应该是这个模样：
而更糟的是，当你把这样的历史推送到服务器后，会再次把这些变基后的提交引入到中央服务器，进一步困扰其他人译注
而正是由于分支管理的便捷，才衍生出了这类典型的工作模式，你可以根据项目的实际情况选择一种用用看。
而正是由这些环境变量，决定了在各个环节的具体工作方式和行为。
而的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。
而管理员也可以轻松掌控每个开发者的权限，并且管理一个要远比在各个客户端上维护本地数据库来得轻松容易。
而维护者则通过管理这些分支，逐步有序地并入第三方贡献。
而这里需要做的工作就是告诉内容快照的位置，什么样的数据指向它们，以及它们的顺序。
而选项则允许克隆项目时不必给出完整路径。
而选项则指定了对应的标签说明，会将此说明一同保存在标签对象中。
而部分则显示的是原作者，以及创建补丁的时间。
而随着使用的深入，会有很多经常要用到的命令，遇到这种情况，不妨建个别名提高效率。
能够为输出到你终端的内容着色，以便你可以凭直观进行快速、简单地分析，有许多选项能供你使用以符合你的偏好。
能够识别的配置项被分为了两大类：客户端和服务器端，其中大部分基于你个人工作偏好，属于客户端配置。
能获取最新的数据，不过才会在获取之后在本地进行更新。
脚本为每一个得到推送的分支运行一次；它接受推送目标的索引，该分支原来指向的位置，以及被推送的新内容。
脚本和脚本十分类似。
脚本的主循环大致是这样：
自动定期对仓库进行重新打包以节省空间。
自动把分支名扩展为，意为“取出我在本地的分支，推送到远程仓库的分支中去”。
自定导入脚本
自带一个叫做的脚本，运行效果可以到这样的站点体验下见图。
自然，这会重写提交历史，如图所示：
自诞生于年以来，日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。
至于其他托管服务大体也是这么一个过程，基本的想法都是差不多的。
至于内部究竟是如何保存和恢复数据的，我们会在第九章讨论内部原理时再作详述。
至此，你该对有了点基本认识，包括它和以前你使用的之间的差别。
至此导入已经完成，可以开始向新的服务器推送了。
至此，每个开发者都提交了若干次，且成功合并了对方的工作成果，最新的提交历史如图所示：
花费不过几分钟。
若使用时用选项，读写的就是这个文件。
若是不久她又发来邮件，说还有个很棒的功能实现在另一分支上，那我们只需重新抓取下最新数据，然后检出那个分支到本地就可以了，无需重复设置远程仓库。
若是条件允许，从源代码安装有很多好处，至少可以安装最新的版本。
若是没有签署者的公钥，会报告类似下面这样的错误：
若给命令传入选项，它会列出所有值，值及相应的文件路径。
若要查看各个分支最后一个提交对象的信息，运行：
若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用命令。
获取帮助
虽然下载了推送到服务器的最近更新，但目前只是指针指向它，而当前的本地分支仍然指向自己的更新，所以需要先把她的提交合并过来，才能继续推送数据：
虽然会确认每个对象的有效性以及是否仍然匹配检验和，但不会在每次推送时都检查一致性。
虽然你也可以直接手动编辑这些配置文件，但是运行命令将会来得简单些。
虽然可以在相同或单独的项目内容里加入并分发它们，全自动的解决方案是不存在的。
虽然技术上看它是由字符组成的文本文件，但你并不认为如此，因为它确实是一个轻量级数据库—如果有人改变了它，你通常无法合并和比较内容，只有机器才能进行识别和操作，于是，你想把它当成二进制文件。
虽然最后整合得到的结果没有任何区别，但变基能产生一个更为整洁的提交历史。
虽然有很多选择，不过我们这里只介绍其中一部分。
虽然能得到差异内容，但请记住，结果有可能和我们的预期不同。
虽然自己实现了,而且到目前为止你一直在使用它，但你能够用一个外部的工具替代它，除此以外，你还能用一个图形化的工具来合并和解决冲突从而不必自己手动解决。
虽然这些元数据并不能完全描述一个二进制文件，但大多数情况下，都是能够概括文件情况的。
虽然这是小问题，但它会极大地扰乱跨平台协作。
虽说这项技术对自定义应用来说很有用，但还是要小心，因为文件会随着项目一起提交，而过滤器例如：不会，所以，过滤器不会在所有地方都生效。
衍合与挑拣的流程
表列出了常用的格式占位符写法及其代表的意义。
表还列出了一些其他常用的选项及其释义。
表还列出了其他常用的类似选项。
裸仓库的目录名一般以结尾，像这样：
要为本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字：
要么所有人都能克隆仓库，要么谁也不能。
要从中移除某个文件，就必须要从已跟踪文件清单中移除确切地说，是从暂存区域移除，然后提交。
要从该清单中筛选出你已经或尚未与当前分支合并的分支，可以用和选项以上版本。
要养成一开始就设置好文件的习惯，以免将来误提交这类无用的文件。
要切换到其他分支，可以执行命令。
要创建一个对象，使用命令，指定一个的，如果有任何前继提交对象，也可以指定。
要创建这样的标签，一个，或选项都不用，直接给出标签名字即可：
要删除远程分支，必须从服务器手动删除引用文件。
要参与任何一个项目的协作，必须要了解该如何管理远程仓库。
要合并或分支，谁先谁后都没有关系，因为它们都在上游译注：想像分叉的更新像是汇流成河的源头，所以上游是指最新的提交，所以无所谓先后顺序，最终合并后的内容快照都是一样的，而仅是提交历史看起来会有些先后差别。
要和朋友们在一个项目上协同工作，就得重新添加他们的公钥。
要在中对文件改名，可以这么做：
要在中建立一个新分支，需要运行`分支名`：
要对现有的某个项目开始用管理，只需到此项目所在的目录，执行：
要尝试本例，先在本地新建一个仓库：
要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号取反。
要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。
要找出一个非类型的索引，要么衍合超过某个已经推送过的提交，要么从本地不同分支推送到远程相同的分支上。
要把标签变成合适的标签，运行
要搞定这一点，所有的规则将被写入一个位于服务器的原始仓库的文件。
要新建并切换到该分支，运行并加上参数：
要是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就会有丢失数据的风险。
要是对生成公钥的步骤不太清楚，也可以点击链接，会显示各个主流操作系统上完成该步骤的介绍。
要是将远端合并到本地再推回去，还不如把整个特性分支推上去来得干脆直接。
要是进程意外退出或者被杀掉，也会自行重启。
要暂存这次更新，需要运行命令这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。
要更复杂一点。
要查看尚未暂存的文件更新了哪些部分，不加参数直接输入：
要查看当前配置有哪些远程仓库，可以用命令，它会列出每个远程库的简短名字。
要查看这到底是哪个文件，可以使用第章中已经简单使用过的命令。
要检查已有的配置信息，可以使用命令：
要检查服务端有哪些打包格式文件，你需要获取文件，这里面包含有打包文件列表是的，它也是被所生成的；
要派生一个项目，到原始项目的页面本例中是点击按钮见图：
要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行：
要添加一个本地仓库作为现有项目的远程仓库，可以这样做：
要看看哪些文件在合并时发生冲突，可以用查阅：
要确定哪些文件当前处于什么状态，可以用命令。
要禁用这样的强制更新功能，可以设置：
要获取它们，你得转到分支的所在：
要运行导入脚本，在需要导入的目录把该内容用管道定向到。
规避策略的方法之一就是用户删除分支，然后推回新的引用。
解决冲突的办法无非是二者选其一或者由你亲自整合到一起。
解决的办法也一样，先编辑文件消除冲突，然后暂存文件，最后运行提交修正结果：
警告：此方法会破坏提交历史。
让你定义一个”个人的“或者”乱七八糟的”命名空间字首给每个开发人员比如，；看在里的一段获取细节。
让我们以库来看看的过程：
让我们来看看，两个开发者一起使用同一个共享仓库，会发生些什么。
让我们跟随的视角看看她的工作流程。
让把所有文件当成二进制文件，在文件中设置如下：
记住，任何已经提交到的都可以被恢复。
记住，提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。
记住，虽然使用了来进行这次操作，并且合并过程可能比使用简单一些因为会自动找到适合的合并基础，这并不是一次普通的合并提交。
记录每次更新到仓库
记录记录所有成功的访问。
许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。
许多使用的开发者都喜欢用这种方式来开展工作，比如仅在分支中保留完全稳定的代码，即已经发布或即将发布的代码。
许多大型项目都会立有一套自己的接受补丁流程，你应该注意下其中细节。
许多开发小组改用就是因为它允许多个小组间并行工作，而在稍后恰当时机再行合并。
设置包装脚本的好处是你能简单地改变和工具，例如把和改成，要做的仅仅是编辑脚本文件：
设置好以后，当输出到终端时，会为之加上颜色。
设置完毕后，运行命令：
设置，当运行时，会在你的编辑器中显示以上的内容，设置如下：
设置，按照你的意图来打开或关闭选项，选项以逗号分割。
访问权报告另一个方便的功能是你尝试用连接到服务器的时候发生了什么。
访问规则检查是否出现在配置文件里，为这个联合寻找匹配但是记得参考名是正则匹配的，不是字符串匹配的。
访问页面并点击里的按钮见图，进入注册页面。
识别二进制文件
译注：例如文档。
译注：其实的潜台词就是把目标文件快照放入暂存区域，也就是，同时未曾跟踪过的文件标记为需要跟踪。
译注：如果现在还没有克隆项目源代码，是时候了。
译注：本书的翻译也是放在上广泛协作的。
译者注：分发公钥是为了验证标签。
该协议还要求防火墙开放端口，而企业级防火墙一般不允许对这个非标准端口的访问。
该命令从标准输入读取简单的指令来写入具体的数据。
该命令将原本以开头的远程分支的索引变成真正的轻巧的标签。
该命令是查看对象的瑞士军刀。
该命令的输出或许会让人有些不解。
该命令输出长度为个字符的校验和。
该命令首先找到是哪个服务器本例为，从上面获取你尚未拥有的数据，更新你本地的数据库，然后把的指针移到它最新的位置上见图。
该如何撤消暂存其中的一个文件呢？其实，的命令输出已经告诉了我们该怎么做：
该字串由个十六进制字符及组成，看起来就像是：
该工具把变成了服务的客户端，从而让你在本地享受到所有的功能，而后直接向服务器推送内容，仿佛在本地使用了客户端。
该技术允许你迅速且完全的进行语境切换—因为你的工作分散在不同的流水线里，每个分支里的改变都和它的目标特性相关，浏览代码之类的事情因而变得更简单了。
该挂钩不接收参数，在补丁被运用之后运行，因此，可以被用来在提交前检查快照。
该挂钩可以被用来检查代码错误运行类似的程序，检查尾部空白默认挂钩是这么做的，检查新方法译注：程序的函数的说明。
该挂钩同样能够验证在控制之外的文件是否存在，因此，当工作树改变时，你想这些文件可以被复制。
该挂钩对通常的提交来说不是很有用，只在自动产生的默认提交信息的情况下有作用，如提交信息模板、合并、压缩和修订提交等。
该挂钩接收一些选项：拥有提交信息的文件路径，提交类型，如果是一次修订的话，提交的校验和。
该指南和本书前文介绍的类似，对于新的项目，需要先在本地初始化为项目，添加要管理的文件并作首次提交：
该文件的存在，表明允许守护进程开放对该项目的匿名只读访问。
该样本假定是你定义的分支名，因此，你可能要修改样本，把改成你定义过且稳定的分支名。
该格式包含了单词，所读取数据的大小，一个换行符，最后是数据本身。
该目录下有可能还有其他文件，但这是一个全新的生成的库，所以默认情况下这些就是你能看到的结构。
该目录结构如下：
该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。
该程序在系统上由包提供，而在上则包含在包里：
该脚本从命令中得到最新提交日期，找到文件中的所有字符串，最后把该日期填充到字符串中—此脚本很简单，你可以选择你喜欢的编程语言来实现。
该脚本无法组织推送进程，不过客户端在它完成运行之前将保持连接状态；所以在用它作一些消耗时间的操作之前请三思。
该行修改后的样子如下：
该选项除了显示基本信息之外，还在附带了每次的变化。
该配置项只在及以上版本有效，假如你在中错打了一条命令，会显示：
语法解析该次提交的所有祖先。
说实话，有了这些小窍门，我们的工作可以变得更简单，更轻松，更高效。
说明认出了该用户的身份，但由于没有运行任何命令，所以它切断了连接。
说白了，新建一个分支就是向一个文件写入个字节外加一个换行符那么简单，当然也就很快了。
请不要在周末穷追猛打一次性解决五个问题，而最后拖到周一再提交。
请务必牢记这些分支全部都是本地分支，这一点很重要。
请回顾之前有关合并的一节见图，你会看到开发进程分叉到两个不同分支，又各自提交了更新。
请注意，上面列出的地址只有用的是链接，所以也只有这个仓库我能推送数据上去我们会在第四章解释原因。
请注意，单单不过是显示还没有暂存起来的改动，而不是这次工作和上次提交之间的差异。
请注意，合并时出现了“”的提示。
请注意，合并结果中最后一次提交所指向的快照，无论是通过变基，还是三方合并，都会得到相同的快照内容，只不过提交历史不同罢了。
请注意，如果要得到同时满足这两个选项搜索条件的提交，就必须用选项。
请注意子目录并非一个对象，而是一个指向另一个对象的指针：
请注意它和你熟知的许多其他版本控制系统比如或里的概念大不相同。
请注意，有些撤销操作是不可逆的，所以请务必谨慎小心，一旦失误，就有可能丢失部分工作成果。
请注意，特别是你用惯了的话，这里其实修改的是两个文件，而不是同一个文件的同一个地方。
请注意该对象包含了两个文件记录，且的值是早先值的第二版。
请注意，这次合并操作的底层实现，并不同于之前的并入方式。
请注意，这里不用指明完整路径实际上，如果加上反而没用，只需要一个冒号加项目名字即可—会自动帮你映射到实际位置。
请牢记，在后加选项将展示每次提交的内容差异。
请留意文件最后以开头的那一行。
请记住，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。
读到这里，你应该已经学会了如何创建分支并切换到新分支，在不同分支间转换，合并本地分支，把分支推送到共享服务器上，使用共享分支与他人协作，以及在分享之前进行变基。
读完本章，你就会明白为什么会如此流行，为什么你应该立即开始使用它。
读完本章你就能上手使用了。
读完本章，你就能初始化一个新的代码仓库，做一些适当配置；开始或停止跟踪某些文件；暂存或提交某些更新。
读过前一节有关的内容以后，你应该能轻而易举的根据其中的指导来一个仓库了；然后，停止的使用，向一个新推送，并开始使用它。
贡献者克隆此仓库，修订或编写新代码。
贡献者推送数据到自己的公共仓库。
贡献者给维护者发送邮件，请求拉取自己的最新修订。
起步
跟踪分支是一种和某个远程分支有直接联系的本地分支。
跟踪新文件
跟踪远程分支
跳过使用暂存区域
轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。
轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。
较新的版本中都带有该工具，它将数据编码为用于网络传输的格式。
输出的内容可以直接发邮件给管理者，他们就会明白这是从哪次提交开始旁支出去的，该到哪里去抓取新的代码，以及新的代码增加了哪些功能等等。
辛辛苦苦写成的代码在最后时刻惨遭拒绝是十分悲剧且具有迷惑性的；更可怜的是他们不得不修改提交历史来解决问题，这怎么也算不上王道。
边注：有一些二进制文件虽然包含文字，但是却难以转换。
运行会输出的正常日志，从而显示更多有用信息：
运行后，打开该文件，会发现其内容如下：
运行命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在分支里工作参考图。
运行命令将从服务器导入项目，我们需要给出仓库和项目的路径以及导入的目标路径：
运行它之前必须获取的源码，可以在下载：
运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。
运行自己的服务器意味着更多的控制权以及在防火墙内部操作的可能性，当然这样的服务器通常需要投入一定的时间精力来架设维护。
近乎所有操作都是本地执行
返回到原先已经发布到生产服务器上的分支。
还会将所有引用并入一个单独文件。
还可以使用来获取与运行类似的信息：
还可以做更多——处理不同的文件模式，二进制文件，多重分支与合并，标签，进展标识等等。
还可以查看每次提交的具体修改。
还可以给出若干搜索条件，列出符合的提交。
还好，合并过程非常顺利，没有冲突，现在的提交历史如图所示：
还好，的设计者想到了解决办法：可以把即公钥作为变量写入库，然后把它的内容直接写在标签里。
还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。
还有个常用的选项，可以指定使用完全不同于默认格式的方式展示提交历史。
还有个额外的好处：是一个如此常见的协议，以至于企业级防火墙通常都允许其端口的通信。
还有你的提交权限。
还能对归档做一些简单的关键字替换。
还能设定哪些项目允许放在上显示。
这一招可以让你在几分钟内为相当数量的用户架设好基于的读取权限。
这一步很重要，因为它意味着所有的值都会发生变化。
这一步的合并是迟早会发生的，因为只有这样你才能和其他协作者提交的内容保持同步。
这一点值得牢记：会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。
这一点需要牢记，因为它的结果是推送之后项目处于一个不完整存在与任何主机上的状态。
这一般出现在以下情况下：强制删除了一个分支而后又想重新使用这个分支，了一个分支从而丢弃了分支的部分。
这一节带你快速浏览这两种主要的协议操作过程。
这三类对象──，以及──都各自以文件的方式保存在目录下。
这与响应很类似，但是这里指的能力是不同的。
这丝毫不会影响提交的数据—访问主机用的身份不会影响提交对象的提交者信息。
这两个频道上总有着上百号人，大多都有着丰富的知识，并且乐于助人。
这两处目录中的脚本，都会在启动时自动加载。
这两条配置很重要，每次提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：
这个之桥是通向分布式版本控制系统,世界的神奇隧道。
这个减少了主管理者的负担，让他瓶颈更小。
这个功能在他自己的文档目录里的下面。
这个功能在文档里
这个压缩包解压出来的是一个文件夹，里面是你项目的最新代码快照。
这个命令会在你的文件中增加一节：
这个字符串可以作为快照的名字，方便人们理解。
这个小程序会删除字符串里多余的字符，恢复原貌。
这个很好理解：如果是特性分支的直接祖先，不会产生任何问题；如果它们的提交历史在不同的分叉上，那么产生的内容差异，看起来就像是增加了特性分支上的新代码，同时删除了分支上的新代码。
这个技巧不错吧，可以节省很多输入和查阅文档的时间。
这个提交对象比较特殊，它有两个祖先和。
这个文件是在服务端运行了所生成的，这也解释了为什么在服务端要想使用传输，必须要开启钩子：
这个方法可以做更细致的控制，例如：禁用特定的用户做强制更新。
这个方法大致是这样的：
这个方法是很简单但效率不是很高。
这个时候，我们就可以把基于分支而非分支的改变即和，跳过直接放到分支中重演一遍，但这需要用的选项指定新的基底分支：
这个标识符可以保留，以防以后需要引用的修改版本号。
这个特性很酷，而且鲜为人知，因此我会结合实例来讲解。
这个的值相当地随机，无法区分日期的前后，所以，如果你在或中用过关键字替换，一定会包含一个日期值。
这个给了你更多的能力，当然也有一点复杂，因为不匹配并不是唯一的拒绝访问的方法，因此规则的顺序变得无关了！
这个脚本利用了一个第六章修订版本选择一节中不曾提到的语法。
这个获取过程仅仅是一系列请求，客户端可以假定服务端的仓库中的布局。
这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了，和这些行。
这个解决方案的硬伤在于它有可能很慢而且常常没有必要——只要不用来强制推送，服务器会自动给出警告并且拒绝推送内容。
这个过程看起来像这样：
这个进程运行在客户端上，它连接至远端运行的进程。
这个通常会引起一些名称簇变成像里一样集中化，加上设置许可变成管理员的苦差事。
这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。
这么做也方便自己将来取消某个特定问题的修复。
这么做唯一的好处就是简单。
这么做最主要的优点在于，你可以按照自己的节奏继续工作，而不必等待维护者处理你提交的更新；而维护者也可以按照自己的节奏，任何时候都可以过来处理接纳你的贡献。
这么做最显而易见的缺点是中央服务器的单点故障。
这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。
这么做需要用到第章中用过的命令：
这么说好了，在前面的情况中，我们想要工程师可以任意除了和。
这也意味着该协议通常不能用来进行推送。
这也是从别人工作目录中获取工作成果的快捷方法。
这也是同时使用和两种服务作为远程服务不是个好主意的原因之一。
这些修改在你合并之前将一直被拒绝。
这些内容包含如何避免为每一个用户建立一个账户，给仓库添加公共读取权限，架设网页界面，使用工具等等。
这些协议在远端都有智能型进程在服务它可以读出本地数据并计算出客户端所需要的，并生成合适的数据给它，这有两类传输数据的进程对用于上传数据和一对用于下载。
这些变量可以存放在以下三个不同的地方：
这些命令一般被称为命令底层命令，其他的更友好的命令则被称为命令高层命令。
这些命令主要不是用来从命令行手工使用的，更多的是用来为其他工具和自定义脚本服务的。
这些挂钩脚本可以在提交对象推送到服务器前被调用，也可以在推送到服务器后被调用。
这些改变分别孤立在不同的分支里：我们可以在不同分支里反复切换，并在时机成熟时把它们合并到一起。
这些文件实际上都是从目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。
这些是的核心部分。
这些脚本使用写成，一半由于它是作者倾向的脚本语言，另外作者觉得它是最接近伪代码的脚本语言；因而即便你不使用也能大致看懂。
这些设置项被称为属性，可以在你目录中的文件内进行设置通常是你项目的根目录，也可以当你不想让这些属性文件和项目文件一同提交时，在进行设置。
这些过滤器能够做各种有趣的事。
这些选项也能运用于衍合。
这些项目由字符隔开。
这会修改当前工作目录下的文件，效果基本与运行打补丁一样，但它更为严格，且不会出现混乱。
这会切换到新建的本地分支，其内容同远程分支一致，这样你就可以在里面继续开发了。
这会在当前对象上新建一个分支指针见图。
这会在当前目录下创建一个名为的目录，其中包含一个的目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。
这会在端口开启一个服务，随之在浏览器中显示该页，十分简单。
这会安装几个供使用的工具。
这会得到一个名为的工作目录，主要由两部分组成：
这便是存储数据内容的方式──为每份内容生成一个文件，取得该内容与头信息的校验和，创建以该校验和前两个字符为名称的子目录，并以校验和剩下个字符为文件命名保存至子目录下。
这其实是上一种工作流的变体。
这和使用服务器是不同的——在世界里，发布之前，你可以在客户端系统里完整的测试项目的状态，而在永远都没法确保提交前后项目的状态完全一样。
这和大多数版本控制系统形成了鲜明对比，它们管理分支大多采取备份所有项目文件到特定目录的方式，所以根据项目文件数量和大小不同，可能花费的时间也会有相当大的差别，快则几秒，慢则数分钟。
这和服务端的脚本几乎一样，除了两个重要区别。
这在服务端有多个打包文件时也很有用，因为这样就可以先检查你所需要的对象空间是在哪一个打包文件里面了：
这基本上就是运行　和命令时进行的工作　──保存修改了的文件的，更新索引，创建对象，最后创建对象，这些对象指向了顶层对象以及先前的对象。
这多半是因为主干分支和补丁的基础分支相差太远，但也可能是因为某些依赖补丁还未应用。
这好比在说：“取出分支，找出分支和分支的共同祖先之后的变化，然后把它们在上重演一遍”。
这将会引入的代码，但是会得到不同的值，因为应用日期不同。
这将建立进行同步所需的属性。
这就是的全部——一个永远不会发生变化的分支。
这就是自从版本以来的所有提交的简介，内容按照作者分组，以便你能快速的发给他们。
这就等于告诉提交者，你所作的修订无法通过快进来合并，你必须先拉取最新数据下来，手工解决冲突合并后，才能继续推送新的提交。
这就行了──你已经创建了一个正确的对象。
这就迫使开源社区特别是的缔造者不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。
这就需要你再次衍合到最新的，解决相关冲突，然后重新提交你的修改：
这常见于团队每一个成员都对一个共享的文件系统例如拥有访问权，或者比较少见的多人共用同一台电脑的情况。
这时如果运行,下的所有文件都会消失。
这时，已经可以开始漫游操作了。
这时，，或者就可以把它加为远程仓库，推送一个分支，从而把第一个版本的项目文件上传到仓库里了。
这时暂存区域中包含了的新版本及一个新文件。
这是一个包含在软件包中的特殊守护进程；它会监听一个提供类似于服务的特定端口，而无需任何授权。
这是一个强力的公能写在里。
这是一个非常有用的功能，需要通过设置`;`在文件中启用。
这是一个非常有用的命令，应该牢记。
这是个哈希值──其值为要存储的数据加上你马上会了解到的一种头信息的校验和。
这是个让偷偷潜入合作开发环境的好东西，在帮助你的开发同伴们提高效率的同时，它还能帮你劝说团队让整个项目框架转向对的支持。
这是个非常重要的差别，收取的是项目历史的所有数据每一个文件的每一个版本，服务器上有的数据克隆之后本地也都有了。
这是传输协议的一个很基础的例子，在更复杂的例子中，客户端可能会支持或者能力；但是这个例子中展示了智能协议的基本交互过程。
这是同其他系统的重要区别。
这是命令输出的开头几行，也是一个有效的文件格式。
这是因为使用回车和换行两个字符来结束一行，而和只使用换行一个字符。
这是因为大多数环境已经支持通过对服务器的访问—即便还没有，架设起来也很容易。
这是所创建对象的值：
这是操作对这个远端的缺省值。
这是最简单的流程，所以在处理大一些的项目时可能会有问题。
这是种简单的纯文本文件，可以包含多封电邮，格式上用加空格以及随便什么辅助信息所组成的行作为分隔行，以区分每封邮件，就像这样：
这有好几个原因－这个对象可能在替代仓库里面，或者在打包文件里面，会首先检查任何列出的替代仓库：
这本书读到这里，你已经使用过一些简单的远程分支到本地引用的映射方式了，这种映射可以更为复杂。
这条命令做了两件事。
这条命令在你用向仓库推送内容时运行；之后，其他人就可以用下面的命令来克隆仓库：
这条命令看起来有些古怪，先别管，能用就行。
这条咒语从每一个待提交内容里提取提交信息，并且会在提取信息不符合要求的情况下退出。
这样一来，下面的两条命令完全等同：
这样一来，当你重启计算机时，进程也会自动启动。
这样一来，我就可以非常轻松地从这些用户的仓库中，拉取他们的提交到本地。
这样一来，所有人都将通过账户访问主机。
这样一来，避免了对项目的干扰。
这样不管命令的输出量多少，都会在一页显示所有内容。
这样他们就可以通过各自的公钥访问我的这个仓库了。
这样，会保持原样。
这样会在推送过程中阻止删除分支和标签—没有用户能够这么做。
这样会在系统上的签出文件中保留，会在和系统上，包括仓库中保留。
这样，你就可以在原来代码基础上，继续工作，直到最后一起提交。
这样你的分支将会只包含那次提交以及之前的工作：
这样做是出于速度考虑──由于在运行你的之前无需将所有版本签出到磁盘上，这个操作会快得多。
这样做有几大优点：托管账户的建立通常比较省时，方便项目的启动，而且不涉及服务器的维护和监控。
这样，其他人的克隆和推送也一样变得很简单：
这样，其它开发者能阅读，但在采纳补丁时不会将此合并进来。
这样创建对象比运行纯命令或者手动写对象要简单的多更多相关内容见第九章。
这样命令就变成了：
这样，在人们克隆仓库时就有两种选择：既可检出最新稳定版本，确保正常使用；也能检出开发版本，试用最前沿的新特性。
这样在提交之前你就可以看到这类问题，及时解决以免困扰其他开发者。
这样，在确保这些已完成的特性分支短期分支，比如之前的分支能够通过所有测试，并且不会引入更多错误之后，就可以并到主干分支中，等待下一次的发布。
这样就丢弃了最新的两个──包含这两个的分支不存在了。
这样，就会让缺省就把本地的分支推送到远程的分支上。
这样就取得了这它的下一步对象，再抓取对象：
这样就可以了。
这样就好理解后续操作的实际意义了。
这样，就得到了两个需要进一步获取的对象－是这个对象所对应的对象，和是它的父对象；
这样，就必须先将的代码合并到自己本地分支中，才能再一起推送回服务器。
这样就指向了分支见图。
这样最新的两个不会被任何东西引用到：
这样有了一个跟原来一样的分支，最新的两个又找回来了。
这样用户就被添加了。
这样的实现方式会给我们带来什么好处呢？好吧，现在不妨再提交一次：
这样的引用标识符——它看起来并不像一个普通的引用——其实并不包含值，而是一个指向另外一个引用的指针。
这样的组合，使源代码在暂存前被程序过滤，非常有效。
这样该公钥的拥有者就能修改用于配置的那个特殊仓库了。
这次你可能会想要知道访问控制规则是如何应用的，我们简要介绍一下。
这次，没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象见图。
这正是和一开始就能正常工作的原因。
这相当于在中的命令，并会对服务器进行相关操作。
这相当于执行下面这两条命令：
这相当于针对所提供的运行了两条命令——加上。
这种做法便于同别人保持长期的合作关系。
这种做法带来了许多好处，特别是相较于老式的本地来说。
这种对象类型称为。
这种工作流程并不常用，只有当项目极为庞杂，或者需要多级别管理时，才会体现出优势。
这种差异带来的影响是显著的，越是多的人参与进来，就越难保证每次合并正确无误。
这种情况下，会报错并询问该怎么做：
这种情况下，你们可以用或其他集中式版本控制系统类似的工作流来协作。
这种情形通常都会有个代表着官方发布的项目仓库，开发者们由此仓库克隆出一个自己的公共仓库，然后将自己的提交推送上去，请求官方仓库的维护者拉取更新合并到主项目。
这种手段的缺点在于用户推送内容遭到拒绝后几乎无法避免的抱怨。
这种方式会启动文本编辑器以便输入本次提交的说明。
这种方式就不需要再自己安装依赖库了，会帮你搞定这些麻烦事。
这种方式的妙处在于接受补丁时仍可保留原来的提交消息，请看接下来的例子：
这种方法的缺点是，与基本的网络连接访问相比，难以控制从不同位置来的访问权限。
这种说法的意思是，从核心上来看不过是简单地存储键值对。
这种高可靠性令我们的开发工作安心不少，尽管去做各种试验性的尝试好了，再怎样也不会弄丢数据。
这简单的很，因为它们分别处于一个目录——你可以输出命令，随后是目录中每个文件的内容。
这类系统，等等每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容，请看图。
这类系统，诸如，以及等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。
这表示该行上一行的那个标签是一个标签，而该行正是那个标签所指向的。
这说明你现在的工作目录相当干净。
这说明在完成获取后，需要检出分支。
这说明虽然只是往一个行的文件最后加入了一行内容，却用一个全新的对象来保存新的文件内容：
这通常是个很好的禁止策略，但有时你在做衍合并确定要更新远程分支，可以在命令后加标志来强制更新。
这里为了简化，后面我们还是用之前运行的用户。
这里为了说明要解决的问题，才把新建的分支取名为。
这里举一个简单的例子：在暂存前，用缩进程序过滤所有源代码。
这里使用的格式和的机制十分类似：它由若干行构成，第一项内容是或者，接着是逗号分隔的规则生效用户列表，最后一项是规则生效的目录空白表示开放访问。
这里其实走了一点捷径。
这里我们从检查远程最后一次提交能够衍变获得但从所有我们尝试推送的提交的值祖先无法衍变获得的提交内容——也就是的内容。
这里我们假定服务已经配置好，会把对的请求发送到这台主机：
这里是例子：
这里是如何做到的
这里，是权限模式加入有可执行文件，则需要探测之并设定为，而说明我们在本行结束之后立即列出文件的内容。
这里有两个远程服务器：一个名为，具有一个分支；另一个叫，具有和两个分支。
这里有几个有趣的信息。
这里服务端只有一个打包文件，所以你要的对象显然就在里面。
这里的全的值表示之前没有过这个对象－因为你是在添加新的引用。
这里的命令会立即对它所拥有的每一个引用响应一行－在这个例子中，只有分支和它的值。
这里的对比显示在行间。
这里的选项将目标分支上的所有更改全拿来应用到当前分支上，而选项告诉此时无需自动生成和记录合并提交。
这里的选项表示在重启服务前，不等之前的连接超时就立即重启。
这里第行也包含了服务端的能力列表这里是和。
这里继续使用之前的例子。
这里说私有，是指源代码不公开，其他人无法访问项目仓库。
这里进程在连接后像这样向后台发送数据：
这需要许多自定义设置：通知使用哪个合并工具；规定命令运行的方式；会通知程序的退出是否指示合并操作成功；通知用什么命令做比较。
这项特性作为的设计哲学，建在整体架构的最底层。
进入目标目录
进去看看：
远程仓库是指托管在网络上的项目仓库，可能会有好多个，其中有些你只能读，另外有些可以写。
远程仓库的使用
远程仓库的删除和重命名
远程仓库通常只是一个裸仓库—即一个没有当前工作目录的仓库。
远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。
远程分支是对远程仓库中的分支的索引。
退出合并工具以后，会询问你合并是否成功。
退出编辑器时，会丢掉注释行，将说明内容和本次更新提交到仓库。
逃离这种两难境地的法宝是给用户一些客户端的挂钩，在他们作出可能悲剧的事情的时候给以警告。
选择一个系统中尚未使用的用户名，提供一个与之相关联的电邮地址，并输入密码见图：
选项类似于第章中使用的选项，但这里不是传入一个命令去修改磁盘上签出的文件，而是修改暂存区域或索引。
通常我们把这件事叫做。
通常最快捷的办法是使用工具。
通常根据你的暂存区域或来创建并写入一个。
通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。
通常，集中式工作流程使用的都是单点协作模型。
通过传递值给命令可以让返回任何对象的类型：
通过值获得提交内容中的提交信息的一个简单办法是找到提交的第一行，然后取从它往后的所有内容。
通过克隆一个仓库，你可以像下面这样给出的：
通过共享远程分支的方式，无需干扰整体项目代码便可以开展工作，因此使用的小型团队间协作可以变得非常灵活自由。
通过命令可以将数据内容取回。
通过它，你可以编写一个导入脚本来从导入源读取必要的信息，同时在标准输出直接输出相关指示。
通过属性，还能对项目中的特定文件使用不同的合并策略。
通过打包对象减少了一半磁盘使用空间。
通过推送的好处之一是你可以使用任何服务器，不需要为设定特殊环境；所以如果主机提供商支持通过更新网站内容，你也可以使用这项功能。
通过搜寻提交历史中分支的头部来决定的目的地——而它应该只有一个，那就是当前分支历史中最近一次包含的提交。
通过改变文件限制
通过查看这个新对象：
通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作，可以用来推送数据。
通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。
通过用户访问控制列表也能这么做，在本章结尾将会介绍这些有趣的方式。
通过获取推送到服务器内容的提交列表。
通过该命令人为的将文件的首个版本加入到了一个新的暂存区域中。
通过该命令可以获得作者的列表：
通过这一句可以获得一个所有已经完成推送的提交的列表：
通过这些工具，它会和你和公司或团队配合得天衣无缝。
通过进行推送操作也是可能的，不过这种做法不太常见，并且牵扯到复杂的设定。
通过逗号分割的链中去掉选项或在选项前加来关闭，例如，如果你想要打开除了之外的所有选项：
通配符从版本以上已经可以使用。
遇到冲突时的分支合并
避免修改历史再重新推送的做法，也不要同时推送到并行的仓库来试图与其他用户合作。
那么，又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。
那么，我们该怎样做才能确保代码是最新的，提交的补丁也是可用的呢？
那么，是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为的特别指针。
那么，现在运行一个实际的命令—克隆的控制仓库：
那么第一步要做的是，告诉怎么把你的二进制文件转化为纯文本格式，从而让普通的命令可以进行文本对比。
那么，简单地说，究竟是怎样的一个系统呢？请注意，接下来的内容非常重要，若是理解了的思想和基本工作原理，用起来就会知其所以然，游刃有余。
那条规则刚刚加入规则集的仓库
部分显示的是采纳补丁的人，以及采纳的时间。
配置完成后，您可以使用来发送你的补丁：
配置工作只需一次，以后升级时还会沿用现在的配置。
配置文件和访问规则
配置文件的语法在里，我们只会提到一些主要的。
采取这种办法的好处是，项目拥有者不必忙于应付赋予他人推送权限的工作。
采用命名空间的方式确实很棒，但组成员第次是如何将他们的分支推送到空间里面的呢？答案是你可以使用来推送。
采用版本控制系统是个明智的选择。
采纳来自邮件的补丁
重启之后，就可以通过项目的来克隆该目录下的仓库了。
重复一下，公钥大致看起来是这个样子：
重申一下，任何服务程序都可以达到相同效果；作为范例，我们将用一些基本的设定来展示大体需要的步骤。
重申一下，这一点只适用于非授权的只读访问。
针对之前给出的规则文件，这个方法返回的数据结构如下：
针对每个引用发送这样一行信息，就是旧的值，新的值，和将要更新的引用的名称。
针对每个引用，这次推送都会告诉对端的这个信息。
镜像可以帮助你维护多个镜像，如果主服务器挂掉的话在他们之间很容易切换。
附带的挂钩会默认运行合适的命令来确保通过的获取和克隆正常工作。
限制输出长度
除了定制输出格式的选项之外，还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。
除了客户端挂钩，作为系统管理员，你还可以使用两个服务器端的挂钩对项目实施各种类型的策略。
除了对应的克隆地址外，它还给出了许多额外的信息。
除此之外，以上每个选项都有子选项，可以被用来覆盖其父设置，以达到为输出的各个部分着色的目的。
除此之外，我们还需要学习如何管理分支，在日后的常规工作中会经常用到下面介绍的管理命令。
随便谁都可以通过派生得到一个项目副本并在其中展开工作，事后只需要项目维护者将这些副本仓库加为远程仓库，然后提取更新合并即可。
随后会讲解主要的挂钩脚本。
随后你会学到传输机制和最终要使用的各种库管理任务。
随后，在上提交了若干更新：
随后将自己的更新提交到这个仓库，所有人都可以看到你的每次更新。
集中化的版本控制系统
集中式工作流
集成管理员工作流
需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。
需要指定保存对象的路径值的头两个字符作为子目录名称，剩余个字符作为文件名保存至该子目录中。
需要注意的是此时没有任何内容被检出——刚开始当前目录里没有任何文件。
需要牢记的一点是，要求我们在推送之前先合并上游仓库中最新的内容，而只要求存在冲突的时候才这样做。
需要记住的是几个版本的文件值可能与实际的值不同，其次，存储的并不是文件名而仅仅是文件内容。
非到或者被第一条规则允许。
非常有趣，现在分支向前移动了一格，而分支仍然指向原先时所在的对象。
非常有趣的是第二个版本才是完整保存文件内容的对象，而第一个版本是以差异方式保存的──这是因为大部分情况下需要快速访问文件的最新版本。
项目中有多少开发者是经常提交代码的？经常又是多久呢？大多数两至三人的小团队，一天大约只有几次提交，如果不是什么热门项目的话就更少了。
项目有,多条提交，但我们给出搜索选项后，仅列出了其中满足条件的条。
项目本身就提供了一份文档项目源代码目录中，列数了大量提示，从如何编撰提交说明到提交补丁，不一而足。
项目本身就是这样要求的，我强烈建议你到项目仓库下运行看看，所有提交历史的说明是怎样撰写的。
项目本身有四个长期分支：用于发布的分支、用于合并基本稳定特性的分支、用于合并仍需改进特性的分支是的缩写，以及用于除错维护的分支取自。
项目本身还时常把分支名称分置于不同命名空间下，比如就说明这是这个人贡献的。
项目本身需要开发者撰写详尽注解，包括本次修订的因由，以及前后不同实现之间的比较，我们也该借鉴这种做法。
项目维护者可以推送数据到公共仓库。
项目还有一个分支，它是以最近一次发行版为基础分化而来的，用于维护除错补丁。
项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。
顺带说明下，并不同任何特定的问题追踪系统打交道。
预先设置了一些选项来探测和修正空白问题，其种主要选项中的个默认被打开，另个被关闭，你可以自由地打开或关闭它们。
预先设置了许多其他的合并和解决冲突的工具，而你不必设置。
首先，你应该在每次提交前核查你的提交注释信息，这样你才能确保服务器不会因为不合条件的提交注释信息而拒绝你的更改。
首先，你能够把的校验和自动注入文件的字段。
首先，你需要的源码，其中带有，并能生成定制的脚本：
首先先确认一下是否已经有一个公钥了。
首先，创建一个名为的用户，并为其创建一个目录。
首先，创建一个新文件，并把文件内容存储到数据库中：
首先初使化一个仓库并确认目录是空的：
首先，加一个大文件进去：
首先在文件中配置项。
首先，如果你想拥有对网络仓库的写权限，基本上不可能不使用。
首先，它可以离线工作，不像命令，需要向服务器索取数据。
首先，开启挂钩：
首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新见图。
首先，我们可以看到挂钩运行的起点：
首先把你要运行的命令放入外部包装脚本中，我会使用系统上的路径来指定该脚本的位置，在其他系统上，它应该被放置在二进制文件所在的目录中。
首先把这些数据读入你编写的数据结构。
首先查看一下当前的仓库状态：
首先注册一个免费账户。
首先要将代码的压缩包归档，方便那些可怜的还没有使用的人们。
首先要弄明白一点，从根本上来讲是一套内容寻址文件系统，在此之上提供了一个用户界面。
首先要找出这个文件。
首先要移动标签，把它们从奇怪的远程分支变成实际的标签，然后把剩下的分支移动到本地。
首先，要解决的是最令人头疼的问题：对文档进行版本控制。
首先，请不要在更新中提交多余的白字符。
首先运行的是挂钩，他接收一个参数：包含被建议提交信息的临时文件名。
首先，进入目标目录并且找到所有子目录，每一个子目录将作为一个快照被导入为一个。
首先需要导入该库，然后用对数据进行压缩：
首当其冲的是参与者规模。
马上你将详细了解是如何操纵这些内容的。
马上你就会学到这意味着什么。
默认不用任何参数的话，会按提交时间列出所有的更新，最近的更新排在最上面。
默认会使用操作系统指定的默认编辑器，一般可能会是或者。
默认会启用的环境变量所指定的软件，一般都是或。
默认会把作为存储所有仓库的根目录，这没什么不好，不过我们之前已经把项目仓库都放在里面了，所以为方便起见，我们可以做一个符号连接，直接划转过去，而不必重新配置：
默认会放置一些脚本样本在这个目录中，除了可以作为挂钩使用，这些样本本身是可以独立使用的。
默认会调用你的环境变量定义的值作为文本编辑器，如果没有定义的话，会调用来创建和编辑提交以及标签信息，你可以使用改变默认编辑器：
默认快速安装对大多数人都管用，还有一些定制安装方法如果你用的上的话。
默认情况下不会在推送期间检查所有对象的一致性。
默认情况下，并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。
默认打开的标签页面，则列出了该项目的目录结构和概要信息，并在下方自动展示文件的内容如果该文件存在的话，此外还会显示最近一次提交的相关信息。
默认被关闭的个选项是和，会查找个以上空格非制表符开头的行，让知道行尾回车符是合法的。
默认被打开的个选项是和，会查找每行结尾的空格，会查找每行开头的制表符前的空格。
鼓励开发者频繁使用分支，正是因为有着这些特性作保障。
