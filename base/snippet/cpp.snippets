# TextMate Snippets
priority -50
extends c

# We want to overwrite everything in parent ft.
priority -49

snippet incc
#include <${1:iostream}>
endsnippet

snippet binc
#include <boost/${1:shared_ptr}.hpp>
endsnippet	

## access modifiers
# 加了 : 和${0} 后，继承时就不好用了
snippet pri
private:
	${0}
endsnippet

snippet pro
protected:
	${0}
endsnippet

snippet pub
public:
	${0}
endsnippet
############


snippet fr
friend
endsnippet
	
#### STL
snippet vec
vector<${1:T}> ${2};${0}
endsnippet

snippet arr
array<${1:T}, ${2:N}> ${3};
endsnippet

snippet deq
deque<${1:T}> ${2};
endsnippet

snippet flist
forward_list<${1:T}> ${2};
endsnippet

snippet list
list<${1:T}> ${2};
endsnippet

snippet set
set<${1:T}> ${2};
endsnippet

snippet map
map<${1:Key}, ${2:T}> ${3};
endsnippet

snippet mset
multiset<${1:T}> ${2};
endsnippet

snippet mmap
multimap<${1:Key}, ${2:T}> ${3};
endsnippet

snippet uset
unordered_set<${1:T}> ${2};
endsnippet

snippet umap
unordered_map<${1:Key}, ${2:T}> ${3};
endsnippet

snippet umset
unordered_multiset<${1:T}> ${2};
endsnippet

snippet ummap
unordered_multimap<${1:Key}, ${2:T}> ${3};
endsnippet

snippet stack
stack<${1:T}> ${2};
endsnippet

snippet que
queue<${1:T}> ${2};
endsnippet

snippet pqu
priority_queue<${1:T}> ${2};
endsnippet

## Casts
snippet sca "static"
static_cast<${1:unsigned}>(${2:expr})${3}
endsnippet

snippet dca "dynamic"
dynamic_cast<${1:unsigned}>(${2:expr})${3}
endsnippet
 
snippet rca "reinterpret"
reinterpret_cast<${1:unsigned}>(${2:expr})${3}
endsnippet

snippet cca "const"
const_cast<${1:unsigned}>(${2:expr})${3}
endsnippet
## end Casts


## Iteration
snippet fori
for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
	${4}
}
endsnippet

snippet fore "foreach"
for (${1:auto} ${2:i} : ${3:container}) {
	${4}
}
endsnippet

snippet iter "iterator"
for (${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {
	${6}
}
endsnippet

snippet itera "auto iterator"
for (auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
	${3:std::cout << *$1 << std::endl;}
}
endsnippet

## Lambdas
snippet ld "lamda (one line)"
[${1}](${2}){${3}};
endsnippet

snippet lld "lambda (multi-line)"
[${1}](${2}){
	${3}
};
endsnippet
	
snippet beginend "$1.begin(), $1.end()"
${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
endsnippet

snippet ns
namespace${1/.+/ /m}${1:`!p snip.rv = snip.basename or "name"`}
{
	${VISUAL}${0}
}${1/.+/ \/* /m}$1${1/.+/ *\/ /m}
endsnippet

snippet us
using namespace ${1:std;}
endsnippet

snippet readfile "read file (readF)"
std::vector<char> v;
if (FILE *fp = fopen(${1:"filename"}, "r")) {
	char buf[1024];
	while(size_t len = fread(buf, 1, sizeof(buf), fp))
		v.insert(v.end(), buf, buf + len);
	fclose(fp);
}
endsnippet

snippet tp "template <typename ..> (template)"
template <typename ${1:_InputIter}>
endsnippet

snippet cl
class ${1:`!p snip.rv = snip.basename`}
{
public:
	${1/(\w+).*/$1/}(${2});
	virtual ~${1/(\w+).*/$1/}();
${0}
};
endsnippet

snippet mf "member function" 
${3:void} `!p snip.rv = snip.basename`::${1}(${2}) {
	${0}
}
endsnippet	

# vim:ft=snippets:
