PAC: password attempts counters
新型号的 at88sc  只支持3.3V 原来的支持5V，不论是3.3v 还是5v 电源，上拉都是3.3v的 验证后是可以的
at88无器件地址
5命令：0xb0/0xb2/0xb4/0xb6/0xb8/0xba(相当于I2C地址)
读/写用户区,读/写系统区,verify crypto,verify password

芯片上来什么都不做，直接读配制区和用户区
配置区240个字节可以读（最后16个字节是保留的）

存储空间：配置空间/用户空间
1-kbit EEPROM User Memory(128byte) 32Byte/Zone*4
每Zone可设访问权限，单字节写，16字节为一页写
2-kbit Configuration Zone(256byte)
37-byte OTP 用户自定义区域
160字节 用户自定义Key和Password
256个字节分成
Fabrication
Security
Identification
Secret
Passwords
System(最后16个字节不用)

密码7位置初始密码 Secure Code: 0xdd 0x42 0x97
知道此密码才能访问配置区

同步模式指2-Wire即I2C模式，异步模式指Smart Card模式，芯片只支持同步模式

3种通讯模式：标准/认证/加密

Password Verification:
可用密码控制用户区（4*32bytes）读写权限
密码3字节，读/写可设置不同密码
密码共8组（每组包括3字节写密码和3字节读密码），可用任一组密码保护4个zone的任何一个。
同一时刻，一个用户区域只能设置一组密码。
知道写密码，同时也有读权限，只知道读密码，没有写权限。

Authentication Protocol
也可通过认证协议来保护用户区域

AR: access register
PR: password register
有4组AR-PR 共8个字节

密码区有8个：
at88sc0104只有4个用户区，密码区有4个多余
若有16个用户区，多个用户区使用一个密码组

新片4个用户区域直接可操作，先选择区域，可读写

最后一步PER熔断，熔断后，种子区域就禁止读写了

认证分为Gc认证 和Sk认证

Gc 用户自定义F1算法得出秘密种子
算法： 内置64bit的加密算法
安全机制
1、标准访问：对用户存储区的读写访问无任何限制；
2、口令访问：对用户存储区的读写访问需要口令验证；
3、认证访问：须经过算法认证，同时要通过不同用户区所设定的口令检验才能访问用户数据区；
4、加密验证访问：先认证由认证成功后配置区新的数据为密钥再次认证，通过不同用户区设定的口令检验才可访问用户区，总线数据是密文。

认证流程：
用户系统首先从芯片中读出Nc（7个字节的芯片ID）和Ci（7字节 认证所需随机数），
根据自定义的F1(Nc，Ks)算法算出Gc
这个GC怎么是算出来的呢？

上面提到的F2算法，是芯片内部的控制逻辑利用Gc、Ci、Q0三个参数初始化的一个DES算法的变种

GPA 这里叫做伪随机数产生器pseudo-ramdom generator

Ci叫做密文  初始化时可写一随机数，认证卡时使用，每次认证会被自动改写。
Gc叫做密钥  64位的保密种子  密钥，64位的保密种子，由Nc通过F1公式推算出来，在个人化前，写入卡
    中。个人化后不可访问，认证时作为该卡的F2公式的参数。(详细用法参
    见认证协议)

AAC：为认证错误计数器，初始值为8

熔断之后，Ci还是可以Free读的 SK就不可以读了（这时指的是最高级的熔断） 

Gc秘密种子即秘钥，是很重要的信息，所以在程序的bin里不能出现这个7字节的种子
所以这个种子是通过ID算出来的

Ci和Sk 每次都要变化  Ci一直可以Free读  SK就不能读了
Ci是一直可以读的 ，注意
在应用程序里只提供一组非加密情况下读写eep的函数 比如四个区域中的某一个
拿出一个userZoon 作为一般的区域， free操作
一个区域使用密码作为特殊应用
另外两个区域设置成最高级别  加密+认证+密码 用来保护程序 共64个字节
前两个区域的操作都是公开的，很简单，代码到网上就能找到，所以不用特殊处理
需要特殊处理的在应用程序中出现的代码 就是 认证加密密码读 
对于加密区域的代码 放到系统段  .system 段
然后使用纯代码，而不是库！
这个代码只有认证加密密码 读

方法就是 在用户区2 ，3写入秘密数据 作为“种子”这个种子的作用跟 配置区的种子是一样的。
那么为什么不直接用配置区的种子呢？
因为配置区的种子 在知道ID号（即Nc）的情况下就可以在程序中算出来了  Nc又不是加密的 随时都可以读出来   所以用配置区的种子加密是没有任何意义的

那么只能是 用 用户区的秘密数据作为秘密种子   再用同样的方法加密、解密 这样就没有问题了。

Des算法就需要56位秘密种子

读密码 在程序中也是加密的。  把3字节密码扩展到8字节  然后用秘密种子（G）加密
（不行 如果这样做的话 每个程序中的加密后的密码就不一样 ）但是3字节密码也不能直接出现在程序中

AuthCryPw 的密码校验部分 删除单独的 Check_Pwd[7] 用来发送密码校验命令的，不使用这个可以节省堆栈空间

des算法使用了一个大数组，这个地方容易暴露，因为是linux的标准算法，要对这两个数组做简单处理，安全级别并没有提高。

用NC算出来的秘密种子 作为程序加密的种子 会怎样？这个Gc秘密种子也是读不出来的。不行，那样只要？？

1 不同的芯片，Lot History Code区的数据是不同的
2 4个user zone配置如下:没有全部权限的区域

在没有写熔断之前，  对写密码7进行了写操作，之后并没有写熔断   再次读配置区时  仍然用dd 42 97验证  这时读出的数据是没有写入dd 42 97之前的情况   
并且此组密码的PAC在以fe fc f8 f0 e0 c0 80 00的规律减小

写入dd 42 97后 对整个配置区有了写权限   这时可以向写密码7中写入其他密码如，并没有执行熔断处理。然后复位 或者是断电
再上电后又没有了对配置区的写权限  要想再获得写权限还需要验证写密码7  ，注意这时要用后来新写入的密码0x1f,0xff,0x11进行验证

讨论结果
1 程序解密后，立即恢复  防止整个text?段被读出然后替换
2 秘密种子不要存放到一处，并且要经过简单处理 不要直接存放到内存中
3 加密代码中不可以跟踪(关闭pmon)

首先，测试了des解密的算法 足够快  us级别  所以不用担心速度问题 （ 高清平台测试 ）

2 分散GC的问题  在一个大数组的上下分别定义两个GC  ：  UI8 Gc0  UI8 Gc1 但是编译完成后 还是跑到了一起 。

Gc认证 和 Sk认证的两次random可以不同  本来就是两次单独的认证。  

本来认为很简单的问题，结果弄了一天还没有弄完
1 F1算法的KS搞越界了 竟然写出来一个KS[ 8 ]
2 初始化后 在Gpa_SetInitGc后面调用了 ReadConfigZone 因为read这个函数会
变换Gpa数据 所以一定要在初始化之前调用read这个函数。
3 测试过程中，马虎马虎！！的没有写5个时钟的初始化
结果认证能通过，读数据的时候全部是0xff  我奇怪的是 为什么没有初始化 认证还能通过

做认证时，首先初始化状态机。初始化之后，发校验命令，这时开始，芯片内部的状态机就开始工作了，之后发的任何命令都会影响到状态机。
所以发过认证命令之后，再发读配置区的命令的时候，就会改变状态机的状态
  
同时，读配置区和读用户区命令的时候 使用的状态机改变算法是一样的  就是我程序中的Gpa_Read函数。这个函数在改变状态机的同时，还完成对数据的解密操作。

但是要注意，配置区 只有秘密区域是加密的  其他区域不加密！

刚才突然想到 ，既然我的程序加密就是靠写到用户区的8个字节的秘密数据作为种子，那费了这么半天劲，我在做什么？直接用加密芯片的秘密种子Gc不就行了吗？
当然不行？因为Gc是读不出来的，是通过F1算法算出来的。

用户区域写的数据的安全性也十分重要，如果被跟踪到，
如果跟踪到 读 用户区域 数据的程序位置，就可以一个字节一个字节的跟踪到，不过这时候的数据是加密的。
其实 在发送读用户区命令的时候，0xb2-0x00-地址-长度 这些数据在总线上走的时候的plaintext。
返回来的数据是密文。如果别人想知道用户区域的密文，从这里也可以得到。不过这个密文每次都会变化，所以这个密文是没有意义的。

但是如果在程序里，知道了密文，就可以跟到Gpa解密流程。所以Gpa解密 密文的过程也要融合到程序里

用户区域解密过程就是跟gpa_byte异或的过程

使用setkey的前段部分存expdata不好 因为这个函数执行第二次的时候 就会死机  暴露了程序的位置

1 20081231 AuthCryPw 里面的密码校验部分 删除单独的 Check_Pwd[ 7 ]
这个是用来发送密码校验命令的，不使用这个可以节省堆栈空间

2 20090102 des算法使用了一个大数组，这个地方容易暴露，因为是linux的标准算法
所以要对这两个数组做【简单的】处理  安全级别并没有提高 只是蒙蔽了一下

生成的.o文件 使用PC端加密工具加密后，link到工程里面即可

1 读芯片的时候 delay可以比较短  但是写的时候不能太短  否则写不进去
2 增减代码后，多处地址会发生变化  应用程序里面要改变main 和 dec_resum的地址
  同时改变 _dec_resum函数最后 恢复的地址  PC端加密工具也要变换响应地址。
另外 要选择是否使用 0x800  和 0xa00

使用user zoon2 区域的8个字节作为秘密种子 加密16条指令
好像并没有提高安全级别
如果不用user zoon2 里面的8字节 而只是在0x80040000 地址空间里面安排8个字节呢？
这两种的安全级别好像是否一样（不对，at88里面的8字节别人是不知道的）

加密的地方不能有条件判断  那样会跳转 导致不能执行 恢复加密的指令

5月7日 上面的说明 明确写着 增减代码后 要修改_dec_resum里面的恢复地址。
今天因为这个问题，又折腾了一天。
当时死到了一个操作系统里面，感觉这个死机的位置似曾相识，就是想不起来。
5月7日调试的时候，就是因为没有修改_dec_resum的恢复地址搞了一天。

起因还是从早晨烧写200个芯片说起。由于疏忽，sec写成了0  （没有调用F1）
所以想在程序里面做一下兼容。所以增加了代码，所以改变了main和dec resum的地址
所以应用程序里面和加密工具都改了，唯独忘记了改bin文件里面的恢复地址。

1  在AR设置全部Free的时候，用户区域是可以随意写入的，没有问题。
2 上电后经过初始化，不用写入安全密码 dd 42 97  就可以读出ATR
3b b2 11 00 10 80 00 01
当然还有其他很多数据可以读出来。
3 DCR的第一个位Device Configuration Register
SME  supervisor mode enable 校验了写密码7 就可以操作整个密码区域包括PAC,【即使在熔断以后，仍然可以操作】。
但是，在没有熔断的时候，即使写入了0xfb ，校验写密码，仍然可以操作整个密码区域 。

4 有一个很奇怪的问题 DCR设置成0xfb后，就不能认证通过了

5 注意了  烧写的时候，不容易写进去

总之需要注意  0x4B  的那个4  跟校验和有关系。

在调试程序的时候，不断电，直接重启，重新认证芯片
校验密码，但是芯片没有断电，这样没有问题吗？

我记得，如果这样做的话，第二次密码会密文，但是第二次有调用初始化函数
导致密码传输的是明文 会不会使得密码校验失败呢？

检测0x1b按键 实现一次下载程序  多次烧写
但是有个奇怪现象， 同一片芯片第一次读出user zoon2 数据是对的 第二次不对 但是好像
只是user区域不对  认证区域还是对的。

加密芯片工作失误：
DCR要重新设置
注意 DCR 0 is enable

今天奇怪的发现，验证了密码7后，在全部熔断的情况下，密码区域还可以读写
原因在于DCR的设置  bit7 为0 时 验证了密码7  就可以访问全部密码区域

应该设置成0xfb

DCR设置成0xfb后出现了新情况， 烧写程序不好用了

DCR的bit7 为0的时候  即使熔断了 密码区域写了 dd 42 97 后 仍然可以更改 ！！！！
校验了写密码7  就可以读写所有密码区域。这样，密码不就等于无意义了吗？ 写密码7 可以修改吗?

设置这个位后  密码区域只有校验了写密码后 才可以读/写 密码区域

上次写的那个 user区域读出来的数据一次对 一次错 当时就不知道什么原因
实际上密码早就不是数组里面写好的的，
但是下一次写的密码已经不是程序里面初始化的密码  user区域对的时候  是因为写入的密码正好是 修改过的密码
在那里修改的呢？在校验密码的时候修改的  也就是说 我多次按 ESC键 以后写入的密码已经是修改过的了 
分析 原来读user区域 一次对一次错的原因：

开始 密码区写 10 d0 31
校验读密码 正确  这时由于已经通过了认证  ，按照原来的程序， 校验完读密码后 读密码就被修改了 （这是一个很深的bug）
然后校验写密码正确 校验完成后 写密码也被修改

DCR写成 0xfb 没有成功

今天上午写的200片没有运行F1 导致这200片 秘密种子全是0

这次写的是iccdt008 如果最后是8 就把加密种子置成0 也只能这样了

现在我想用iccdt008  后面的008 来区分 secret是否为全0 
那么以后的加密片就不能用008作为结尾。

其实我用时间来区分最好，今天写的芯片已经标识了090525这个日期了

现在检测id[7] ==  '8' 就清零secret
今天（090525）的199片 全部是寄给九联的
搞不好，一直要维护这个问题，因为这199台机器一直都是要升级的。

当然是有区别的：
1 如果没有应用程序加密，只需要在应用程序里面找到at88初始化的地方注释掉初始化就可以了
2 如果程序加密，但是使用的3des加密8字节在内存里面，应用程序注释掉at88初始化，同样可以解密。
  但是话说回来：我在at88初始化里面对内存中的8字节做些处理不就行了？
  没有校验通过，同样可以达到无法解密应用程序的目的。
  【我现在认为8个字节写到at88sc里面 跟写到内存里面，加些特殊处理，效果是一样的 安全级别也一样】

3 只要种子被破解，就代表完全被破解了。如果种子被破解，就没有任何补救措施了【不过还有4次机会的密码】

但是种子已经无论如何都不能修改了。最关键的是GC

1 AuthCryPw 里面的密码校验部分 删除单独的 Check_Pwd[ 7 ]
这个数组是用来发送密码校验命令的，不使用这个可以节省堆栈空间

配置区的AR-PR都是0xff所以用户区域是Free的
这时候用户区域可以直接读写，只需要执行区域选择然后就可以读写了
可以单个字节写 也可以16字节或者8字节为一个page一起写

在SelectZone和WriteUserZone的时候都要运算Gpa
但是在这两个命令中，运算gpa后并不影响命令和数据
只是利用命令和数据，来改变Gpa的Gpa_byte 和Gap_din_gpa
这是在非加密的情况下，如果在加密的情况下即Encrypted==1的时候
就会改变，并且只改变数据部分，也就是第5个字节开始加密

执行完命令后 为什么要加0xb6然后等ACK呢？
当时调试的时候 这里确实是有问题的
是不停的发送0xb6 等ACK

电就可以free方式访问 用户区

写密码{0xDD,0x42,0x97};后 再读配置区：

密钥Gc  用一个二元算法得到 Gc = F1(Nc,Ks)

每个芯片的Nc不同  Ci也不同 并且   Ci一直的可以读出来的   SK不可读 G不可读

配置的值由Dll提供  这个Dll同时提供F1算法

在芯片电源管角 加 0.7V 的电压 ；正向时：电流几乎为0；反向时：会有相对大的一个电流有几十ma。
采样电阻 运放 电压采集放大 电压比较器  

Ci部分一直都是免费读取的，无论在熔断，加密还是认证
Q0是主机生成的随机数，程序中只用了3次

注意这里面有一个细节
在读配置区的时候 在进行了GC认证  SK认证之后，数据线上的数据就是加密的了 
【但是】在读配置区的时候！！！只有密码区域（包括PAC）是加密数据  其他的地方是明文
page24 Configuration data includes the entire Configuration Zone [except the passwords]
密码区域是加密的【密文】

DRV_AT0104_Authenticate 函数 调用 Gpa_Auth
这里还有一个安全隐患  就是在Gpa_SetInit( Cix, GC, Random );的时候 把Gc存储到了
Gpa.Key里  就一直不变了   所以这个秘密种子Gc 实际上是以数组的形式存放到了内存里面 不够安全

所以我在程序中，做完认证操作之后，需要立刻将秘密种子删除（清零）

0xb8 是verify 认证和加密的命令
这个命令发送16个字节 8个主机产生的随机数 + 8个challenge字节
是在这里产生了联系

终于明白网上这段解释
“初始化时，首先要向第七组写密码区中写入配置区的写入密码。只有正确写入该密码后用户才可以获得对整个配置区的写入权力，
这个密码由芯片供应商提供。正确写入密码后就可以根据要求对芯片的各个寄存器进行配置，最后还要根据用户需要，将生产厂商信息、
分区设置、安全等级和密码以及加密认证所需参数等写入芯片的配置区，最后还要进行写熔断的处理。注意，芯片一旦被写熔断后就无法
再对配置区的信息进行更改。在对配置区进行合理配置的同时，要将认证所需的三组重要的参数写入到配置区相应的寄存器中。
这三组数分别是：Ci(Cryptograms)认证所需的随机数，Nc(Identification Number)芯片序列号，Gc(Secret Seeds) 
由用户自定义的F1算法得出的秘密种子。
”
用户MCU先从芯片中读出Nc和Ci，根据自定义F1(Nc，Ks)算法算出Gc，利用芯片的F2(Gc，Ci，Q0)算法算出Q1，并向芯片发送初始化认证参数Q1和Q0，
这里的Q1 是资料上的Challenge
"其中，Q0是CPU方给出的随机数。芯片内部则利用自己的F2逻辑算出Ci+1=F2(Gc，Ci，Q0)"

资料中描述的Ci+1是什么意思？  Ci是7个字节 Ci+1难道代表8个字节？ 还是代表一组新的Ci值？莫名其妙
还有Ci+2 的表示方法 所以Ci+2不可能代表9个字节啊  那么还是代表不同组的Ci

流程：
芯片用Gc 原来的Ci 和Q（主机发过来的random）计算出Ci+1（一组新的Ci）【这个Ci+1是几个字节呢？7个？8个？】
然后用Ci+1 跟主机发过来的Challenge比较  主机的Challenge也是通过Ci Gc Random算出来的。 比较成功 则完成了Verify A  如果相等 芯片就会写一个新的Ci+2到Ci区域
Obviously, Ci+2 是不同于Ci+1也就是Challenge的 Ci+2
Ci+2 是我程序里面的New_Ci

page65 
//If the host sends a valid host challenge Ch, the device will compute a new Ci and Sk and write these in eeprom.
Ci[0] = 0xff  //The first byte of Ci is the AAC

注意：完成加密后（SK认证完成后），配置区除了密码区域外 还都是明文
只有读密码区域的时候是密文。所以我原来的程序还是有bug的 （读配置区的函数）

关于【校验和】checksum  CS
MAC  Message Authentication Code 信息认证码
显然 这里所说的校验和并不是简单的把数据相加 

DCR寄存器即Nc前的1字节
第四位是芯片的地址  高四位有一个  UCR  
意思是经过了认证 加密之后 读取了用户区，不用进行新的认证就可以再次读取
试验的结果是：

如果这个位无效
1 DRV_AT0104_SelectZone(3,0);
2 TestStatus = DRV_AT0104_Authenticate(0x03,Random,GC,SK,GC_SEED);
3 TestStatus = DRV_AT0104_Authenticate(0x03,Random,GC,SK,SK_SEED);
//DRV_AT0104_ReadConfigZone(176,64,Rddata+176);
4 DRV_AT0104_VerifyPassword(0x03,PassWord3+5,Read);
5 DRV_AT0104_ReadUserZone(0,12,ReadUserZone);
6 DRV_AT0104_ReadChecksum(ReadCheckSum);
可以正确读出 ReadUserZone 
但是这时如果重复5  则无法读出正确的数据
如果不重复操作5 而是接着

7 DRV_AT0104_VerifyPassword(0x03,PassWord3+1,Write);
8 DRV_AT0104_WriteUserZone(0,12,0,UserTest);
9 DRV_AT0104_SendChecksum();
也不能写成功

注意 写校验和是必须的 
而读校验和 是需要读回来 跟本地计算出来的CS比较的 不比较也没有问题

如果将校验密码的函数再执行一次 就会出错 其他的函数如果被执行 
再调用DRV_AT0104_ReadUserZone 也就出错了

只要不发读checksum命令  加密机就不会复位 这时即使UCR无效 也可不断读用户区

在认证加密完成后 如果UCR=1  则在不读校验和的情况下
a 可以对用户区多次读 但是这时如果再进行一次读密码校验 再读用户区就不行了

从上面a处  开始 执行写密码校验 然后可以正确写入 并且可以不停写入
写入用户区时可以写校验和 可以不写校验和 都没有关系
并且可以多次写入  但是 如果再次进行写密码校验
就不能正常写了 也不能正常读了  这个还不知道是什么原因

如果UCR==0
则没有读校验和的限制  我可以读多次校验和  都仍然可以读用户区
我可以读多次校验和  在读用户区  或者不停的读用户区 都没有问题

